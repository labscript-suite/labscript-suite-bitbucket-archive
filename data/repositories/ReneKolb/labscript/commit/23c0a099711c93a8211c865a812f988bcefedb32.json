{"rendered": {"message": {"raw": "Added initial support for shutter calibration. At the moment a calibration file is simply produced by calibrate_shutters.py, and a comment in that file\ndescribes the future plans for how this will be produced. Calibrations are stored as attributes in a hdf5 file calibrations.h5.\n\nWhen instantiating a shutter, a labscript user can add an argument: delay=(open_delay,close_delay), to specify the delays in the script, or can set delay='calibrated' to instruct labscript\nto find the delays in the calibrations.h5 file. They are attributes to the group /shutters/shuttername, where shuttername is the name of the shutter object, given\nto it as the first argument when the user instantiates it.\n\nAlso this commit makes devices attached to pulseblaster flags processed as being on the slow clock. There can be no constant clock rate ramps for such devices, since the pulseblaster\nitself does not output buffered values when it gets a clock tick. Rather, a separate instruction is required every time an output changes state. The output produced is identical, but\ninternally labscript no longer expands the pulseblaster flags to their values at every time in the fast clock.\n\nIf this change hadn't been made, then we would have run into problems with the pulseblaster DDS outputs, once functionality for them is implemented.* It is nonsensical to ask one of them\nto do a ramp on the fast clock, since every update requires a new pulseblaster instruction, and the fast clock is implemented with loops. Ramps will have to be done with repeated calls to\nDDS.set_amp(t, value) etc. This can still be abstracted away to perform fast ramps (or ones with a non constant update rate), but there is a risk that these instructions will collide with\ninstructions on the devices attached to the flags, exceeding their maximum update rate. In this case labscript throws an error. Really the slow clock shouldn't be used that way, and if we\nneed pulseblaster or novatech boards to do ramps like that we should make sure nothing else on the pulseblaster flags needs to change state at the same time.\n\nThese are the sorts of things we should consider when deciding what thing to plug into what pulseblaster!", "markup": "markdown", "html": "<p>Added initial support for shutter calibration. At the moment a calibration file is simply produced by calibrate_shutters.py, and a comment in that file<br />\ndescribes the future plans for how this will be produced. Calibrations are stored as attributes in a hdf5 file calibrations.h5.</p>\n<p>When instantiating a shutter, a labscript user can add an argument: delay=(open_delay,close_delay), to specify the delays in the script, or can set delay='calibrated' to instruct labscript<br />\nto find the delays in the calibrations.h5 file. They are attributes to the group /shutters/shuttername, where shuttername is the name of the shutter object, given<br />\nto it as the first argument when the user instantiates it.</p>\n<p>Also this commit makes devices attached to pulseblaster flags processed as being on the slow clock. There can be no constant clock rate ramps for such devices, since the pulseblaster<br />\nitself does not output buffered values when it gets a clock tick. Rather, a separate instruction is required every time an output changes state. The output produced is identical, but<br />\ninternally labscript no longer expands the pulseblaster flags to their values at every time in the fast clock.</p>\n<p>If this change hadn't been made, then we would have run into problems with the pulseblaster DDS outputs, once functionality for them is implemented.* It is nonsensical to ask one of them<br />\nto do a ramp on the fast clock, since every update requires a new pulseblaster instruction, and the fast clock is implemented with loops. Ramps will have to be done with repeated calls to<br />\nDDS.set_amp(t, value) etc. This can still be abstracted away to perform fast ramps (or ones with a non constant update rate), but there is a risk that these instructions will collide with<br />\ninstructions on the devices attached to the flags, exceeding their maximum update rate. In this case labscript throws an error. Really the slow clock shouldn't be used that way, and if we<br />\nneed pulseblaster or novatech boards to do ramps like that we should make sure nothing else on the pulseblaster flags needs to change state at the same time.</p>\n<p>These are the sorts of things we should consider when deciding what thing to plug into what pulseblaster!</p>", "type": "rendered"}}, "hash": "23c0a099711c93a8211c865a812f988bcefedb32", "repository": {"links": {"self": {"href": "data/repositories/ReneKolb/labscript.json"}, "html": {"href": "#!/ReneKolb/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e5bcc338-0f71-423d-a5e3-5e9b093934f9}ts=python"}}, "type": "repository", "name": "labscript", "full_name": "ReneKolb/labscript", "uuid": "{e5bcc338-0f71-423d-a5e3-5e9b093934f9}"}, "links": {"self": {"href": "data/repositories/ReneKolb/labscript/commit/23c0a099711c93a8211c865a812f988bcefedb32.json"}, "comments": {"href": "data/repositories/ReneKolb/labscript/commit/23c0a099711c93a8211c865a812f988bcefedb32/comments_page=1.json"}, "patch": {"href": "https://api.bitbucket.org/2.0/repositories/ReneKolb/labscript/patch/23c0a099711c93a8211c865a812f988bcefedb32"}, "html": {"href": "#!/ReneKolb/labscript/commits/23c0a099711c93a8211c865a812f988bcefedb32"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/ReneKolb/labscript/diff/23c0a099711c93a8211c865a812f988bcefedb32"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/ReneKolb/labscript/commit/23c0a099711c93a8211c865a812f988bcefedb32/approve"}, "statuses": {"href": "data/repositories/ReneKolb/labscript/commit/23c0a099711c93a8211c865a812f988bcefedb32/statuses_page=1.json"}}, "author": {"raw": "cbilling", "type": "author", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}}, "summary": {"raw": "Added initial support for shutter calibration. At the moment a calibration file is simply produced by calibrate_shutters.py, and a comment in that file\ndescribes the future plans for how this will be produced. Calibrations are stored as attributes in a hdf5 file calibrations.h5.\n\nWhen instantiating a shutter, a labscript user can add an argument: delay=(open_delay,close_delay), to specify the delays in the script, or can set delay='calibrated' to instruct labscript\nto find the delays in the calibrations.h5 file. They are attributes to the group /shutters/shuttername, where shuttername is the name of the shutter object, given\nto it as the first argument when the user instantiates it.\n\nAlso this commit makes devices attached to pulseblaster flags processed as being on the slow clock. There can be no constant clock rate ramps for such devices, since the pulseblaster\nitself does not output buffered values when it gets a clock tick. Rather, a separate instruction is required every time an output changes state. The output produced is identical, but\ninternally labscript no longer expands the pulseblaster flags to their values at every time in the fast clock.\n\nIf this change hadn't been made, then we would have run into problems with the pulseblaster DDS outputs, once functionality for them is implemented.* It is nonsensical to ask one of them\nto do a ramp on the fast clock, since every update requires a new pulseblaster instruction, and the fast clock is implemented with loops. Ramps will have to be done with repeated calls to\nDDS.set_amp(t, value) etc. This can still be abstracted away to perform fast ramps (or ones with a non constant update rate), but there is a risk that these instructions will collide with\ninstructions on the devices attached to the flags, exceeding their maximum update rate. In this case labscript throws an error. Really the slow clock shouldn't be used that way, and if we\nneed pulseblaster or novatech boards to do ramps like that we should make sure nothing else on the pulseblaster flags needs to change state at the same time.\n\nThese are the sorts of things we should consider when deciding what thing to plug into what pulseblaster!", "markup": "markdown", "html": "<p>Added initial support for shutter calibration. At the moment a calibration file is simply produced by calibrate_shutters.py, and a comment in that file<br />\ndescribes the future plans for how this will be produced. Calibrations are stored as attributes in a hdf5 file calibrations.h5.</p>\n<p>When instantiating a shutter, a labscript user can add an argument: delay=(open_delay,close_delay), to specify the delays in the script, or can set delay='calibrated' to instruct labscript<br />\nto find the delays in the calibrations.h5 file. They are attributes to the group /shutters/shuttername, where shuttername is the name of the shutter object, given<br />\nto it as the first argument when the user instantiates it.</p>\n<p>Also this commit makes devices attached to pulseblaster flags processed as being on the slow clock. There can be no constant clock rate ramps for such devices, since the pulseblaster<br />\nitself does not output buffered values when it gets a clock tick. Rather, a separate instruction is required every time an output changes state. The output produced is identical, but<br />\ninternally labscript no longer expands the pulseblaster flags to their values at every time in the fast clock.</p>\n<p>If this change hadn't been made, then we would have run into problems with the pulseblaster DDS outputs, once functionality for them is implemented.* It is nonsensical to ask one of them<br />\nto do a ramp on the fast clock, since every update requires a new pulseblaster instruction, and the fast clock is implemented with loops. Ramps will have to be done with repeated calls to<br />\nDDS.set_amp(t, value) etc. This can still be abstracted away to perform fast ramps (or ones with a non constant update rate), but there is a risk that these instructions will collide with<br />\ninstructions on the devices attached to the flags, exceeding their maximum update rate. In this case labscript throws an error. Really the slow clock shouldn't be used that way, and if we<br />\nneed pulseblaster or novatech boards to do ramps like that we should make sure nothing else on the pulseblaster flags needs to change state at the same time.</p>\n<p>These are the sorts of things we should consider when deciding what thing to plug into what pulseblaster!</p>", "type": "rendered"}, "participants": [], "parents": [{"hash": "3f3b22915cc004442a73ecc761581d27754f2afb", "type": "commit", "links": {"self": {"href": "data/repositories/ReneKolb/labscript/commit/3f3b22915cc004442a73ecc761581d27754f2afb.json"}, "html": {"href": "#!/ReneKolb/labscript/commits/3f3b22915cc004442a73ecc761581d27754f2afb"}}}], "date": "2011-03-31T07:39:15+00:00", "message": "Added initial support for shutter calibration. At the moment a calibration file is simply produced by calibrate_shutters.py, and a comment in that file\ndescribes the future plans for how this will be produced. Calibrations are stored as attributes in a hdf5 file calibrations.h5.\n\nWhen instantiating a shutter, a labscript user can add an argument: delay=(open_delay,close_delay), to specify the delays in the script, or can set delay='calibrated' to instruct labscript\nto find the delays in the calibrations.h5 file. They are attributes to the group /shutters/shuttername, where shuttername is the name of the shutter object, given\nto it as the first argument when the user instantiates it.\n\nAlso this commit makes devices attached to pulseblaster flags processed as being on the slow clock. There can be no constant clock rate ramps for such devices, since the pulseblaster\nitself does not output buffered values when it gets a clock tick. Rather, a separate instruction is required every time an output changes state. The output produced is identical, but\ninternally labscript no longer expands the pulseblaster flags to their values at every time in the fast clock.\n\nIf this change hadn't been made, then we would have run into problems with the pulseblaster DDS outputs, once functionality for them is implemented.* It is nonsensical to ask one of them\nto do a ramp on the fast clock, since every update requires a new pulseblaster instruction, and the fast clock is implemented with loops. Ramps will have to be done with repeated calls to\nDDS.set_amp(t, value) etc. This can still be abstracted away to perform fast ramps (or ones with a non constant update rate), but there is a risk that these instructions will collide with\ninstructions on the devices attached to the flags, exceeding their maximum update rate. In this case labscript throws an error. Really the slow clock shouldn't be used that way, and if we\nneed pulseblaster or novatech boards to do ramps like that we should make sure nothing else on the pulseblaster flags needs to change state at the same time.\n\nThese are the sorts of things we should consider when deciding what thing to plug into what pulseblaster!", "type": "commit", "git_hash": "24a8aa4b2444e3db4c900cdec12d3a70334ab202", "tags": null, "branches": "default"}