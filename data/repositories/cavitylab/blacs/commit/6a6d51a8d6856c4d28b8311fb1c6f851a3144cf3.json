{"rendered": {"message": {"raw": "Fixed colour scheme of buttons!\n\nHover colours now make sense. Colour scheme can be adjusted via the blacs.gtkrc file\n\nImplemented locking for Digital widgets properly. This locking doesn't actually set the widget insensitive, as we need the widget to respond so we can unlock it again! We do a bit of hackery to achieve this, and we need to make sure that we:\n\nA) Don't accidentally program the device to the opposite of the locked value, and program it back (digital edges are bad!)\n\nB) Locked digital widgets update themselves correctly when using the set_state method at the end of the experiment!\n\nFurther testing along these lines indicates that the program method gets called even when a widget is locked, but at least it is never asked to program the wrong value (it only ever programs the locked value)\n\nI still need to implement the restoring of the locked state of a widget!", "markup": "markdown", "html": "<p>Fixed colour scheme of buttons!</p>\n<p>Hover colours now make sense. Colour scheme can be adjusted via the blacs.gtkrc file</p>\n<p>Implemented locking for Digital widgets properly. This locking doesn't actually set the widget insensitive, as we need the widget to respond so we can unlock it again! We do a bit of hackery to achieve this, and we need to make sure that we:</p>\n<p>A) Don't accidentally program the device to the opposite of the locked value, and program it back (digital edges are bad!)</p>\n<p>B) Locked digital widgets update themselves correctly when using the set_state method at the end of the experiment!</p>\n<p>Further testing along these lines indicates that the program method gets called even when a widget is locked, but at least it is never asked to program the wrong value (it only ever programs the locked value)</p>\n<p>I still need to implement the restoring of the locked state of a widget!</p>", "type": "rendered"}}, "hash": "6a6d51a8d6856c4d28b8311fb1c6f851a3144cf3", "repository": {"links": {"self": {"href": "data/repositories/cavitylab/blacs.json"}, "html": {"href": "#!/cavitylab/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{95ce113a-2d94-42de-b9fb-c31ba362c5f1}ts=python"}}, "type": "repository", "name": "BLACS", "full_name": "cavitylab/blacs", "uuid": "{95ce113a-2d94-42de-b9fb-c31ba362c5f1}"}, "links": {"self": {"href": "data/repositories/cavitylab/blacs/commit/6a6d51a8d6856c4d28b8311fb1c6f851a3144cf3.json"}, "comments": {"href": "data/repositories/cavitylab/blacs/commit/6a6d51a8d6856c4d28b8311fb1c6f851a3144cf3/comments_page=1.json"}, "patch": {"href": "https://api.bitbucket.org/2.0/repositories/cavitylab/blacs/patch/6a6d51a8d6856c4d28b8311fb1c6f851a3144cf3"}, "html": {"href": "#!/cavitylab/blacs/commits/6a6d51a8d6856c4d28b8311fb1c6f851a3144cf3"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/cavitylab/blacs/diff/6a6d51a8d6856c4d28b8311fb1c6f851a3144cf3"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/cavitylab/blacs/commit/6a6d51a8d6856c4d28b8311fb1c6f851a3144cf3/approve"}, "statuses": {"href": "data/repositories/cavitylab/blacs/commit/6a6d51a8d6856c4d28b8311fb1c6f851a3144cf3/statuses_page=1.json"}}, "author": {"raw": "pstarkey", "type": "author", "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}}, "summary": {"raw": "Fixed colour scheme of buttons!\n\nHover colours now make sense. Colour scheme can be adjusted via the blacs.gtkrc file\n\nImplemented locking for Digital widgets properly. This locking doesn't actually set the widget insensitive, as we need the widget to respond so we can unlock it again! We do a bit of hackery to achieve this, and we need to make sure that we:\n\nA) Don't accidentally program the device to the opposite of the locked value, and program it back (digital edges are bad!)\n\nB) Locked digital widgets update themselves correctly when using the set_state method at the end of the experiment!\n\nFurther testing along these lines indicates that the program method gets called even when a widget is locked, but at least it is never asked to program the wrong value (it only ever programs the locked value)\n\nI still need to implement the restoring of the locked state of a widget!", "markup": "markdown", "html": "<p>Fixed colour scheme of buttons!</p>\n<p>Hover colours now make sense. Colour scheme can be adjusted via the blacs.gtkrc file</p>\n<p>Implemented locking for Digital widgets properly. This locking doesn't actually set the widget insensitive, as we need the widget to respond so we can unlock it again! We do a bit of hackery to achieve this, and we need to make sure that we:</p>\n<p>A) Don't accidentally program the device to the opposite of the locked value, and program it back (digital edges are bad!)</p>\n<p>B) Locked digital widgets update themselves correctly when using the set_state method at the end of the experiment!</p>\n<p>Further testing along these lines indicates that the program method gets called even when a widget is locked, but at least it is never asked to program the wrong value (it only ever programs the locked value)</p>\n<p>I still need to implement the restoring of the locked state of a widget!</p>", "type": "rendered"}, "participants": [], "parents": [{"hash": "10845ef642ac47250dc288dff11abab7fe22516a", "type": "commit", "links": {"self": {"href": "data/repositories/cavitylab/blacs/commit/10845ef642ac47250dc288dff11abab7fe22516a.json"}, "html": {"href": "#!/cavitylab/blacs/commits/10845ef642ac47250dc288dff11abab7fe22516a"}}}], "date": "2012-02-15T11:40:24+00:00", "message": "Fixed colour scheme of buttons!\n\nHover colours now make sense. Colour scheme can be adjusted via the blacs.gtkrc file\n\nImplemented locking for Digital widgets properly. This locking doesn't actually set the widget insensitive, as we need the widget to respond so we can unlock it again! We do a bit of hackery to achieve this, and we need to make sure that we:\n\nA) Don't accidentally program the device to the opposite of the locked value, and program it back (digital edges are bad!)\n\nB) Locked digital widgets update themselves correctly when using the set_state method at the end of the experiment!\n\nFurther testing along these lines indicates that the program method gets called even when a widget is locked, but at least it is never asked to program the wrong value (it only ever programs the locked value)\n\nI still need to implement the restoring of the locked state of a widget!", "type": "commit", "git_hash": "d430562c255443762ce6f9a0a1f4acbcd9091995", "tags": null, "branches": "default"}