{"rendered": {"message": {"raw": "Add a function `get_unit_conversion_class(fullname)` to unitconversions module.\nIf a fully qualified class name is provided, this will import just the class\nspecified (even if it is not located within the unitconversions folder).\n\nOtherwise, if just a class name is given without a full import path,\nit falls back to importing everything to find the class of the given\nname. This provides backward compatibility with shots compiled with versions\nof labscript that save the class name only (i.e. the current version).\n\nA custom `__all__` provides backward compatibility for versions of BLACS\n(i.e. the current version) that import * from unitconversions. Submodules\nare only imported en-masse if `__all__` is actually acessed, at which point\nall the classes are imported and loaded into the globals dictionary (and their\nnames added to `__all__`).\n\nThis custom `__all__` even takes the bizarre step of adding items to the\n`globals()` dictionary (and to `__all__`) with the fully qualified names, e.g.\n'labscript_utils.unitconversions.submodule.SomeClass', usually disallowed\nvariable names in Python. This ensures that if an old version of BLACS\n(i.e. the current version) imports * and inspects its `globals()` dict looking\nfor unit conversion classes, it will still find them, even if the shot file\nthe conversion class name is coming from was compiled with a newer version of\nlabscript that saves the full paths.\n\nThis change paves the way for:\n\n* lascript to save fully qualified unit conversion class names, allowing\n  unit conversion classes to be stored within userlib instead of labscript_utils.\n\n* BLACS to improve performance by not importing all the classes en-masse.\n\nwhilst supporting full backward compatibility.", "markup": "markdown", "html": "<p>Add a function <code>get_unit_conversion_class(fullname)</code> to unitconversions module.<br />\nIf a fully qualified class name is provided, this will import just the class<br />\nspecified (even if it is not located within the unitconversions folder).</p>\n<p>Otherwise, if just a class name is given without a full import path,<br />\nit falls back to importing everything to find the class of the given<br />\nname. This provides backward compatibility with shots compiled with versions<br />\nof labscript that save the class name only (i.e. the current version).</p>\n<p>A custom <code>__all__</code> provides backward compatibility for versions of BLACS<br />\n(i.e. the current version) that import * from unitconversions. Submodules<br />\nare only imported en-masse if <code>__all__</code> is actually acessed, at which point<br />\nall the classes are imported and loaded into the globals dictionary (and their<br />\nnames added to <code>__all__</code>).</p>\n<p>This custom <code>__all__</code> even takes the bizarre step of adding items to the<br />\n<code>globals()</code> dictionary (and to <code>__all__</code>) with the fully qualified names, e.g.<br />\n'labscript_utils.unitconversions.submodule.SomeClass', usually disallowed<br />\nvariable names in Python. This ensures that if an old version of BLACS<br />\n(i.e. the current version) imports * and inspects its <code>globals()</code> dict looking<br />\nfor unit conversion classes, it will still find them, even if the shot file<br />\nthe conversion class name is coming from was compiled with a newer version of<br />\nlabscript that saves the full paths.</p>\n<p>This change paves the way for:</p>\n<ul>\n<li>\n<p>lascript to save fully qualified unit conversion class names, allowing<br />\n  unit conversion classes to be stored within userlib instead of labscript_utils.</p>\n</li>\n<li>\n<p>BLACS to improve performance by not importing all the classes en-masse.</p>\n</li>\n</ul>\n<p>whilst supporting full backward compatibility.</p>", "type": "rendered"}}, "hash": "65f77dd71b8e8f53b7dece3f5219650e81f1fdcd", "repository": {"links": {"self": {"href": "data/repositories/cbillington/labscript_utils.json"}, "html": {"href": "#!/cbillington/labscript_utils"}, "avatar": {"href": "data/bytebucket.org/ravatar/{455d0b5d-4852-4e4a-b8b1-f5ba77882210}ts=python"}}, "type": "repository", "name": "labscript_utils", "full_name": "cbillington/labscript_utils", "uuid": "{455d0b5d-4852-4e4a-b8b1-f5ba77882210}"}, "links": {"self": {"href": "data/repositories/cbillington/labscript_utils/commit/65f77dd71b8e8f53b7dece3f5219650e81f1fdcd.json"}, "comments": {"href": "data/repositories/cbillington/labscript_utils/commit/65f77dd71b8e8f53b7dece3f5219650e81f1fdcd/comments_page=1.json"}, "patch": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_utils/patch/65f77dd71b8e8f53b7dece3f5219650e81f1fdcd"}, "html": {"href": "#!/cbillington/labscript_utils/commits/65f77dd71b8e8f53b7dece3f5219650e81f1fdcd"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_utils/diff/65f77dd71b8e8f53b7dece3f5219650e81f1fdcd"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_utils/commit/65f77dd71b8e8f53b7dece3f5219650e81f1fdcd/approve"}, "statuses": {"href": "data/repositories/cbillington/labscript_utils/commit/65f77dd71b8e8f53b7dece3f5219650e81f1fdcd/statuses_page=1.json"}}, "author": {"raw": "chrisjbillington", "type": "author"}, "summary": {"raw": "Add a function `get_unit_conversion_class(fullname)` to unitconversions module.\nIf a fully qualified class name is provided, this will import just the class\nspecified (even if it is not located within the unitconversions folder).\n\nOtherwise, if just a class name is given without a full import path,\nit falls back to importing everything to find the class of the given\nname. This provides backward compatibility with shots compiled with versions\nof labscript that save the class name only (i.e. the current version).\n\nA custom `__all__` provides backward compatibility for versions of BLACS\n(i.e. the current version) that import * from unitconversions. Submodules\nare only imported en-masse if `__all__` is actually acessed, at which point\nall the classes are imported and loaded into the globals dictionary (and their\nnames added to `__all__`).\n\nThis custom `__all__` even takes the bizarre step of adding items to the\n`globals()` dictionary (and to `__all__`) with the fully qualified names, e.g.\n'labscript_utils.unitconversions.submodule.SomeClass', usually disallowed\nvariable names in Python. This ensures that if an old version of BLACS\n(i.e. the current version) imports * and inspects its `globals()` dict looking\nfor unit conversion classes, it will still find them, even if the shot file\nthe conversion class name is coming from was compiled with a newer version of\nlabscript that saves the full paths.\n\nThis change paves the way for:\n\n* lascript to save fully qualified unit conversion class names, allowing\n  unit conversion classes to be stored within userlib instead of labscript_utils.\n\n* BLACS to improve performance by not importing all the classes en-masse.\n\nwhilst supporting full backward compatibility.", "markup": "markdown", "html": "<p>Add a function <code>get_unit_conversion_class(fullname)</code> to unitconversions module.<br />\nIf a fully qualified class name is provided, this will import just the class<br />\nspecified (even if it is not located within the unitconversions folder).</p>\n<p>Otherwise, if just a class name is given without a full import path,<br />\nit falls back to importing everything to find the class of the given<br />\nname. This provides backward compatibility with shots compiled with versions<br />\nof labscript that save the class name only (i.e. the current version).</p>\n<p>A custom <code>__all__</code> provides backward compatibility for versions of BLACS<br />\n(i.e. the current version) that import * from unitconversions. Submodules<br />\nare only imported en-masse if <code>__all__</code> is actually acessed, at which point<br />\nall the classes are imported and loaded into the globals dictionary (and their<br />\nnames added to <code>__all__</code>).</p>\n<p>This custom <code>__all__</code> even takes the bizarre step of adding items to the<br />\n<code>globals()</code> dictionary (and to <code>__all__</code>) with the fully qualified names, e.g.<br />\n'labscript_utils.unitconversions.submodule.SomeClass', usually disallowed<br />\nvariable names in Python. This ensures that if an old version of BLACS<br />\n(i.e. the current version) imports * and inspects its <code>globals()</code> dict looking<br />\nfor unit conversion classes, it will still find them, even if the shot file<br />\nthe conversion class name is coming from was compiled with a newer version of<br />\nlabscript that saves the full paths.</p>\n<p>This change paves the way for:</p>\n<ul>\n<li>\n<p>lascript to save fully qualified unit conversion class names, allowing<br />\n  unit conversion classes to be stored within userlib instead of labscript_utils.</p>\n</li>\n<li>\n<p>BLACS to improve performance by not importing all the classes en-masse.</p>\n</li>\n</ul>\n<p>whilst supporting full backward compatibility.</p>", "type": "rendered"}, "participants": [], "parents": [{"hash": "67147a11ef942f73ff43f41bdf494997a3a01c73", "type": "commit", "links": {"self": {"href": "data/repositories/cbillington/labscript_utils/commit/67147a11ef942f73ff43f41bdf494997a3a01c73.json"}, "html": {"href": "#!/cbillington/labscript_utils/commits/67147a11ef942f73ff43f41bdf494997a3a01c73"}}}], "date": "2018-10-04T03:14:02+00:00", "message": "Add a function `get_unit_conversion_class(fullname)` to unitconversions module.\nIf a fully qualified class name is provided, this will import just the class\nspecified (even if it is not located within the unitconversions folder).\n\nOtherwise, if just a class name is given without a full import path,\nit falls back to importing everything to find the class of the given\nname. This provides backward compatibility with shots compiled with versions\nof labscript that save the class name only (i.e. the current version).\n\nA custom `__all__` provides backward compatibility for versions of BLACS\n(i.e. the current version) that import * from unitconversions. Submodules\nare only imported en-masse if `__all__` is actually acessed, at which point\nall the classes are imported and loaded into the globals dictionary (and their\nnames added to `__all__`).\n\nThis custom `__all__` even takes the bizarre step of adding items to the\n`globals()` dictionary (and to `__all__`) with the fully qualified names, e.g.\n'labscript_utils.unitconversions.submodule.SomeClass', usually disallowed\nvariable names in Python. This ensures that if an old version of BLACS\n(i.e. the current version) imports * and inspects its `globals()` dict looking\nfor unit conversion classes, it will still find them, even if the shot file\nthe conversion class name is coming from was compiled with a newer version of\nlabscript that saves the full paths.\n\nThis change paves the way for:\n\n* lascript to save fully qualified unit conversion class names, allowing\n  unit conversion classes to be stored within userlib instead of labscript_utils.\n\n* BLACS to improve performance by not importing all the classes en-masse.\n\nwhilst supporting full backward compatibility.", "type": "commit", "git_hash": "e35a8bbd02aee7d3f811cf39f65c305cdae8e3bd", "tags": null, "branches": "defer_unit_conversion_imports"}