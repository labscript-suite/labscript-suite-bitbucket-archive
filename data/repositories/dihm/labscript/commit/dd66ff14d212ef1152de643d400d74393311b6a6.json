{"rendered": {"message": {"raw": "Fixed a bug which reared its head only under very specific circumstances. If a single element ramp (I know, why the hell would you do that?) was used, and immediately followed another ramp, then there was a strange interaction between the two.\n\nThe single element ramp would modify its function evaluation time to correct for zero order hold error. The problem was, it would modify an existing mutable data structure in doing so. The previous ramp would then see this modification, and if the two ramps had different sample rates, would get an incorrect time point for its own zero order hold correction. This resulted in a grossly incorrect final point for that first ramp, as its function was evaluated at some much later time.\n\nThe fix was to ensure that the correction for zero order hold error doesn't modify the shared time arrays in the case of a one-element ramp!\n\nThis was not a contrived example, this was actually discovered whilst in use. Sure a one-element ramp is unrealistic, but it was being used to essentially 'comment out' a ramp to be a single state change. It was more convenient to leave the ramp in and make it have only one point by modifying a runmanager global than to change the code.", "markup": "markdown", "html": "<p>Fixed a bug which reared its head only under very specific circumstances. If a single element ramp (I know, why the hell would you do that?) was used, and immediately followed another ramp, then there was a strange interaction between the two.</p>\n<p>The single element ramp would modify its function evaluation time to correct for zero order hold error. The problem was, it would modify an existing mutable data structure in doing so. The previous ramp would then see this modification, and if the two ramps had different sample rates, would get an incorrect time point for its own zero order hold correction. This resulted in a grossly incorrect final point for that first ramp, as its function was evaluated at some much later time.</p>\n<p>The fix was to ensure that the correction for zero order hold error doesn't modify the shared time arrays in the case of a one-element ramp!</p>\n<p>This was not a contrived example, this was actually discovered whilst in use. Sure a one-element ramp is unrealistic, but it was being used to essentially 'comment out' a ramp to be a single state change. It was more convenient to leave the ramp in and make it have only one point by modifying a runmanager global than to change the code.</p>", "type": "rendered"}}, "hash": "dd66ff14d212ef1152de643d400d74393311b6a6", "repository": {"links": {"self": {"href": "data/repositories/dihm/labscript.json"}, "html": {"href": "#!/dihm/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{91cd5be9-bc45-4cfa-bf3e-538c67029348}ts=python"}}, "type": "repository", "name": "labscript", "full_name": "dihm/labscript", "uuid": "{91cd5be9-bc45-4cfa-bf3e-538c67029348}"}, "links": {"self": {"href": "data/repositories/dihm/labscript/commit/dd66ff14d212ef1152de643d400d74393311b6a6.json"}, "comments": {"href": "data/repositories/dihm/labscript/commit/dd66ff14d212ef1152de643d400d74393311b6a6/comments_page=1.json"}, "patch": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/labscript/patch/dd66ff14d212ef1152de643d400d74393311b6a6"}, "html": {"href": "#!/dihm/labscript/commits/dd66ff14d212ef1152de643d400d74393311b6a6"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/labscript/diff/dd66ff14d212ef1152de643d400d74393311b6a6"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/labscript/commit/dd66ff14d212ef1152de643d400d74393311b6a6/approve"}, "statuses": {"href": "data/repositories/dihm/labscript/commit/dd66ff14d212ef1152de643d400d74393311b6a6/statuses_page=1.json"}}, "author": {"raw": "cbilling", "type": "author", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}}, "summary": {"raw": "Fixed a bug which reared its head only under very specific circumstances. If a single element ramp (I know, why the hell would you do that?) was used, and immediately followed another ramp, then there was a strange interaction between the two.\n\nThe single element ramp would modify its function evaluation time to correct for zero order hold error. The problem was, it would modify an existing mutable data structure in doing so. The previous ramp would then see this modification, and if the two ramps had different sample rates, would get an incorrect time point for its own zero order hold correction. This resulted in a grossly incorrect final point for that first ramp, as its function was evaluated at some much later time.\n\nThe fix was to ensure that the correction for zero order hold error doesn't modify the shared time arrays in the case of a one-element ramp!\n\nThis was not a contrived example, this was actually discovered whilst in use. Sure a one-element ramp is unrealistic, but it was being used to essentially 'comment out' a ramp to be a single state change. It was more convenient to leave the ramp in and make it have only one point by modifying a runmanager global than to change the code.", "markup": "markdown", "html": "<p>Fixed a bug which reared its head only under very specific circumstances. If a single element ramp (I know, why the hell would you do that?) was used, and immediately followed another ramp, then there was a strange interaction between the two.</p>\n<p>The single element ramp would modify its function evaluation time to correct for zero order hold error. The problem was, it would modify an existing mutable data structure in doing so. The previous ramp would then see this modification, and if the two ramps had different sample rates, would get an incorrect time point for its own zero order hold correction. This resulted in a grossly incorrect final point for that first ramp, as its function was evaluated at some much later time.</p>\n<p>The fix was to ensure that the correction for zero order hold error doesn't modify the shared time arrays in the case of a one-element ramp!</p>\n<p>This was not a contrived example, this was actually discovered whilst in use. Sure a one-element ramp is unrealistic, but it was being used to essentially 'comment out' a ramp to be a single state change. It was more convenient to leave the ramp in and make it have only one point by modifying a runmanager global than to change the code.</p>", "type": "rendered"}, "participants": [], "parents": [{"hash": "4a2d7fcf40fe8899a755b3933083275fbd3ca7f2", "type": "commit", "links": {"self": {"href": "data/repositories/dihm/labscript/commit/4a2d7fcf40fe8899a755b3933083275fbd3ca7f2.json"}, "html": {"href": "#!/dihm/labscript/commits/4a2d7fcf40fe8899a755b3933083275fbd3ca7f2"}}}], "date": "2012-12-21T04:54:47+00:00", "message": "Fixed a bug which reared its head only under very specific circumstances. If a single element ramp (I know, why the hell would you do that?) was used, and immediately followed another ramp, then there was a strange interaction between the two.\n\nThe single element ramp would modify its function evaluation time to correct for zero order hold error. The problem was, it would modify an existing mutable data structure in doing so. The previous ramp would then see this modification, and if the two ramps had different sample rates, would get an incorrect time point for its own zero order hold correction. This resulted in a grossly incorrect final point for that first ramp, as its function was evaluated at some much later time.\n\nThe fix was to ensure that the correction for zero order hold error doesn't modify the shared time arrays in the case of a one-element ramp!\n\nThis was not a contrived example, this was actually discovered whilst in use. Sure a one-element ramp is unrealistic, but it was being used to essentially 'comment out' a ramp to be a single state change. It was more convenient to leave the ramp in and make it have only one point by modifying a runmanager global than to change the code.", "type": "commit", "git_hash": "950f367f1ba32b6b25512e3ed01e4eeba6766bfe", "tags": null, "branches": "default"}