{"rendered": {"message": {"raw": "Rework tab shutdown and restart to aboid blocking the mainloop with terminate().\n\n* Rename DeviceTab.destroy() to Tab.shutdown_workers(), moving it to the Tab class.\n  This method now does what it says, it just shuts down workers and does not call\n  Tab.close_tab(). This is because, should the timeout be reached when shutting down BLACS,\n  the former DeviceTab.destroy() may or may not have called Tab.close_tab(). We\n  do not want code to be  calling close_tab() twice, so we simply don't do this\n  in this method anymore. To close a tab, cleanly, code can now call\n  Tab.shutdown_workers(), wait until Tab.shutdown_workers_complete is True, then call\n  Tab.close_tab. Or, to shutdown without telling the workers politely, code can\n  call only Tab.cose_tab(). A consequence of this is that because the Tab class\n  does not have a concept of 'primary' and 'secondary' workers, that the shutdown\n  methods of workers are called in an arbitrary order (in Python 2) or in the\n  order the workers were added (in Python 3), whereas previously it was the primary\n  worker's shutdown method being called first. I do not imagine this being of\n  consequence but worth mentioning.\n\n * Split non-blocking and blocking parts of Tab.close_tab() into separate functions.\n  If finalise=False is passed to Tab.close_tab(), then it will not call the blocking part,\n  and it is up to calling code to call Tab.finalise_close_tab().\n\n* Move joining of the mainloop into Tab.finalise_close_tab()\n\n* Rename Tab.wait_for_mainloop_to_stop() to Tab.continue_restart(), and have it\n  call Tab.finalise_close_tab(), which does all the blocking operations and no longer\n  only the joining of the mainloop.\n\n* When blocking on closing the tab, set the tab's icon to an hourglass, grey out\n  and put in brackets its tab label, and insert a QLabel in the tab widget saying\n  \"waiting for tab mainloop and worker(s) to exit\"\n\n* use new zprocess functionality Process.interrupt_startup() to interrupt the\n  worker startup in the nonblocking Tab.close_tab(), separately from terminating\n  the worker process, since the interruption is non-blocking and must be done\n  before one can break out of the mainloop, but terminate() can be blocking and\n  so must be in Tab.finalise_close_tab().\n\n* Re-work BLACS.finalise_quit to wait for clean worker shutdown (instead of destroy\n  as previous), give up if a tab has an error or the timeout is reached, and then\n  call close_tab on each tab. Then wait a further timeout period for\n  finalise_close_tab to complete for each tab, before giving up on that too and\n  quitting.\n\n* Make PluginTab.close_tab accept the 'finalise' keyword arguemnt, but ignore it\n  since it does no blocking work. However, it looks to me like\n  PluginTab.close_tab() is refundant, being identical to Tab.close_tab() except\n  that it doesn't have the stuff about workers (which will be skipped in any\n  case)\n\n* Rely on zprocess 2.14.0, with the necessary changes for interrupting blocking\n  operations.", "markup": "markdown", "html": "<p>Rework tab shutdown and restart to aboid blocking the mainloop with terminate().</p>\n<ul>\n<li>\n<p>Rename DeviceTab.destroy() to Tab.shutdown_workers(), moving it to the Tab class.<br />\n  This method now does what it says, it just shuts down workers and does not call<br />\n  Tab.close_tab(). This is because, should the timeout be reached when shutting down BLACS,<br />\n  the former DeviceTab.destroy() may or may not have called Tab.close_tab(). We<br />\n  do not want code to be  calling close_tab() twice, so we simply don't do this<br />\n  in this method anymore. To close a tab, cleanly, code can now call<br />\n  Tab.shutdown_workers(), wait until Tab.shutdown_workers_complete is True, then call<br />\n  Tab.close_tab. Or, to shutdown without telling the workers politely, code can<br />\n  call only Tab.cose_tab(). A consequence of this is that because the Tab class<br />\n  does not have a concept of 'primary' and 'secondary' workers, that the shutdown<br />\n  methods of workers are called in an arbitrary order (in Python 2) or in the<br />\n  order the workers were added (in Python 3), whereas previously it was the primary<br />\n  worker's shutdown method being called first. I do not imagine this being of<br />\n  consequence but worth mentioning.</p>\n</li>\n<li>\n<p>Split non-blocking and blocking parts of Tab.close_tab() into separate functions.<br />\n  If finalise=False is passed to Tab.close_tab(), then it will not call the blocking part,<br />\n  and it is up to calling code to call Tab.finalise_close_tab().</p>\n</li>\n<li>\n<p>Move joining of the mainloop into Tab.finalise_close_tab()</p>\n</li>\n<li>\n<p>Rename Tab.wait_for_mainloop_to_stop() to Tab.continue_restart(), and have it<br />\n  call Tab.finalise_close_tab(), which does all the blocking operations and no longer<br />\n  only the joining of the mainloop.</p>\n</li>\n<li>\n<p>When blocking on closing the tab, set the tab's icon to an hourglass, grey out<br />\n  and put in brackets its tab label, and insert a QLabel in the tab widget saying<br />\n  \"waiting for tab mainloop and worker(s) to exit\"</p>\n</li>\n<li>\n<p>use new zprocess functionality Process.interrupt_startup() to interrupt the<br />\n  worker startup in the nonblocking Tab.close_tab(), separately from terminating<br />\n  the worker process, since the interruption is non-blocking and must be done<br />\n  before one can break out of the mainloop, but terminate() can be blocking and<br />\n  so must be in Tab.finalise_close_tab().</p>\n</li>\n<li>\n<p>Re-work BLACS.finalise_quit to wait for clean worker shutdown (instead of destroy<br />\n  as previous), give up if a tab has an error or the timeout is reached, and then<br />\n  call close_tab on each tab. Then wait a further timeout period for<br />\n  finalise_close_tab to complete for each tab, before giving up on that too and<br />\n  quitting.</p>\n</li>\n<li>\n<p>Make PluginTab.close_tab accept the 'finalise' keyword arguemnt, but ignore it<br />\n  since it does no blocking work. However, it looks to me like<br />\n  PluginTab.close_tab() is refundant, being identical to Tab.close_tab() except<br />\n  that it doesn't have the stuff about workers (which will be skipped in any<br />\n  case)</p>\n</li>\n<li>\n<p>Rely on zprocess 2.14.0, with the necessary changes for interrupting blocking<br />\n  operations.</p>\n</li>\n</ul>", "type": "rendered"}}, "hash": "41bcea18bded6a4a6027a649e3a1ceb4b7da1380", "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs.json"}, "html": {"href": "#!/labscript_suite/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}ts=249915"}}, "type": "repository", "name": "BLACS", "full_name": "labscript_suite/blacs", "uuid": "{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}"}, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/commit/41bcea18bded6a4a6027a649e3a1ceb4b7da1380.json"}, "comments": {"href": "data/repositories/labscript_suite/blacs/commit/41bcea18bded6a4a6027a649e3a1ceb4b7da1380/comments_page=1.json"}, "patch": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/blacs/patch/41bcea18bded6a4a6027a649e3a1ceb4b7da1380"}, "html": {"href": "#!/labscript_suite/blacs/commits/41bcea18bded6a4a6027a649e3a1ceb4b7da1380"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/blacs/diff/41bcea18bded6a4a6027a649e3a1ceb4b7da1380"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/blacs/commit/41bcea18bded6a4a6027a649e3a1ceb4b7da1380/approve"}, "statuses": {"href": "data/repositories/labscript_suite/blacs/commit/41bcea18bded6a4a6027a649e3a1ceb4b7da1380/statuses_page=1.json"}}, "author": {"raw": "chrisjbillington", "type": "author", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}}, "summary": {"raw": "Rework tab shutdown and restart to aboid blocking the mainloop with terminate().\n\n* Rename DeviceTab.destroy() to Tab.shutdown_workers(), moving it to the Tab class.\n  This method now does what it says, it just shuts down workers and does not call\n  Tab.close_tab(). This is because, should the timeout be reached when shutting down BLACS,\n  the former DeviceTab.destroy() may or may not have called Tab.close_tab(). We\n  do not want code to be  calling close_tab() twice, so we simply don't do this\n  in this method anymore. To close a tab, cleanly, code can now call\n  Tab.shutdown_workers(), wait until Tab.shutdown_workers_complete is True, then call\n  Tab.close_tab. Or, to shutdown without telling the workers politely, code can\n  call only Tab.cose_tab(). A consequence of this is that because the Tab class\n  does not have a concept of 'primary' and 'secondary' workers, that the shutdown\n  methods of workers are called in an arbitrary order (in Python 2) or in the\n  order the workers were added (in Python 3), whereas previously it was the primary\n  worker's shutdown method being called first. I do not imagine this being of\n  consequence but worth mentioning.\n\n * Split non-blocking and blocking parts of Tab.close_tab() into separate functions.\n  If finalise=False is passed to Tab.close_tab(), then it will not call the blocking part,\n  and it is up to calling code to call Tab.finalise_close_tab().\n\n* Move joining of the mainloop into Tab.finalise_close_tab()\n\n* Rename Tab.wait_for_mainloop_to_stop() to Tab.continue_restart(), and have it\n  call Tab.finalise_close_tab(), which does all the blocking operations and no longer\n  only the joining of the mainloop.\n\n* When blocking on closing the tab, set the tab's icon to an hourglass, grey out\n  and put in brackets its tab label, and insert a QLabel in the tab widget saying\n  \"waiting for tab mainloop and worker(s) to exit\"\n\n* use new zprocess functionality Process.interrupt_startup() to interrupt the\n  worker startup in the nonblocking Tab.close_tab(), separately from terminating\n  the worker process, since the interruption is non-blocking and must be done\n  before one can break out of the mainloop, but terminate() can be blocking and\n  so must be in Tab.finalise_close_tab().\n\n* Re-work BLACS.finalise_quit to wait for clean worker shutdown (instead of destroy\n  as previous), give up if a tab has an error or the timeout is reached, and then\n  call close_tab on each tab. Then wait a further timeout period for\n  finalise_close_tab to complete for each tab, before giving up on that too and\n  quitting.\n\n* Make PluginTab.close_tab accept the 'finalise' keyword arguemnt, but ignore it\n  since it does no blocking work. However, it looks to me like\n  PluginTab.close_tab() is refundant, being identical to Tab.close_tab() except\n  that it doesn't have the stuff about workers (which will be skipped in any\n  case)\n\n* Rely on zprocess 2.14.0, with the necessary changes for interrupting blocking\n  operations.", "markup": "markdown", "html": "<p>Rework tab shutdown and restart to aboid blocking the mainloop with terminate().</p>\n<ul>\n<li>\n<p>Rename DeviceTab.destroy() to Tab.shutdown_workers(), moving it to the Tab class.<br />\n  This method now does what it says, it just shuts down workers and does not call<br />\n  Tab.close_tab(). This is because, should the timeout be reached when shutting down BLACS,<br />\n  the former DeviceTab.destroy() may or may not have called Tab.close_tab(). We<br />\n  do not want code to be  calling close_tab() twice, so we simply don't do this<br />\n  in this method anymore. To close a tab, cleanly, code can now call<br />\n  Tab.shutdown_workers(), wait until Tab.shutdown_workers_complete is True, then call<br />\n  Tab.close_tab. Or, to shutdown without telling the workers politely, code can<br />\n  call only Tab.cose_tab(). A consequence of this is that because the Tab class<br />\n  does not have a concept of 'primary' and 'secondary' workers, that the shutdown<br />\n  methods of workers are called in an arbitrary order (in Python 2) or in the<br />\n  order the workers were added (in Python 3), whereas previously it was the primary<br />\n  worker's shutdown method being called first. I do not imagine this being of<br />\n  consequence but worth mentioning.</p>\n</li>\n<li>\n<p>Split non-blocking and blocking parts of Tab.close_tab() into separate functions.<br />\n  If finalise=False is passed to Tab.close_tab(), then it will not call the blocking part,<br />\n  and it is up to calling code to call Tab.finalise_close_tab().</p>\n</li>\n<li>\n<p>Move joining of the mainloop into Tab.finalise_close_tab()</p>\n</li>\n<li>\n<p>Rename Tab.wait_for_mainloop_to_stop() to Tab.continue_restart(), and have it<br />\n  call Tab.finalise_close_tab(), which does all the blocking operations and no longer<br />\n  only the joining of the mainloop.</p>\n</li>\n<li>\n<p>When blocking on closing the tab, set the tab's icon to an hourglass, grey out<br />\n  and put in brackets its tab label, and insert a QLabel in the tab widget saying<br />\n  \"waiting for tab mainloop and worker(s) to exit\"</p>\n</li>\n<li>\n<p>use new zprocess functionality Process.interrupt_startup() to interrupt the<br />\n  worker startup in the nonblocking Tab.close_tab(), separately from terminating<br />\n  the worker process, since the interruption is non-blocking and must be done<br />\n  before one can break out of the mainloop, but terminate() can be blocking and<br />\n  so must be in Tab.finalise_close_tab().</p>\n</li>\n<li>\n<p>Re-work BLACS.finalise_quit to wait for clean worker shutdown (instead of destroy<br />\n  as previous), give up if a tab has an error or the timeout is reached, and then<br />\n  call close_tab on each tab. Then wait a further timeout period for<br />\n  finalise_close_tab to complete for each tab, before giving up on that too and<br />\n  quitting.</p>\n</li>\n<li>\n<p>Make PluginTab.close_tab accept the 'finalise' keyword arguemnt, but ignore it<br />\n  since it does no blocking work. However, it looks to me like<br />\n  PluginTab.close_tab() is refundant, being identical to Tab.close_tab() except<br />\n  that it doesn't have the stuff about workers (which will be skipped in any<br />\n  case)</p>\n</li>\n<li>\n<p>Rely on zprocess 2.14.0, with the necessary changes for interrupting blocking<br />\n  operations.</p>\n</li>\n</ul>", "type": "rendered"}, "participants": [], "parents": [{"hash": "02582a5dd0bc5ef6976d44ee2775b1873979aba7", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/blacs/commit/02582a5dd0bc5ef6976d44ee2775b1873979aba7.json"}, "html": {"href": "#!/labscript_suite/blacs/commits/02582a5dd0bc5ef6976d44ee2775b1873979aba7"}}}], "date": "2019-05-12T20:50:19+00:00", "message": "Rework tab shutdown and restart to aboid blocking the mainloop with terminate().\n\n* Rename DeviceTab.destroy() to Tab.shutdown_workers(), moving it to the Tab class.\n  This method now does what it says, it just shuts down workers and does not call\n  Tab.close_tab(). This is because, should the timeout be reached when shutting down BLACS,\n  the former DeviceTab.destroy() may or may not have called Tab.close_tab(). We\n  do not want code to be  calling close_tab() twice, so we simply don't do this\n  in this method anymore. To close a tab, cleanly, code can now call\n  Tab.shutdown_workers(), wait until Tab.shutdown_workers_complete is True, then call\n  Tab.close_tab. Or, to shutdown without telling the workers politely, code can\n  call only Tab.cose_tab(). A consequence of this is that because the Tab class\n  does not have a concept of 'primary' and 'secondary' workers, that the shutdown\n  methods of workers are called in an arbitrary order (in Python 2) or in the\n  order the workers were added (in Python 3), whereas previously it was the primary\n  worker's shutdown method being called first. I do not imagine this being of\n  consequence but worth mentioning.\n\n * Split non-blocking and blocking parts of Tab.close_tab() into separate functions.\n  If finalise=False is passed to Tab.close_tab(), then it will not call the blocking part,\n  and it is up to calling code to call Tab.finalise_close_tab().\n\n* Move joining of the mainloop into Tab.finalise_close_tab()\n\n* Rename Tab.wait_for_mainloop_to_stop() to Tab.continue_restart(), and have it\n  call Tab.finalise_close_tab(), which does all the blocking operations and no longer\n  only the joining of the mainloop.\n\n* When blocking on closing the tab, set the tab's icon to an hourglass, grey out\n  and put in brackets its tab label, and insert a QLabel in the tab widget saying\n  \"waiting for tab mainloop and worker(s) to exit\"\n\n* use new zprocess functionality Process.interrupt_startup() to interrupt the\n  worker startup in the nonblocking Tab.close_tab(), separately from terminating\n  the worker process, since the interruption is non-blocking and must be done\n  before one can break out of the mainloop, but terminate() can be blocking and\n  so must be in Tab.finalise_close_tab().\n\n* Re-work BLACS.finalise_quit to wait for clean worker shutdown (instead of destroy\n  as previous), give up if a tab has an error or the timeout is reached, and then\n  call close_tab on each tab. Then wait a further timeout period for\n  finalise_close_tab to complete for each tab, before giving up on that too and\n  quitting.\n\n* Make PluginTab.close_tab accept the 'finalise' keyword arguemnt, but ignore it\n  since it does no blocking work. However, it looks to me like\n  PluginTab.close_tab() is refundant, being identical to Tab.close_tab() except\n  that it doesn't have the stuff about workers (which will be skipped in any\n  case)\n\n* Rely on zprocess 2.14.0, with the necessary changes for interrupting blocking\n  operations.", "type": "commit", "git_hash": "2b2b854bbdb1fa22278fd94d303d3eff26c7487c", "tags": null, "branches": "remote-workers"}