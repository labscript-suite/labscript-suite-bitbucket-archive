{"pagelen": 100, "values": [{"links": {"self": {"href": "data/repositories/labscript_suite/blacs/issues/15/comments/37444351.json"}, "html": {"href": "#!/labscript_suite/blacs/issues/15#comment-37444351"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs/issues/15.json"}}, "type": "issue", "id": 15, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs.json"}, "html": {"href": "#!/labscript_suite/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}ts=249915"}}, "type": "repository", "name": "BLACS", "full_name": "labscript_suite/blacs", "uuid": "{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}"}, "title": "Improve shot cycle time in BLACS"}, "content": {"raw": null, "markup": "markdown", "html": "", "type": "rendered"}, "created_on": "2017-06-07T23:18:10.559758+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}, "updated_on": null, "type": "issue_comment", "id": 37444351}, {"links": {"self": {"href": "data/repositories/labscript_suite/blacs/issues/15/comments/37444355.json"}, "html": {"href": "#!/labscript_suite/blacs/issues/15#comment-37444355"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs/issues/15.json"}}, "type": "issue", "id": 15, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs.json"}, "html": {"href": "#!/labscript_suite/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}ts=249915"}}, "type": "repository", "name": "BLACS", "full_name": "labscript_suite/blacs", "uuid": "{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}"}, "title": "Improve shot cycle time in BLACS"}, "content": {"raw": null, "markup": "markdown", "html": "", "type": "rendered"}, "created_on": "2017-06-07T23:18:49.347790+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}, "updated_on": null, "type": "issue_comment", "id": 37444355}, {"links": {"self": {"href": "data/repositories/labscript_suite/blacs/issues/15/comments/37464131.json"}, "html": {"href": "#!/labscript_suite/blacs/issues/15#comment-37464131"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs/issues/15.json"}}, "type": "issue", "id": 15, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs.json"}, "html": {"href": "#!/labscript_suite/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}ts=249915"}}, "type": "repository", "name": "BLACS", "full_name": "labscript_suite/blacs", "uuid": "{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}"}, "title": "Improve shot cycle time in BLACS"}, "content": {"raw": "I'm a little skeptical that there is much contention for the main thread or latency accessing it (I'm testing with just one DummyPseudoclock device, but I wrapped that check in a `for i in range(50):` and noticed no difference), but profiling will answer the question. At some point I'll profile the experiment loop for an actual experiment and we can see where most time is wasted and whether it's worth pursuing more optimisation.\n\nAh actually the PulseBlaster for example doing its frequent status checks (every ~100ms it looks like) during a run may be creating contention for the main thread - but if so the fix might be to have the PulseBlaster do 1 second worth of checks per call to the WorkerProcess rather than one check every 100 ms. For example the PineBlaster does this - its worker process does a blocking `readline()` from the serial connection waiting for a 'done' signal, and this times out in 1 second at which point the worker function returns. So each call to the worker process takes 1 second and so there's not much going on in the GUI process due to this. Could be a better model for the PulseBlaster.\n\nBut, Qt is surprisingly fast, and our use of threads is mostly cooperative rather than preemptive. So I'd see what profiling says before bothering to act.", "markup": "markdown", "html": "<p>I'm a little skeptical that there is much contention for the main thread or latency accessing it (I'm testing with just one DummyPseudoclock device, but I wrapped that check in a <code>for i in range(50):</code> and noticed no difference), but profiling will answer the question. At some point I'll profile the experiment loop for an actual experiment and we can see where most time is wasted and whether it's worth pursuing more optimisation.</p>\n<p>Ah actually the PulseBlaster for example doing its frequent status checks (every ~100ms it looks like) during a run may be creating contention for the main thread - but if so the fix might be to have the PulseBlaster do 1 second worth of checks per call to the WorkerProcess rather than one check every 100 ms. For example the PineBlaster does this - its worker process does a blocking <code>readline()</code> from the serial connection waiting for a 'done' signal, and this times out in 1 second at which point the worker function returns. So each call to the worker process takes 1 second and so there's not much going on in the GUI process due to this. Could be a better model for the PulseBlaster.</p>\n<p>But, Qt is surprisingly fast, and our use of threads is mostly cooperative rather than preemptive. So I'd see what profiling says before bothering to act.</p>", "type": "rendered"}, "created_on": "2017-06-08T15:26:54.293311+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-06-08T15:39:59.542449+00:00", "type": "issue_comment", "id": 37464131}], "page": 1, "size": 3}