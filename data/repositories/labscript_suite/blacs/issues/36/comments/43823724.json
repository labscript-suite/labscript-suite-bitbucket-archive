{"links": {"self": {"href": "data/repositories/labscript_suite/blacs/issues/36/comments/43823724.json"}, "html": {"href": "#!/labscript_suite/blacs/issues/36#comment-43823724"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs/issues/36.json"}}, "type": "issue", "id": 36, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs.json"}, "html": {"href": "#!/labscript_suite/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}ts=249915"}}, "type": "repository", "name": "BLACS", "full_name": "labscript_suite/blacs", "uuid": "{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}"}, "title": "front panel settings not loaded correctly if blacs is not run as a module"}, "content": {"raw": "Aha!\n\n\nWe have fallen victim to the Python \"[double import problem](http://python-notes.curiousefficiency.org/en/latest/python_concepts/import_traps.html)\" which can rear its head if a module is imported *both* by absolute imports and by 'relative' imports (technically they are not relative imports, but you know what I mean). This results in *two* copies of the module in memory.\n\nSo you end up with two classes - a `blacs.connections.ConnectionTable` and a `connections.ConnectionTable`, and as far as Python is concerned, instances of one are not instances of the other.\n\nAs you said, the solution is to not make any 'relative' imports. However, as I said technically these are not relative imports - even in Python 3 they would be allowed. It' merely the case that since we're running from the package directory, those modules are available as the current directory is in `sys.path`. And Python has no way to know they are part of BLACS - it just things they're regular modules, distinct from submodules of BLACS.\n\nSo even if we did `from __future__ import absolute_import`, that still wouldn't raise an error which would force us to find all remaining instances of these dodgy imports.\n\nReally you're not supposed to run code from within package directories, and you're supposed to use `python -m` in our type of situation. But, since our launchers simply run BLACS from within its directory, this is so far our official way of doing things. And it's a pain to not be allowed to run code from within a package directory - one tends to do it all the time during testing.\n\nSo removing *all* the sortof-relative-but-not-technically imports will solve our problem, but is fragile - a single relative import in the future, even on Python 3, would break things again. Maybe we should change what our launchers do.", "markup": "markdown", "html": "<p>Aha!</p>\n<p>We have fallen victim to the Python \"<a data-is-external-link=\"true\" href=\"http://python-notes.curiousefficiency.org/en/latest/python_concepts/import_traps.html\" rel=\"nofollow\">double import problem</a>\" which can rear its head if a module is imported <em>both</em> by absolute imports and by 'relative' imports (technically they are not relative imports, but you know what I mean). This results in <em>two</em> copies of the module in memory.</p>\n<p>So you end up with two classes - a <code>blacs.connections.ConnectionTable</code> and a <code>connections.ConnectionTable</code>, and as far as Python is concerned, instances of one are not instances of the other.</p>\n<p>As you said, the solution is to not make any 'relative' imports. However, as I said technically these are not relative imports - even in Python 3 they would be allowed. It' merely the case that since we're running from the package directory, those modules are available as the current directory is in <code>sys.path</code>. And Python has no way to know they are part of BLACS - it just things they're regular modules, distinct from submodules of BLACS.</p>\n<p>So even if we did <code>from __future__ import absolute_import</code>, that still wouldn't raise an error which would force us to find all remaining instances of these dodgy imports.</p>\n<p>Really you're not supposed to run code from within package directories, and you're supposed to use <code>python -m</code> in our type of situation. But, since our launchers simply run BLACS from within its directory, this is so far our official way of doing things. And it's a pain to not be allowed to run code from within a package directory - one tends to do it all the time during testing.</p>\n<p>So removing <em>all</em> the sortof-relative-but-not-technically imports will solve our problem, but is fragile - a single relative import in the future, even on Python 3, would break things again. Maybe we should change what our launchers do.</p>", "type": "rendered"}, "created_on": "2018-03-09T22:35:01.095627+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-03-09T22:37:44.322526+00:00", "type": "issue_comment", "id": 43823724}