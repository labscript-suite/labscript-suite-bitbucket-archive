{"priority": "minor", "kind": "enhancement", "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs.json"}, "html": {"href": "#!/labscript_suite/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}ts=249915"}}, "type": "repository", "name": "BLACS", "full_name": "labscript_suite/blacs", "uuid": "{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}"}, "links": {"attachments": {"href": "data/repositories/labscript_suite/blacs/issues/53/attachments_page=1.json"}, "self": {"href": "data/repositories/labscript_suite/blacs/issues/53.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/blacs/issues/53/watch"}, "comments": {"href": "data/repositories/labscript_suite/blacs/issues/53/comments_page=1.json"}, "html": {"href": "#!/labscript_suite/blacs/issues/53/ways-of-speeding-up-cycle-time-pipelining"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/blacs/issues/53/vote"}}, "reporter": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "title": "Ways of speeding up cycle time. Pipelining, readahead, removing redundant steps.", "component": null, "votes": 0, "watches": 1, "content": {"raw": "There are a few ways we might speed up the overall rate at which shots are run. Some are pretty invasive so it's not a minor change, but the basic idea is to split up `transition_to_buffered()` and `transition_to_manual()` into multiple steps, and a) only call the ones that are necessary, and b) call the ones that are not dependent on previous steps simultaneously.\r\n\r\nSo for example, `transition_to_manual()` could be split into:\r\n\r\n* Read data from hardware (this can be done before the shot is even complete)\r\n* Save data to shot file (this can be done after the shot is complete, even whilst the next shot is running)\r\n* Get hardware into an appropriate state for either a) another buffered run or b) actual  transition to manual. (`program_manual` could be skipped unless the queue is paused)\r\n\r\n`transition_to_buffered()` could be split into:\r\n\r\n* Read instructions from the shot file (this can be done before the previous shot is complete, and can be completely skipped if it is known that the shot is an exact repeat of the previous one)\r\n* Program the hardware\r\n\r\nRunning as many of these steps as possible simultaneously, and skipping unnecessary ones could go some way to speeding up the cycle time of BLACS. In the ideal case, devices that are retriggerable with the same date will not need any reconfiguration in between shots, and will contribute no overhead.\r\n\r\nProfiling will reveal what the actual overhead is. If after fixing the above sources of overhead (if they are what's dominating), it turns out that opening and closing HDF5 files is the slow thing, then we can have some kind of intelligent \"readahead\" in one hit in a single process as soon as the shot arrives in BLACS - knowing based on previous shots what groups and datasets a particular driver opened, the data can be read all ahead of time and the worker process will see a proxy HDF5 file object which requires no zlock to open, and which already has all data available, only opening the actual shot file if the driver attempts to read a group that was not read in advance. This would consume more RAM, so should be disableable of course.\r\n\r\nThese are the sorts of optimisation we could do, but before any of it I would want to do profiling, marking particular functions and when they were called, and getting some statistics to see where the bottlenecks are.", "markup": "markdown", "html": "<p>There are a few ways we might speed up the overall rate at which shots are run. Some are pretty invasive so it's not a minor change, but the basic idea is to split up <code>transition_to_buffered()</code> and <code>transition_to_manual()</code> into multiple steps, and a) only call the ones that are necessary, and b) call the ones that are not dependent on previous steps simultaneously.</p>\n<p>So for example, <code>transition_to_manual()</code> could be split into:</p>\n<ul>\n<li>Read data from hardware (this can be done before the shot is even complete)</li>\n<li>Save data to shot file (this can be done after the shot is complete, even whilst the next shot is running)</li>\n<li>Get hardware into an appropriate state for either a) another buffered run or b) actual  transition to manual. (<code>program_manual</code> could be skipped unless the queue is paused)</li>\n</ul>\n<p><code>transition_to_buffered()</code> could be split into:</p>\n<ul>\n<li>Read instructions from the shot file (this can be done before the previous shot is complete, and can be completely skipped if it is known that the shot is an exact repeat of the previous one)</li>\n<li>Program the hardware</li>\n</ul>\n<p>Running as many of these steps as possible simultaneously, and skipping unnecessary ones could go some way to speeding up the cycle time of BLACS. In the ideal case, devices that are retriggerable with the same date will not need any reconfiguration in between shots, and will contribute no overhead.</p>\n<p>Profiling will reveal what the actual overhead is. If after fixing the above sources of overhead (if they are what's dominating), it turns out that opening and closing HDF5 files is the slow thing, then we can have some kind of intelligent \"readahead\" in one hit in a single process as soon as the shot arrives in BLACS - knowing based on previous shots what groups and datasets a particular driver opened, the data can be read all ahead of time and the worker process will see a proxy HDF5 file object which requires no zlock to open, and which already has all data available, only opening the actual shot file if the driver attempts to read a group that was not read in advance. This would consume more RAM, so should be disableable of course.</p>\n<p>These are the sorts of optimisation we could do, but before any of it I would want to do profiling, marking particular functions and when they were called, and getting some statistics to see where the bottlenecks are.</p>", "type": "rendered"}, "assignee": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "state": "new", "version": null, "edited_on": null, "created_on": "2019-12-08T19:18:39.292230+00:00", "milestone": null, "updated_on": "2019-12-09T17:28:21.100407+00:00", "type": "issue", "id": 53}