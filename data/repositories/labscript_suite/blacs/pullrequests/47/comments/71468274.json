{"links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/47/comments/71468274.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/47/_/diff#comment-71468274"}}, "parent": {"id": 71445109, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/47/comments/71445109.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/47/_/diff#comment-71445109"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 47, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/47.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/47"}}, "title": "Deserialise transition_to_manual"}, "content": {"raw": "Ok, ignore my first point then for now.\n\nI agree we can remove the second call to `transition_to_manual` but we need to leave in the disconnection of the signal in order to avoid a memory leak \\(I think signal connection prevents garbage collection, which would cause memory to leak on tab restart after an abort\\). Looks like it\u2019s fine to call disconnect on something that\u2019s already been disconnected though \\(I think that\u2019s how the code worked previously?\\).\n\nWe could wait until all devices are back in either `MODE_MANUAL` or an error state before cleaning the file, but that would require the user to restart any device tabs that have locked up or crashed, and to restart any device tabs that depend on the locked up tab via a ZMQ event. I\u2019m not sure what other choice we have though, other than some more complicated system where the queue has the ability \\(either automatically or via the abort button\\) to either restart tabs that are not responding after a timeout or kill worker processes. The latter is perhaps preferable so that the user sees an error message, but is a much bigger change as we currently don\u2019t do this ever. We\u2019d need to check how killing the worker process played with the BLACS state machine, and whether the the GUI method continues if the worker process dies \\(as it\u2019s possible someone could have overridden the GUI method so it was writing to the HDF5 file too\\).\n\nIs there a risk that we might corrupt HDF5 files if they\u2019re being written to when we kill a worker process? Also, does restarting a device tab guarantee that the worker process is killed?\n\n\u200c\n\n**An alternative suggestion**  \nWe could always give cleaned HDF5 files a new name \\(`_clean0001.h5` etc.\\) so that there is no risk of zombie processes writing to the clean file. \n\nNot sure if I like this though\u2026", "markup": "markdown", "html": "<p>Ok, ignore my first point then for now.</p>\n<p>I agree we can remove the second call to <code>transition_to_manual</code> but we need to leave in the disconnection of the signal in order to avoid a memory leak (I think signal connection prevents garbage collection, which would cause memory to leak on tab restart after an abort). Looks like it\u2019s fine to call disconnect on something that\u2019s already been disconnected though (I think that\u2019s how the code worked previously?).</p>\n<p>We could wait until all devices are back in either <code>MODE_MANUAL</code> or an error state before cleaning the file, but that would require the user to restart any device tabs that have locked up or crashed, and to restart any device tabs that depend on the locked up tab via a ZMQ event. I\u2019m not sure what other choice we have though, other than some more complicated system where the queue has the ability (either automatically or via the abort button) to either restart tabs that are not responding after a timeout or kill worker processes. The latter is perhaps preferable so that the user sees an error message, but is a much bigger change as we currently don\u2019t do this ever. We\u2019d need to check how killing the worker process played with the BLACS state machine, and whether the the GUI method continues if the worker process dies (as it\u2019s possible someone could have overridden the GUI method so it was writing to the HDF5 file too).</p>\n<p>Is there a risk that we might corrupt HDF5 files if they\u2019re being written to when we kill a worker process? Also, does restarting a device tab guarantee that the worker process is killed?</p>\n<p>\u200c</p>\n<p><strong>An alternative suggestion</strong><br />\nWe could always give cleaned HDF5 files a new name (<code>_clean0001.h5</code> etc.) so that there is no risk of zombie processes writing to the clean file. </p>\n<p>Not sure if I like this though\u2026</p>", "type": "rendered"}, "created_on": "2018-07-31T00:11:23.854162+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}, "updated_on": "2018-07-31T00:11:23.860742+00:00", "type": "pullrequest_comment", "id": 71468274}