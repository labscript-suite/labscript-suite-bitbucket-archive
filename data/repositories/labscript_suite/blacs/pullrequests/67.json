{"rendered": {"description": {"raw": "* Add support for remote workers.\r\n    Raise NotImplementedError on request for remote GUI, or multi-hop remote\r\n    workers, neither of which are supported quite yet.\r\n    Require labscript_utils 2.12.4, which has fixes for remote workers\r\n    and which in turn relies on a zprocess version with other required fixes.\r\n\r\n* Convert h5 filepaths to network agnostic before sending them to worker\r\n    processes for transition_to_buffered.\r\n\r\n    Only do this if the device is actually a remote device. This way, it is backward\r\n    compatible with device not expecting remote paths. Workers that are updated to\r\n    support being remote workers will need to check `self.is_remote` before calling\r\n    `path_to_local`, since if running locally the path with continue to be a local one.\r\n\r\n    Bump patch version so that labscript devices can depend on this new behaviour.\r\n\r\nThis PR requires labscript_utils [pull request 77](#!/labscript_suite/labscript_utils/pull-requests/77/), and so should be merged after it, with the version check updated to reflect whatever version number that PR ends up being tagged as.\r\n\r\nIt is not currently obvious how to setup and run remote workers. I will need to document how to start the remote process server, including configuring a security key.\r\n\r\nFor now, if anyone wants to test, this is my test script:\r\n```python\r\nfrom labscript import *\r\nfrom labscript_devices.PulseBlaster import PulseBlaster\r\nfrom labscript_devices.IMAQdxCamera.labscript_devices import IMAQdxCamera\r\n\r\nPulseBlaster('pulseblaster')\r\nTrigger('camera_trigger', pulseblaster.direct_outputs, 'flag 0')\r\nRemoteBLACS('test_remote', 'localhost')\r\nIMAQdxCamera(\r\n    'camera', camera_trigger, 'trigger', serial_number=0xDEADBEEF, worker=test_remote\r\n)\r\nIMAQdxCamera('camera2', camera_trigger, 'trigger', serial_number=0xDEADBEEF)\r\nstart()\r\n\r\ncamera.expose(1, 'test', trigger_duration=0.2)\r\ncamera2.expose(1, 'test', trigger_duration=0.2)\r\n\r\nstop(2)\r\n```\r\n\r\nAnd to start a zprocess remote server, you will need to run `python -m labscript_utils.remote` on the remote computer.\r\n\r\nYou will want to configure security - I think the remote server refuses to run presently unless you have either set\r\n```\r\n[security]\r\nshared_secret=<path to shared secret file>\r\n```\r\nor\r\n```\r\n[security]\r\nallow_insecure = True\r\n```\r\n\r\nin your labconfig.\r\n\r\nA new shared secret file can be generated with `python -m zprocess.makesecret`. Obviously all labconfigs on the computers that need to communicate with each other will need to have the same shared secret file.\r\n\r\nOne complication of enabling encryption is that it is enabled for all zmq communication in the labscript suite. This includes zlock. To start zlock with labscript-suite security settings, it needs to be started as `python -m labscript_utils.zlock` instead of `python -m zprocess.locking` or `python -m zprocess.zlock` (the former is an alias for the latter nowadays). However, if you look at `labscript_utils.zlock` you can see that all it is doing is reading labconfig and calling `python -m zprocess.zlock <command line args>`, so if running zlock on a separate computer without the labscript suite, it is easy enough to pass in the required shared secret on the command line.  `python -m zprocess.zlock -h` will list command line options for running a zlock server.\r\n\r\nSo you will need to restart zlock servers with encryption enabled, furthermore, you will need to kill zlog servers that may still be running after turning encryption on, as they will need to be started again with encryption.\r\n\r\nThe reason zlock is a complication is that non-python programs may need to talk to zlock still (such as BIAS), and it will be a pain in the neck for them to require encryption to do so. And unlike the arbitrary code execution allowed by the remote process server, the threat model of \"someone can temporarily ask politely for other programs not to open a HDF5 file if they know its exact name\" doesn't exactly have me shaking in my boots.\r\n\r\nSo I'm undecided about how to resolve this. Two options are:\r\n\r\n1. Add a setting to labconfig to leave zlock, specifically, unencrypted\r\n2. Make a proxy script that can run locally that forwards an unencrypted zmq REQ socket to a remote encrypted zmq REP socket. This could be used to allow programs like BIAS to talk to an encrypted zlock server.\r\n\r\nThis is exluding the third option where people with programs like BIAS just run with `allow_insecure = True` all the time - that strikes me as not a good plan.\r\n\r\nBoth of these options are easy to implement. The latter would likely mean adding another port number in labconfig for the local zlock proxy, and then the proxy would be started with something like `python -m labscript_utils.zlockproxy`. BIAS would then need to be modified to talk to localhost and that port number instead of a remote zlock server.\r\n\r\nThere is no particular reason for *logging* to be encrypted either given what it is, but I find it unappealing to have *some* connections encrypted and some not - this strikes me as more bug-prone than having *everything* encrypted. This is the main point against having zlock be an exception.\r\n\r\nInterested in people's thoughts, including @lincolndturner if you have any opinion here.\r\n\r\nA final option is that it might be possible to configure zlock to accept both encrypted and unencrypted traffic. This would be fairly ideal (so long as it optional so that people thinking they're using secure communication aren't misled), but zmq authentication is hard so it will be some effort to figure out if this is possible and implement it.", "markup": "markdown", "html": "<ul>\n<li>\n<p>Add support for remote workers.\n    Raise NotImplementedError on request for remote GUI, or multi-hop remote\n    workers, neither of which are supported quite yet.\n    Require labscript_utils 2.12.4, which has fixes for remote workers\n    and which in turn relies on a zprocess version with other required fixes.</p>\n</li>\n<li>\n<p>Convert h5 filepaths to network agnostic before sending them to worker\n    processes for transition_to_buffered.</p>\n<p>Only do this if the device is actually a remote device. This way, it is backward\ncompatible with device not expecting remote paths. Workers that are updated to\nsupport being remote workers will need to check <code>self.is_remote</code> before calling\n<code>path_to_local</code>, since if running locally the path with continue to be a local one.</p>\n<p>Bump patch version so that labscript devices can depend on this new behaviour.</p>\n</li>\n</ul>\n<p>This PR requires labscript_utils <a data-is-external-link=\"true\" href=\"#!/labscript_suite/labscript_utils/pull-requests/77/\" rel=\"nofollow\">pull request 77</a>, and so should be merged after it, with the version check updated to reflect whatever version number that PR ends up being tagged as.</p>\n<p>It is not currently obvious how to setup and run remote workers. I will need to document how to start the remote process server, including configuring a security key.</p>\n<p>For now, if anyone wants to test, this is my test script:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">labscript</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n<span class=\"kn\">from</span> <span class=\"nn\">labscript_devices.PulseBlaster</span> <span class=\"kn\">import</span> <span class=\"n\">PulseBlaster</span>\n<span class=\"kn\">from</span> <span class=\"nn\">labscript_devices.IMAQdxCamera.labscript_devices</span> <span class=\"kn\">import</span> <span class=\"n\">IMAQdxCamera</span>\n\n<span class=\"n\">PulseBlaster</span><span class=\"p\">(</span><span class=\"s1\">&#39;pulseblaster&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">Trigger</span><span class=\"p\">(</span><span class=\"s1\">&#39;camera_trigger&#39;</span><span class=\"p\">,</span> <span class=\"n\">pulseblaster</span><span class=\"o\">.</span><span class=\"n\">direct_outputs</span><span class=\"p\">,</span> <span class=\"s1\">&#39;flag 0&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">RemoteBLACS</span><span class=\"p\">(</span><span class=\"s1\">&#39;test_remote&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;localhost&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">IMAQdxCamera</span><span class=\"p\">(</span>\n    <span class=\"s1\">&#39;camera&#39;</span><span class=\"p\">,</span> <span class=\"n\">camera_trigger</span><span class=\"p\">,</span> <span class=\"s1\">&#39;trigger&#39;</span><span class=\"p\">,</span> <span class=\"n\">serial_number</span><span class=\"o\">=</span><span class=\"mh\">0xDEADBEEF</span><span class=\"p\">,</span> <span class=\"n\">worker</span><span class=\"o\">=</span><span class=\"n\">test_remote</span>\n<span class=\"p\">)</span>\n<span class=\"n\">IMAQdxCamera</span><span class=\"p\">(</span><span class=\"s1\">&#39;camera2&#39;</span><span class=\"p\">,</span> <span class=\"n\">camera_trigger</span><span class=\"p\">,</span> <span class=\"s1\">&#39;trigger&#39;</span><span class=\"p\">,</span> <span class=\"n\">serial_number</span><span class=\"o\">=</span><span class=\"mh\">0xDEADBEEF</span><span class=\"p\">)</span>\n<span class=\"n\">start</span><span class=\"p\">()</span>\n\n<span class=\"n\">camera</span><span class=\"o\">.</span><span class=\"n\">expose</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">&#39;test&#39;</span><span class=\"p\">,</span> <span class=\"n\">trigger_duration</span><span class=\"o\">=</span><span class=\"mf\">0.2</span><span class=\"p\">)</span>\n<span class=\"n\">camera2</span><span class=\"o\">.</span><span class=\"n\">expose</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">&#39;test&#39;</span><span class=\"p\">,</span> <span class=\"n\">trigger_duration</span><span class=\"o\">=</span><span class=\"mf\">0.2</span><span class=\"p\">)</span>\n\n<span class=\"n\">stop</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>And to start a zprocess remote server, you will need to run <code>python -m labscript_utils.remote</code> on the remote computer.</p>\n<p>You will want to configure security - I think the remote server refuses to run presently unless you have either set</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">[security]</span>\n<span class=\"na\">shared_secret</span><span class=\"o\">=</span><span class=\"s\">&lt;path to shared secret file&gt;</span>\n</pre></div>\n\n\n<p>or</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">[security]</span>\n<span class=\"na\">allow_insecure</span> <span class=\"o\">=</span> <span class=\"s\">True</span>\n</pre></div>\n\n\n<p>in your labconfig.</p>\n<p>A new shared secret file can be generated with <code>python -m zprocess.makesecret</code>. Obviously all labconfigs on the computers that need to communicate with each other will need to have the same shared secret file.</p>\n<p>One complication of enabling encryption is that it is enabled for all zmq communication in the labscript suite. This includes zlock. To start zlock with labscript-suite security settings, it needs to be started as <code>python -m labscript_utils.zlock</code> instead of <code>python -m zprocess.locking</code> or <code>python -m zprocess.zlock</code> (the former is an alias for the latter nowadays). However, if you look at <code>labscript_utils.zlock</code> you can see that all it is doing is reading labconfig and calling <code>python -m zprocess.zlock &lt;command line args&gt;</code>, so if running zlock on a separate computer without the labscript suite, it is easy enough to pass in the required shared secret on the command line.  <code>python -m zprocess.zlock -h</code> will list command line options for running a zlock server.</p>\n<p>So you will need to restart zlock servers with encryption enabled, furthermore, you will need to kill zlog servers that may still be running after turning encryption on, as they will need to be started again with encryption.</p>\n<p>The reason zlock is a complication is that non-python programs may need to talk to zlock still (such as BIAS), and it will be a pain in the neck for them to require encryption to do so. And unlike the arbitrary code execution allowed by the remote process server, the threat model of \"someone can temporarily ask politely for other programs not to open a HDF5 file if they know its exact name\" doesn't exactly have me shaking in my boots.</p>\n<p>So I'm undecided about how to resolve this. Two options are:</p>\n<ol>\n<li>Add a setting to labconfig to leave zlock, specifically, unencrypted</li>\n<li>Make a proxy script that can run locally that forwards an unencrypted zmq REQ socket to a remote encrypted zmq REP socket. This could be used to allow programs like BIAS to talk to an encrypted zlock server.</li>\n</ol>\n<p>This is exluding the third option where people with programs like BIAS just run with <code>allow_insecure = True</code> all the time - that strikes me as not a good plan.</p>\n<p>Both of these options are easy to implement. The latter would likely mean adding another port number in labconfig for the local zlock proxy, and then the proxy would be started with something like <code>python -m labscript_utils.zlockproxy</code>. BIAS would then need to be modified to talk to localhost and that port number instead of a remote zlock server.</p>\n<p>There is no particular reason for <em>logging</em> to be encrypted either given what it is, but I find it unappealing to have <em>some</em> connections encrypted and some not - this strikes me as more bug-prone than having <em>everything</em> encrypted. This is the main point against having zlock be an exception.</p>\n<p>Interested in people's thoughts, including @lincolndturner if you have any opinion here.</p>\n<p>A final option is that it might be possible to configure zlock to accept both encrypted and unencrypted traffic. This would be fairly ideal (so long as it optional so that people thinking they're using secure communication aren't misled), but zmq authentication is hard so it will be some effort to figure out if this is possible and implement it.</p>", "type": "rendered"}, "title": {"raw": "Implement remote workers in BLACS", "markup": "markdown", "html": "<p>Implement remote workers in BLACS</p>", "type": "rendered"}}, "type": "pullrequest", "description": "* Add support for remote workers.\r\n    Raise NotImplementedError on request for remote GUI, or multi-hop remote\r\n    workers, neither of which are supported quite yet.\r\n    Require labscript_utils 2.12.4, which has fixes for remote workers\r\n    and which in turn relies on a zprocess version with other required fixes.\r\n\r\n* Convert h5 filepaths to network agnostic before sending them to worker\r\n    processes for transition_to_buffered.\r\n\r\n    Only do this if the device is actually a remote device. This way, it is backward\r\n    compatible with device not expecting remote paths. Workers that are updated to\r\n    support being remote workers will need to check `self.is_remote` before calling\r\n    `path_to_local`, since if running locally the path with continue to be a local one.\r\n\r\n    Bump patch version so that labscript devices can depend on this new behaviour.\r\n\r\nThis PR requires labscript_utils [pull request 77](#!/labscript_suite/labscript_utils/pull-requests/77/), and so should be merged after it, with the version check updated to reflect whatever version number that PR ends up being tagged as.\r\n\r\nIt is not currently obvious how to setup and run remote workers. I will need to document how to start the remote process server, including configuring a security key.\r\n\r\nFor now, if anyone wants to test, this is my test script:\r\n```python\r\nfrom labscript import *\r\nfrom labscript_devices.PulseBlaster import PulseBlaster\r\nfrom labscript_devices.IMAQdxCamera.labscript_devices import IMAQdxCamera\r\n\r\nPulseBlaster('pulseblaster')\r\nTrigger('camera_trigger', pulseblaster.direct_outputs, 'flag 0')\r\nRemoteBLACS('test_remote', 'localhost')\r\nIMAQdxCamera(\r\n    'camera', camera_trigger, 'trigger', serial_number=0xDEADBEEF, worker=test_remote\r\n)\r\nIMAQdxCamera('camera2', camera_trigger, 'trigger', serial_number=0xDEADBEEF)\r\nstart()\r\n\r\ncamera.expose(1, 'test', trigger_duration=0.2)\r\ncamera2.expose(1, 'test', trigger_duration=0.2)\r\n\r\nstop(2)\r\n```\r\n\r\nAnd to start a zprocess remote server, you will need to run `python -m labscript_utils.remote` on the remote computer.\r\n\r\nYou will want to configure security - I think the remote server refuses to run presently unless you have either set\r\n```\r\n[security]\r\nshared_secret=<path to shared secret file>\r\n```\r\nor\r\n```\r\n[security]\r\nallow_insecure = True\r\n```\r\n\r\nin your labconfig.\r\n\r\nA new shared secret file can be generated with `python -m zprocess.makesecret`. Obviously all labconfigs on the computers that need to communicate with each other will need to have the same shared secret file.\r\n\r\nOne complication of enabling encryption is that it is enabled for all zmq communication in the labscript suite. This includes zlock. To start zlock with labscript-suite security settings, it needs to be started as `python -m labscript_utils.zlock` instead of `python -m zprocess.locking` or `python -m zprocess.zlock` (the former is an alias for the latter nowadays). However, if you look at `labscript_utils.zlock` you can see that all it is doing is reading labconfig and calling `python -m zprocess.zlock <command line args>`, so if running zlock on a separate computer without the labscript suite, it is easy enough to pass in the required shared secret on the command line.  `python -m zprocess.zlock -h` will list command line options for running a zlock server.\r\n\r\nSo you will need to restart zlock servers with encryption enabled, furthermore, you will need to kill zlog servers that may still be running after turning encryption on, as they will need to be started again with encryption.\r\n\r\nThe reason zlock is a complication is that non-python programs may need to talk to zlock still (such as BIAS), and it will be a pain in the neck for them to require encryption to do so. And unlike the arbitrary code execution allowed by the remote process server, the threat model of \"someone can temporarily ask politely for other programs not to open a HDF5 file if they know its exact name\" doesn't exactly have me shaking in my boots.\r\n\r\nSo I'm undecided about how to resolve this. Two options are:\r\n\r\n1. Add a setting to labconfig to leave zlock, specifically, unencrypted\r\n2. Make a proxy script that can run locally that forwards an unencrypted zmq REQ socket to a remote encrypted zmq REP socket. This could be used to allow programs like BIAS to talk to an encrypted zlock server.\r\n\r\nThis is exluding the third option where people with programs like BIAS just run with `allow_insecure = True` all the time - that strikes me as not a good plan.\r\n\r\nBoth of these options are easy to implement. The latter would likely mean adding another port number in labconfig for the local zlock proxy, and then the proxy would be started with something like `python -m labscript_utils.zlockproxy`. BIAS would then need to be modified to talk to localhost and that port number instead of a remote zlock server.\r\n\r\nThere is no particular reason for *logging* to be encrypted either given what it is, but I find it unappealing to have *some* connections encrypted and some not - this strikes me as more bug-prone than having *everything* encrypted. This is the main point against having zlock be an exception.\r\n\r\nInterested in people's thoughts, including @lincolndturner if you have any opinion here.\r\n\r\nA final option is that it might be possible to configure zlock to accept both encrypted and unencrypted traffic. This would be fairly ideal (so long as it optional so that people thinking they're using secure communication aren't misled), but zmq authentication is hard so it will be some effort to figure out if this is possible and implement it.", "links": {"decline": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/blacs/pullrequests/67/decline"}, "diffstat": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/blacs/diffstat/labscript_suite/blacs:f2b66b426b03%0D5cde3d142ed8?from_pullrequest_id=67"}, "commits": {"href": "data/repositories/labscript_suite/blacs/pullrequests/67/commits.json"}, "self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/67.json"}, "comments": {"href": "data/repositories/labscript_suite/blacs/pullrequests/67/comments_page=1.json"}, "merge": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/blacs/pullrequests/67/merge"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/67"}, "activity": {"href": "data/repositories/labscript_suite/blacs/pullrequests/67/activity.json"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/blacs/diff/labscript_suite/blacs:f2b66b426b03%0D5cde3d142ed8?from_pullrequest_id=67"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/blacs/pullrequests/67/approve"}, "statuses": {"href": "data/repositories/labscript_suite/blacs/pullrequests/67/statuses_page=1.json"}}, "title": "Implement remote workers in BLACS", "close_source_branch": true, "reviewers": [{"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}, {"display_name": "Philip Starkey", "uuid": "{0147401a-13ed-4e39-a0d0-63108c18738b}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D"}, "html": {"href": "https://bitbucket.org/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/fa0698c306b3470c00717c146b5296e9d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "philipstarkey", "type": "user", "account_id": "557058:2f99420c-1dbd-4837-952c-82c421b8fbdd"}], "id": 67, "destination": {"commit": {"hash": "5cde3d142ed8", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/blacs/commit/5cde3d142ed8.json"}, "html": {"href": "#!/labscript_suite/blacs/commits/5cde3d142ed8"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs.json"}, "html": {"href": "#!/labscript_suite/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}ts=249915"}}, "type": "repository", "name": "BLACS", "full_name": "labscript_suite/blacs", "uuid": "{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}"}, "branch": {"name": "default"}}, "created_on": "2019-04-24T18:13:30.841322+00:00", "summary": {"raw": "* Add support for remote workers.\r\n    Raise NotImplementedError on request for remote GUI, or multi-hop remote\r\n    workers, neither of which are supported quite yet.\r\n    Require labscript_utils 2.12.4, which has fixes for remote workers\r\n    and which in turn relies on a zprocess version with other required fixes.\r\n\r\n* Convert h5 filepaths to network agnostic before sending them to worker\r\n    processes for transition_to_buffered.\r\n\r\n    Only do this if the device is actually a remote device. This way, it is backward\r\n    compatible with device not expecting remote paths. Workers that are updated to\r\n    support being remote workers will need to check `self.is_remote` before calling\r\n    `path_to_local`, since if running locally the path with continue to be a local one.\r\n\r\n    Bump patch version so that labscript devices can depend on this new behaviour.\r\n\r\nThis PR requires labscript_utils [pull request 77](#!/labscript_suite/labscript_utils/pull-requests/77/), and so should be merged after it, with the version check updated to reflect whatever version number that PR ends up being tagged as.\r\n\r\nIt is not currently obvious how to setup and run remote workers. I will need to document how to start the remote process server, including configuring a security key.\r\n\r\nFor now, if anyone wants to test, this is my test script:\r\n```python\r\nfrom labscript import *\r\nfrom labscript_devices.PulseBlaster import PulseBlaster\r\nfrom labscript_devices.IMAQdxCamera.labscript_devices import IMAQdxCamera\r\n\r\nPulseBlaster('pulseblaster')\r\nTrigger('camera_trigger', pulseblaster.direct_outputs, 'flag 0')\r\nRemoteBLACS('test_remote', 'localhost')\r\nIMAQdxCamera(\r\n    'camera', camera_trigger, 'trigger', serial_number=0xDEADBEEF, worker=test_remote\r\n)\r\nIMAQdxCamera('camera2', camera_trigger, 'trigger', serial_number=0xDEADBEEF)\r\nstart()\r\n\r\ncamera.expose(1, 'test', trigger_duration=0.2)\r\ncamera2.expose(1, 'test', trigger_duration=0.2)\r\n\r\nstop(2)\r\n```\r\n\r\nAnd to start a zprocess remote server, you will need to run `python -m labscript_utils.remote` on the remote computer.\r\n\r\nYou will want to configure security - I think the remote server refuses to run presently unless you have either set\r\n```\r\n[security]\r\nshared_secret=<path to shared secret file>\r\n```\r\nor\r\n```\r\n[security]\r\nallow_insecure = True\r\n```\r\n\r\nin your labconfig.\r\n\r\nA new shared secret file can be generated with `python -m zprocess.makesecret`. Obviously all labconfigs on the computers that need to communicate with each other will need to have the same shared secret file.\r\n\r\nOne complication of enabling encryption is that it is enabled for all zmq communication in the labscript suite. This includes zlock. To start zlock with labscript-suite security settings, it needs to be started as `python -m labscript_utils.zlock` instead of `python -m zprocess.locking` or `python -m zprocess.zlock` (the former is an alias for the latter nowadays). However, if you look at `labscript_utils.zlock` you can see that all it is doing is reading labconfig and calling `python -m zprocess.zlock <command line args>`, so if running zlock on a separate computer without the labscript suite, it is easy enough to pass in the required shared secret on the command line.  `python -m zprocess.zlock -h` will list command line options for running a zlock server.\r\n\r\nSo you will need to restart zlock servers with encryption enabled, furthermore, you will need to kill zlog servers that may still be running after turning encryption on, as they will need to be started again with encryption.\r\n\r\nThe reason zlock is a complication is that non-python programs may need to talk to zlock still (such as BIAS), and it will be a pain in the neck for them to require encryption to do so. And unlike the arbitrary code execution allowed by the remote process server, the threat model of \"someone can temporarily ask politely for other programs not to open a HDF5 file if they know its exact name\" doesn't exactly have me shaking in my boots.\r\n\r\nSo I'm undecided about how to resolve this. Two options are:\r\n\r\n1. Add a setting to labconfig to leave zlock, specifically, unencrypted\r\n2. Make a proxy script that can run locally that forwards an unencrypted zmq REQ socket to a remote encrypted zmq REP socket. This could be used to allow programs like BIAS to talk to an encrypted zlock server.\r\n\r\nThis is exluding the third option where people with programs like BIAS just run with `allow_insecure = True` all the time - that strikes me as not a good plan.\r\n\r\nBoth of these options are easy to implement. The latter would likely mean adding another port number in labconfig for the local zlock proxy, and then the proxy would be started with something like `python -m labscript_utils.zlockproxy`. BIAS would then need to be modified to talk to localhost and that port number instead of a remote zlock server.\r\n\r\nThere is no particular reason for *logging* to be encrypted either given what it is, but I find it unappealing to have *some* connections encrypted and some not - this strikes me as more bug-prone than having *everything* encrypted. This is the main point against having zlock be an exception.\r\n\r\nInterested in people's thoughts, including @lincolndturner if you have any opinion here.\r\n\r\nA final option is that it might be possible to configure zlock to accept both encrypted and unencrypted traffic. This would be fairly ideal (so long as it optional so that people thinking they're using secure communication aren't misled), but zmq authentication is hard so it will be some effort to figure out if this is possible and implement it.", "markup": "markdown", "html": "<ul>\n<li>\n<p>Add support for remote workers.\n    Raise NotImplementedError on request for remote GUI, or multi-hop remote\n    workers, neither of which are supported quite yet.\n    Require labscript_utils 2.12.4, which has fixes for remote workers\n    and which in turn relies on a zprocess version with other required fixes.</p>\n</li>\n<li>\n<p>Convert h5 filepaths to network agnostic before sending them to worker\n    processes for transition_to_buffered.</p>\n<p>Only do this if the device is actually a remote device. This way, it is backward\ncompatible with device not expecting remote paths. Workers that are updated to\nsupport being remote workers will need to check <code>self.is_remote</code> before calling\n<code>path_to_local</code>, since if running locally the path with continue to be a local one.</p>\n<p>Bump patch version so that labscript devices can depend on this new behaviour.</p>\n</li>\n</ul>\n<p>This PR requires labscript_utils <a data-is-external-link=\"true\" href=\"#!/labscript_suite/labscript_utils/pull-requests/77/\" rel=\"nofollow\">pull request 77</a>, and so should be merged after it, with the version check updated to reflect whatever version number that PR ends up being tagged as.</p>\n<p>It is not currently obvious how to setup and run remote workers. I will need to document how to start the remote process server, including configuring a security key.</p>\n<p>For now, if anyone wants to test, this is my test script:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">labscript</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n<span class=\"kn\">from</span> <span class=\"nn\">labscript_devices.PulseBlaster</span> <span class=\"kn\">import</span> <span class=\"n\">PulseBlaster</span>\n<span class=\"kn\">from</span> <span class=\"nn\">labscript_devices.IMAQdxCamera.labscript_devices</span> <span class=\"kn\">import</span> <span class=\"n\">IMAQdxCamera</span>\n\n<span class=\"n\">PulseBlaster</span><span class=\"p\">(</span><span class=\"s1\">&#39;pulseblaster&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">Trigger</span><span class=\"p\">(</span><span class=\"s1\">&#39;camera_trigger&#39;</span><span class=\"p\">,</span> <span class=\"n\">pulseblaster</span><span class=\"o\">.</span><span class=\"n\">direct_outputs</span><span class=\"p\">,</span> <span class=\"s1\">&#39;flag 0&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">RemoteBLACS</span><span class=\"p\">(</span><span class=\"s1\">&#39;test_remote&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;localhost&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">IMAQdxCamera</span><span class=\"p\">(</span>\n    <span class=\"s1\">&#39;camera&#39;</span><span class=\"p\">,</span> <span class=\"n\">camera_trigger</span><span class=\"p\">,</span> <span class=\"s1\">&#39;trigger&#39;</span><span class=\"p\">,</span> <span class=\"n\">serial_number</span><span class=\"o\">=</span><span class=\"mh\">0xDEADBEEF</span><span class=\"p\">,</span> <span class=\"n\">worker</span><span class=\"o\">=</span><span class=\"n\">test_remote</span>\n<span class=\"p\">)</span>\n<span class=\"n\">IMAQdxCamera</span><span class=\"p\">(</span><span class=\"s1\">&#39;camera2&#39;</span><span class=\"p\">,</span> <span class=\"n\">camera_trigger</span><span class=\"p\">,</span> <span class=\"s1\">&#39;trigger&#39;</span><span class=\"p\">,</span> <span class=\"n\">serial_number</span><span class=\"o\">=</span><span class=\"mh\">0xDEADBEEF</span><span class=\"p\">)</span>\n<span class=\"n\">start</span><span class=\"p\">()</span>\n\n<span class=\"n\">camera</span><span class=\"o\">.</span><span class=\"n\">expose</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">&#39;test&#39;</span><span class=\"p\">,</span> <span class=\"n\">trigger_duration</span><span class=\"o\">=</span><span class=\"mf\">0.2</span><span class=\"p\">)</span>\n<span class=\"n\">camera2</span><span class=\"o\">.</span><span class=\"n\">expose</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">&#39;test&#39;</span><span class=\"p\">,</span> <span class=\"n\">trigger_duration</span><span class=\"o\">=</span><span class=\"mf\">0.2</span><span class=\"p\">)</span>\n\n<span class=\"n\">stop</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>And to start a zprocess remote server, you will need to run <code>python -m labscript_utils.remote</code> on the remote computer.</p>\n<p>You will want to configure security - I think the remote server refuses to run presently unless you have either set</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">[security]</span>\n<span class=\"na\">shared_secret</span><span class=\"o\">=</span><span class=\"s\">&lt;path to shared secret file&gt;</span>\n</pre></div>\n\n\n<p>or</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">[security]</span>\n<span class=\"na\">allow_insecure</span> <span class=\"o\">=</span> <span class=\"s\">True</span>\n</pre></div>\n\n\n<p>in your labconfig.</p>\n<p>A new shared secret file can be generated with <code>python -m zprocess.makesecret</code>. Obviously all labconfigs on the computers that need to communicate with each other will need to have the same shared secret file.</p>\n<p>One complication of enabling encryption is that it is enabled for all zmq communication in the labscript suite. This includes zlock. To start zlock with labscript-suite security settings, it needs to be started as <code>python -m labscript_utils.zlock</code> instead of <code>python -m zprocess.locking</code> or <code>python -m zprocess.zlock</code> (the former is an alias for the latter nowadays). However, if you look at <code>labscript_utils.zlock</code> you can see that all it is doing is reading labconfig and calling <code>python -m zprocess.zlock &lt;command line args&gt;</code>, so if running zlock on a separate computer without the labscript suite, it is easy enough to pass in the required shared secret on the command line.  <code>python -m zprocess.zlock -h</code> will list command line options for running a zlock server.</p>\n<p>So you will need to restart zlock servers with encryption enabled, furthermore, you will need to kill zlog servers that may still be running after turning encryption on, as they will need to be started again with encryption.</p>\n<p>The reason zlock is a complication is that non-python programs may need to talk to zlock still (such as BIAS), and it will be a pain in the neck for them to require encryption to do so. And unlike the arbitrary code execution allowed by the remote process server, the threat model of \"someone can temporarily ask politely for other programs not to open a HDF5 file if they know its exact name\" doesn't exactly have me shaking in my boots.</p>\n<p>So I'm undecided about how to resolve this. Two options are:</p>\n<ol>\n<li>Add a setting to labconfig to leave zlock, specifically, unencrypted</li>\n<li>Make a proxy script that can run locally that forwards an unencrypted zmq REQ socket to a remote encrypted zmq REP socket. This could be used to allow programs like BIAS to talk to an encrypted zlock server.</li>\n</ol>\n<p>This is exluding the third option where people with programs like BIAS just run with <code>allow_insecure = True</code> all the time - that strikes me as not a good plan.</p>\n<p>Both of these options are easy to implement. The latter would likely mean adding another port number in labconfig for the local zlock proxy, and then the proxy would be started with something like <code>python -m labscript_utils.zlockproxy</code>. BIAS would then need to be modified to talk to localhost and that port number instead of a remote zlock server.</p>\n<p>There is no particular reason for <em>logging</em> to be encrypted either given what it is, but I find it unappealing to have <em>some</em> connections encrypted and some not - this strikes me as more bug-prone than having <em>everything</em> encrypted. This is the main point against having zlock be an exception.</p>\n<p>Interested in people's thoughts, including @lincolndturner if you have any opinion here.</p>\n<p>A final option is that it might be possible to configure zlock to accept both encrypted and unencrypted traffic. This would be fairly ideal (so long as it optional so that people thinking they're using secure communication aren't misled), but zmq authentication is hard so it will be some effort to figure out if this is possible and implement it.</p>", "type": "rendered"}, "source": {"commit": {"hash": "6740894fd68a", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/blacs/commit/6740894fd68a"}, "html": {"href": "#!/cbillington/blacs/commits/6740894fd68a"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/blacs"}, "html": {"href": "#!/cbillington/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{1ffc697c-0cdc-43c3-b124-343fa9d9cc95}ts=python"}}, "type": "repository", "name": "BLACS", "full_name": "cbillington/blacs", "uuid": "{1ffc697c-0cdc-43c3-b124-343fa9d9cc95}"}, "branch": {"name": "remote-workers"}}, "comment_count": 34, "state": "MERGED", "task_count": 0, "participants": [{"role": "PARTICIPANT", "participated_on": "2019-05-29T18:50:13.048271+00:00", "type": "participant", "approved": false, "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}}, {"role": "REVIEWER", "participated_on": "2019-04-29T01:27:42.919006+00:00", "type": "participant", "approved": false, "user": {"display_name": "Philip Starkey", "uuid": "{0147401a-13ed-4e39-a0d0-63108c18738b}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D"}, "html": {"href": "https://bitbucket.org/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/fa0698c306b3470c00717c146b5296e9d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "philipstarkey", "type": "user", "account_id": "557058:2f99420c-1dbd-4837-952c-82c421b8fbdd"}}, {"role": "REVIEWER", "participated_on": "2019-05-13T12:14:18.494025+00:00", "type": "participant", "approved": true, "user": {"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}}, {"role": "PARTICIPANT", "participated_on": "2019-05-28T18:34:29.349320+00:00", "type": "participant", "approved": false, "user": {"display_name": "Lars Kohfahl", "uuid": "{14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a%7D"}, "html": {"href": "https://bitbucket.org/%7B14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/630642264cd55e22515678a3a0489ac7d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLK-2.png"}}, "nickname": "lkohfahl", "type": "user", "account_id": "5aafc5d11396802a57aa7f3b"}}], "reason": "", "updated_on": "2019-05-29T18:50:21.805196+00:00", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "merge_commit": {"hash": "f2b66b426b03", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/blacs/commit/f2b66b426b03.json"}, "html": {"href": "#!/labscript_suite/blacs/commits/f2b66b426b03"}}}, "closed_by": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}}