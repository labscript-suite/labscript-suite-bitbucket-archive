{"links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/67/comments/100230238.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/67/_/diff#comment-100230238"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 67, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/67.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/67"}}, "title": "Implement remote workers in BLACS"}, "content": {"raw": "Yes, the zprocess remote server only starts the processes, it doesn\u2019t play any role in their continued interaction with BLACS unless BLACS wants to call methods of the `Popen` object. I didn\u2019t expect the subprocesses to not be terminated when the server dies, but I guess that makes some kind of sense - it must be because their stdin and stdout/stderr are set to os.devnull, so that sort of detaches them from their parent process.\n\nIf the server dies, even if it is subsequently restarted, BLACS can\u2019t then terminate the processes normally since the newly running server doesn\u2019t know about them. However, the subprocesses are still heartbeating back to BLACS, so they will die if BLACS closes.\n\nAll this is to say that yes, BLACS is fragile to the remote process server stopping, and really needs it to be running continuously. We could make it more robust, but it\u2019s worth pointing out that this is no different to zlock - BLACS \\(and other programs\\) don\u2019t recover well if the zlock server goes down \\(though it merely restarting is fine, so that\u2019s one difference\\).\n\nSo firstly I could go through BLACS for every place it calls a method on a subprocess, and modify all the calls so that they a\\) don\u2019t block the GUI and b\\) handle the timeout error sensibly and recoverably. This should also be done for interaction with HDF5 files, to make zlock failures not take down the whole program as well.\n\nI\u2019m not sure why BLACS should get stuck in \u2018State: \\_transition\\_to\\_buffered \\(GUI\\)\u2019. That shouldn\u2019t involve waiting on the child process - will need to look into that. Perhaps the zmq sockets we\u2019re using are the kind where if they can\u2019t send, they block. If so, I should change this to to either error right away or just queue to send later, so that it either be detected right away that the child process is dead \\(well, or the network is down\\), or so that the error becomes a timeout one instead of a hang.\n\nAlso, I could make the zprocess.remote server have some disk persistence. Perhaps when it is closed cleanly by the user, it could write to disk the current process list so that its state could be restored upon restart. Though it probably won\u2019t save the command line of the processes, or if it does it will need to be encrypted with the shared secret, since they contain the shared secret, so wouldn\u2019t want to leak that. Alternately, I could make it that if the server receives a request for a process ID number it doesn\u2019t know about, it could go ahead and run the requested method anyway - using the os module functions that accept a pid, since the server wouldn\u2019t have a Popen object. If the server resumed its state in any way, it would need to do that anyway, since it would only have pids and not the Popen objects upon restarting.", "markup": "markdown", "html": "<p>Yes, the zprocess remote server only starts the processes, it doesn\u2019t play any role in their continued interaction with BLACS unless BLACS wants to call methods of the <code>Popen</code> object. I didn\u2019t expect the subprocesses to not be terminated when the server dies, but I guess that makes some kind of sense - it must be because their stdin and stdout/stderr are set to os.devnull, so that sort of detaches them from their parent process.</p>\n<p>If the server dies, even if it is subsequently restarted, BLACS can\u2019t then terminate the processes normally since the newly running server doesn\u2019t know about them. However, the subprocesses are still heartbeating back to BLACS, so they will die if BLACS closes.</p>\n<p>All this is to say that yes, BLACS is fragile to the remote process server stopping, and really needs it to be running continuously. We could make it more robust, but it\u2019s worth pointing out that this is no different to zlock - BLACS (and other programs) don\u2019t recover well if the zlock server goes down (though it merely restarting is fine, so that\u2019s one difference).</p>\n<p>So firstly I could go through BLACS for every place it calls a method on a subprocess, and modify all the calls so that they a) don\u2019t block the GUI and b) handle the timeout error sensibly and recoverably. This should also be done for interaction with HDF5 files, to make zlock failures not take down the whole program as well.</p>\n<p>I\u2019m not sure why BLACS should get stuck in \u2018State: _transition_to_buffered (GUI)\u2019. That shouldn\u2019t involve waiting on the child process - will need to look into that. Perhaps the zmq sockets we\u2019re using are the kind where if they can\u2019t send, they block. If so, I should change this to to either error right away or just queue to send later, so that it either be detected right away that the child process is dead (well, or the network is down), or so that the error becomes a timeout one instead of a hang.</p>\n<p>Also, I could make the zprocess.remote server have some disk persistence. Perhaps when it is closed cleanly by the user, it could write to disk the current process list so that its state could be restored upon restart. Though it probably won\u2019t save the command line of the processes, or if it does it will need to be encrypted with the shared secret, since they contain the shared secret, so wouldn\u2019t want to leak that. Alternately, I could make it that if the server receives a request for a process ID number it doesn\u2019t know about, it could go ahead and run the requested method anyway - using the os module functions that accept a pid, since the server wouldn\u2019t have a Popen object. If the server resumed its state in any way, it would need to do that anyway, since it would only have pids and not the Popen objects upon restarting.</p>", "type": "rendered"}, "created_on": "2019-04-28T15:51:10.041640+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-04-28T15:57:35.832672+00:00", "type": "pullrequest_comment", "id": 100230238}