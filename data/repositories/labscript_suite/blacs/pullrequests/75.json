{"rendered": {"description": {"raw": "This PR addresses the more general discussion about how to incorporate manual control of device settings from BLACS is [labscript\\_utils issue 26](#!/labscript_suite/labscript_utils/issues/26/add-enum-control-widget). This PR aspires to add the framework for device\\_properties widgets in a device BLACS tab in much the same way AO, DO, DDS, and Image outputs are handled now.\r\n\r\nConfiguration is done using a new style of property dictionary that uses either an AO, DO, or new EO output for each property.\r\n\r\n> `device_properties = {'device_property':{'default':value, 'type':'num', 'min':0, 'max':1, 'base_unit':'V', 'step':0.1, 'decimals':1}, `\r\n>\r\n> `                     'device_property2'}:{'default':value, 'type':'bool'},`\r\n>\r\n> `                     'device_property3'}:{'default':'value','type':'enum','options':['option 1','option 2']}}`\r\n\r\nIt also establishes the `program_device_properties` state machine method which works in parallel to the `program_devices` method. In order to program these properties, the BLACS\\_worker must define a `program_properties` method in order to control any specified device properties. \r\n\r\nThis requires [PR #93 from labscript\\_utils](#!/labscript_suite/labscript_utils/pull-requests/93/add-enumoutput-widget-type/diff). The enum controls have only been tested for basic functionality. That said, most of the functionality is lifted from the AO and DO devices so I suspect it will be fairly robust.\r\n\r\nKnown Issues remaining:\r\n\r\n* Currently, automatic layout is done either by hand or using `auto_place_widgets` method with a custom group name defined by the user. When mixing types of outputs, it isn't particularly pretty. A separate method for property widgets with more refined layout control is likely necessary. In particular, `auto_place_widgets` does not play nice with the camera tab layouts at the moment. \r\n* Default values are not respected. For the AO and DO properties this isn\u2019t a big issue. For the EO output this is a pretty big problem. Right now it selects the output based on alphabetical sorting \\(necessitated by laziness while also wanting to allow list, dict, and tuple inputs for the \u2018options\u2019\\) which often will place the device in an unusable state at initial startup. This is particularly true when many interacting settings are being controlled at once.\r\n* Remote value checking is still up in the air. I initially thought that the `check_remote_values` method of the worker should populate the properties values as well as the output values. In getting my camera up and running with some test widgets, I found this to be problematic since all properties are read at once, which causes needless slowdowns. I need to work out how to limit the properties read during `check_remote_values` to only those in the device\\_properties definition.\r\n\r\nI\u2019ve gotten a test case working for the Pylon camera which I\u2019ll put up as a third PR to labscript\\_devices. Usage is still pretty rough but I wanted to get feedback on the approach before sinking more time in. Beyond the above issues, I\u2019d like some input on:\r\n\r\n* How best to integrate all of this with the labscript device itself? Should device properties still be configured from device instantiation args or should we move to controlled properties being used more like standard Outputs? I lean towards the former.\r\n* Right now I am working towards having the controlled device properties be largely incorporated into the standard outputs workflow of the device with regards to smart programming and checking remote values, while having a separate programming workflow. Is that a good idea?\r\n* The meta-class is ultimately going to make this all easier. Is there any special conventions we\u2019d like to incorporate beyond moving already statically defined things to it?\r\n\r\n\u200c", "markup": "markdown", "html": "<p>This PR addresses the more general discussion about how to incorporate manual control of device settings from BLACS is <a data-is-external-link=\"true\" href=\"#!/labscript_suite/labscript_utils/issues/26/add-enum-control-widget\" rel=\"nofollow\">labscript_utils issue 26</a>. This PR aspires to add the framework for device_properties widgets in a device BLACS tab in much the same way AO, DO, DDS, and Image outputs are handled now.</p>\n<p>Configuration is done using a new style of property dictionary that uses either an AO, DO, or new EO output for each property.</p>\n<blockquote>\n<p><code>device_properties = {'device_property':{'default':value, 'type':'num', 'min':0, 'max':1, 'base_unit':'V', 'step':0.1, 'decimals':1},</code></p>\n<p><code>'device_property2'}:{'default':value, 'type':'bool'},</code></p>\n<p><code>'device_property3'}:{'default':'value','type':'enum','options':['option 1','option 2']}}</code></p>\n</blockquote>\n<p>It also establishes the <code>program_device_properties</code> state machine method which works in parallel to the <code>program_devices</code> method. In order to program these properties, the BLACS_worker must define a <code>program_properties</code> method in order to control any specified device properties. </p>\n<p>This requires <a data-is-external-link=\"true\" href=\"#!/labscript_suite/labscript_utils/pull-requests/93/add-enumoutput-widget-type/diff\" rel=\"nofollow\">PR #93 from labscript_utils</a>. The enum controls have only been tested for basic functionality. That said, most of the functionality is lifted from the AO and DO devices so I suspect it will be fairly robust.</p>\n<p>Known Issues remaining:</p>\n<ul>\n<li>Currently, automatic layout is done either by hand or using <code>auto_place_widgets</code> method with a custom group name defined by the user. When mixing types of outputs, it isn't particularly pretty. A separate method for property widgets with more refined layout control is likely necessary. In particular, <code>auto_place_widgets</code> does not play nice with the camera tab layouts at the moment. </li>\n<li>Default values are not respected. For the AO and DO properties this isn\u2019t a big issue. For the EO output this is a pretty big problem. Right now it selects the output based on alphabetical sorting (necessitated by laziness while also wanting to allow list, dict, and tuple inputs for the \u2018options\u2019) which often will place the device in an unusable state at initial startup. This is particularly true when many interacting settings are being controlled at once.</li>\n<li>Remote value checking is still up in the air. I initially thought that the <code>check_remote_values</code> method of the worker should populate the properties values as well as the output values. In getting my camera up and running with some test widgets, I found this to be problematic since all properties are read at once, which causes needless slowdowns. I need to work out how to limit the properties read during <code>check_remote_values</code> to only those in the device_properties definition.</li>\n</ul>\n<p>I\u2019ve gotten a test case working for the Pylon camera which I\u2019ll put up as a third PR to labscript_devices. Usage is still pretty rough but I wanted to get feedback on the approach before sinking more time in. Beyond the above issues, I\u2019d like some input on:</p>\n<ul>\n<li>How best to integrate all of this with the labscript device itself? Should device properties still be configured from device instantiation args or should we move to controlled properties being used more like standard Outputs? I lean towards the former.</li>\n<li>Right now I am working towards having the controlled device properties be largely incorporated into the standard outputs workflow of the device with regards to smart programming and checking remote values, while having a separate programming workflow. Is that a good idea?</li>\n<li>The meta-class is ultimately going to make this all easier. Is there any special conventions we\u2019d like to incorporate beyond moving already statically defined things to it?</li>\n</ul>\n<p>\u200c</p>", "type": "rendered"}, "title": {"raw": "Device properties", "markup": "markdown", "html": "<p>Device properties</p>", "type": "rendered"}}, "type": "pullrequest", "description": "This PR addresses the more general discussion about how to incorporate manual control of device settings from BLACS is [labscript\\_utils issue 26](#!/labscript_suite/labscript_utils/issues/26/add-enum-control-widget). This PR aspires to add the framework for device\\_properties widgets in a device BLACS tab in much the same way AO, DO, DDS, and Image outputs are handled now.\r\n\r\nConfiguration is done using a new style of property dictionary that uses either an AO, DO, or new EO output for each property.\r\n\r\n> `device_properties = {'device_property':{'default':value, 'type':'num', 'min':0, 'max':1, 'base_unit':'V', 'step':0.1, 'decimals':1}, `\r\n>\r\n> `                     'device_property2'}:{'default':value, 'type':'bool'},`\r\n>\r\n> `                     'device_property3'}:{'default':'value','type':'enum','options':['option 1','option 2']}}`\r\n\r\nIt also establishes the `program_device_properties` state machine method which works in parallel to the `program_devices` method. In order to program these properties, the BLACS\\_worker must define a `program_properties` method in order to control any specified device properties. \r\n\r\nThis requires [PR #93 from labscript\\_utils](#!/labscript_suite/labscript_utils/pull-requests/93/add-enumoutput-widget-type/diff). The enum controls have only been tested for basic functionality. That said, most of the functionality is lifted from the AO and DO devices so I suspect it will be fairly robust.\r\n\r\nKnown Issues remaining:\r\n\r\n* Currently, automatic layout is done either by hand or using `auto_place_widgets` method with a custom group name defined by the user. When mixing types of outputs, it isn't particularly pretty. A separate method for property widgets with more refined layout control is likely necessary. In particular, `auto_place_widgets` does not play nice with the camera tab layouts at the moment. \r\n* Default values are not respected. For the AO and DO properties this isn\u2019t a big issue. For the EO output this is a pretty big problem. Right now it selects the output based on alphabetical sorting \\(necessitated by laziness while also wanting to allow list, dict, and tuple inputs for the \u2018options\u2019\\) which often will place the device in an unusable state at initial startup. This is particularly true when many interacting settings are being controlled at once.\r\n* Remote value checking is still up in the air. I initially thought that the `check_remote_values` method of the worker should populate the properties values as well as the output values. In getting my camera up and running with some test widgets, I found this to be problematic since all properties are read at once, which causes needless slowdowns. I need to work out how to limit the properties read during `check_remote_values` to only those in the device\\_properties definition.\r\n\r\nI\u2019ve gotten a test case working for the Pylon camera which I\u2019ll put up as a third PR to labscript\\_devices. Usage is still pretty rough but I wanted to get feedback on the approach before sinking more time in. Beyond the above issues, I\u2019d like some input on:\r\n\r\n* How best to integrate all of this with the labscript device itself? Should device properties still be configured from device instantiation args or should we move to controlled properties being used more like standard Outputs? I lean towards the former.\r\n* Right now I am working towards having the controlled device properties be largely incorporated into the standard outputs workflow of the device with regards to smart programming and checking remote values, while having a separate programming workflow. Is that a good idea?\r\n* The meta-class is ultimately going to make this all easier. Is there any special conventions we\u2019d like to incorporate beyond moving already statically defined things to it?\r\n\r\n\u200c", "links": {"decline": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/blacs/pullrequests/75/decline"}, "diffstat": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/blacs/diffstat/dihm/blacs:8b5909f70bbf%0D5d3b0134453f?from_pullrequest_id=75"}, "commits": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75/commits.json"}, "self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "comments": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75/comments_page=1.json"}, "merge": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/blacs/pullrequests/75/merge"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}, "activity": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75/activity.json"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/blacs/diff/dihm/blacs:8b5909f70bbf%0D5d3b0134453f?from_pullrequest_id=75"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/blacs/pullrequests/75/approve"}, "statuses": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75/statuses_page=1.json"}}, "title": "Device properties", "close_source_branch": true, "reviewers": [{"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}], "id": 75, "destination": {"commit": {"hash": "5d3b0134453f", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/blacs/commit/5d3b0134453f.json"}, "html": {"href": "#!/labscript_suite/blacs/commits/5d3b0134453f"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs.json"}, "html": {"href": "#!/labscript_suite/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}ts=249915"}}, "type": "repository", "name": "BLACS", "full_name": "labscript_suite/blacs", "uuid": "{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}"}, "branch": {"name": "default"}}, "created_on": "2019-10-09T00:02:03.574064+00:00", "summary": {"raw": "This PR addresses the more general discussion about how to incorporate manual control of device settings from BLACS is [labscript\\_utils issue 26](#!/labscript_suite/labscript_utils/issues/26/add-enum-control-widget). This PR aspires to add the framework for device\\_properties widgets in a device BLACS tab in much the same way AO, DO, DDS, and Image outputs are handled now.\r\n\r\nConfiguration is done using a new style of property dictionary that uses either an AO, DO, or new EO output for each property.\r\n\r\n> `device_properties = {'device_property':{'default':value, 'type':'num', 'min':0, 'max':1, 'base_unit':'V', 'step':0.1, 'decimals':1}, `\r\n>\r\n> `                     'device_property2'}:{'default':value, 'type':'bool'},`\r\n>\r\n> `                     'device_property3'}:{'default':'value','type':'enum','options':['option 1','option 2']}}`\r\n\r\nIt also establishes the `program_device_properties` state machine method which works in parallel to the `program_devices` method. In order to program these properties, the BLACS\\_worker must define a `program_properties` method in order to control any specified device properties. \r\n\r\nThis requires [PR #93 from labscript\\_utils](#!/labscript_suite/labscript_utils/pull-requests/93/add-enumoutput-widget-type/diff). The enum controls have only been tested for basic functionality. That said, most of the functionality is lifted from the AO and DO devices so I suspect it will be fairly robust.\r\n\r\nKnown Issues remaining:\r\n\r\n* Currently, automatic layout is done either by hand or using `auto_place_widgets` method with a custom group name defined by the user. When mixing types of outputs, it isn't particularly pretty. A separate method for property widgets with more refined layout control is likely necessary. In particular, `auto_place_widgets` does not play nice with the camera tab layouts at the moment. \r\n* Default values are not respected. For the AO and DO properties this isn\u2019t a big issue. For the EO output this is a pretty big problem. Right now it selects the output based on alphabetical sorting \\(necessitated by laziness while also wanting to allow list, dict, and tuple inputs for the \u2018options\u2019\\) which often will place the device in an unusable state at initial startup. This is particularly true when many interacting settings are being controlled at once.\r\n* Remote value checking is still up in the air. I initially thought that the `check_remote_values` method of the worker should populate the properties values as well as the output values. In getting my camera up and running with some test widgets, I found this to be problematic since all properties are read at once, which causes needless slowdowns. I need to work out how to limit the properties read during `check_remote_values` to only those in the device\\_properties definition.\r\n\r\nI\u2019ve gotten a test case working for the Pylon camera which I\u2019ll put up as a third PR to labscript\\_devices. Usage is still pretty rough but I wanted to get feedback on the approach before sinking more time in. Beyond the above issues, I\u2019d like some input on:\r\n\r\n* How best to integrate all of this with the labscript device itself? Should device properties still be configured from device instantiation args or should we move to controlled properties being used more like standard Outputs? I lean towards the former.\r\n* Right now I am working towards having the controlled device properties be largely incorporated into the standard outputs workflow of the device with regards to smart programming and checking remote values, while having a separate programming workflow. Is that a good idea?\r\n* The meta-class is ultimately going to make this all easier. Is there any special conventions we\u2019d like to incorporate beyond moving already statically defined things to it?\r\n\r\n\u200c", "markup": "markdown", "html": "<p>This PR addresses the more general discussion about how to incorporate manual control of device settings from BLACS is <a data-is-external-link=\"true\" href=\"#!/labscript_suite/labscript_utils/issues/26/add-enum-control-widget\" rel=\"nofollow\">labscript_utils issue 26</a>. This PR aspires to add the framework for device_properties widgets in a device BLACS tab in much the same way AO, DO, DDS, and Image outputs are handled now.</p>\n<p>Configuration is done using a new style of property dictionary that uses either an AO, DO, or new EO output for each property.</p>\n<blockquote>\n<p><code>device_properties = {'device_property':{'default':value, 'type':'num', 'min':0, 'max':1, 'base_unit':'V', 'step':0.1, 'decimals':1},</code></p>\n<p><code>'device_property2'}:{'default':value, 'type':'bool'},</code></p>\n<p><code>'device_property3'}:{'default':'value','type':'enum','options':['option 1','option 2']}}</code></p>\n</blockquote>\n<p>It also establishes the <code>program_device_properties</code> state machine method which works in parallel to the <code>program_devices</code> method. In order to program these properties, the BLACS_worker must define a <code>program_properties</code> method in order to control any specified device properties. </p>\n<p>This requires <a data-is-external-link=\"true\" href=\"#!/labscript_suite/labscript_utils/pull-requests/93/add-enumoutput-widget-type/diff\" rel=\"nofollow\">PR #93 from labscript_utils</a>. The enum controls have only been tested for basic functionality. That said, most of the functionality is lifted from the AO and DO devices so I suspect it will be fairly robust.</p>\n<p>Known Issues remaining:</p>\n<ul>\n<li>Currently, automatic layout is done either by hand or using <code>auto_place_widgets</code> method with a custom group name defined by the user. When mixing types of outputs, it isn't particularly pretty. A separate method for property widgets with more refined layout control is likely necessary. In particular, <code>auto_place_widgets</code> does not play nice with the camera tab layouts at the moment. </li>\n<li>Default values are not respected. For the AO and DO properties this isn\u2019t a big issue. For the EO output this is a pretty big problem. Right now it selects the output based on alphabetical sorting (necessitated by laziness while also wanting to allow list, dict, and tuple inputs for the \u2018options\u2019) which often will place the device in an unusable state at initial startup. This is particularly true when many interacting settings are being controlled at once.</li>\n<li>Remote value checking is still up in the air. I initially thought that the <code>check_remote_values</code> method of the worker should populate the properties values as well as the output values. In getting my camera up and running with some test widgets, I found this to be problematic since all properties are read at once, which causes needless slowdowns. I need to work out how to limit the properties read during <code>check_remote_values</code> to only those in the device_properties definition.</li>\n</ul>\n<p>I\u2019ve gotten a test case working for the Pylon camera which I\u2019ll put up as a third PR to labscript_devices. Usage is still pretty rough but I wanted to get feedback on the approach before sinking more time in. Beyond the above issues, I\u2019d like some input on:</p>\n<ul>\n<li>How best to integrate all of this with the labscript device itself? Should device properties still be configured from device instantiation args or should we move to controlled properties being used more like standard Outputs? I lean towards the former.</li>\n<li>Right now I am working towards having the controlled device properties be largely incorporated into the standard outputs workflow of the device with regards to smart programming and checking remote values, while having a separate programming workflow. Is that a good idea?</li>\n<li>The meta-class is ultimately going to make this all easier. Is there any special conventions we\u2019d like to incorporate beyond moving already statically defined things to it?</li>\n</ul>\n<p>\u200c</p>", "type": "rendered"}, "source": {"commit": {"hash": "8b5909f70bbf", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/blacs/commit/8b5909f70bbf"}, "html": {"href": "#!/dihm/blacs/commits/8b5909f70bbf"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/blacs"}, "html": {"href": "#!/dihm/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{5d6c277c-4faa-4fa2-af9f-e3e49c4673b3}ts=python"}}, "type": "repository", "name": "BLACS", "full_name": "dihm/blacs", "uuid": "{5d6c277c-4faa-4fa2-af9f-e3e49c4673b3}"}, "branch": {"name": "device_properties"}}, "comment_count": 6, "state": "OPEN", "task_count": 0, "participants": [{"role": "REVIEWER", "participated_on": null, "type": "participant", "approved": false, "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}}, {"role": "PARTICIPANT", "participated_on": "2019-10-28T20:09:23.368672+00:00", "type": "participant", "approved": false, "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}}, {"role": "REVIEWER", "participated_on": null, "type": "participant", "approved": false, "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}}, {"role": "PARTICIPANT", "participated_on": "2020-01-16T09:01:33.160481+00:00", "type": "participant", "approved": false, "user": {"display_name": "Philip Starkey", "uuid": "{0147401a-13ed-4e39-a0d0-63108c18738b}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D"}, "html": {"href": "https://bitbucket.org/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/fa0698c306b3470c00717c146b5296e9d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "philipstarkey", "type": "user", "account_id": "557058:2f99420c-1dbd-4837-952c-82c421b8fbdd"}}], "reason": "", "updated_on": "2020-01-16T09:01:33.160481+00:00", "author": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "merge_commit": null, "closed_by": null}