{"pagelen": 50, "values": [{"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75/comments/131884530.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75/_/diff#comment-131884530"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}, "content": {"raw": "Sorry for the delay in getting back to you on this.\n\nI think you should go with what seems easiest to do right now. If that means duplicating code and having parallel paths then so be it. We can refactor it later, and the direction of that refactor will probably become clearer once the code has been written once \\(possibly with an update to the UI\\)\n\n\u200c\n\nOn another note, I\u2019m trying to categorise which PRs we can merge before moving to GitHub. I think it\u2019s unlikely this pull request will be ready in time. We should still leave it open on BitBucket \\(so that the archival process doesn\u2019t show this PR as declined\\) but we\u2019ll need to recreate it once the move is complete.", "markup": "markdown", "html": "<p>Sorry for the delay in getting back to you on this.</p>\n<p>I think you should go with what seems easiest to do right now. If that means duplicating code and having parallel paths then so be it. We can refactor it later, and the direction of that refactor will probably become clearer once the code has been written once (possibly with an update to the UI)</p>\n<p>\u200c</p>\n<p>On another note, I\u2019m trying to categorise which PRs we can merge before moving to GitHub. I think it\u2019s unlikely this pull request will be ready in time. We should still leave it open on BitBucket (so that the archival process doesn\u2019t show this PR as declined) but we\u2019ll need to recreate it once the move is complete.</p>", "type": "rendered"}, "created_on": "2020-01-16T09:01:33.149882+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{0147401a-13ed-4e39-a0d0-63108c18738b}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D"}, "html": {"href": "https://bitbucket.org/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/fa0698c306b3470c00717c146b5296e9d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "philipstarkey", "type": "user", "account_id": "557058:2f99420c-1dbd-4837-952c-82c421b8fbdd"}, "updated_on": "2020-01-16T09:01:33.160481+00:00", "type": "pullrequest_comment", "id": 131884530}, "pull_request": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}}, {"update": {"description": "This PR addresses the more general discussion about how to incorporate manual control of device settings from BLACS is [labscript\\_utils issue 26](#!/labscript_suite/labscript_utils/issues/26/add-enum-control-widget). This PR aspires to add the framework for device\\_properties widgets in a device BLACS tab in much the same way AO, DO, DDS, and Image outputs are handled now.\r\n\r\nConfiguration is done using a new style of property dictionary that uses either an AO, DO, or new EO output for each property.\r\n\r\n> `device_properties = {'device_property':{'default':value, 'type':'num', 'min':0, 'max':1, 'base_unit':'V', 'step':0.1, 'decimals':1}, `\r\n>\r\n> `                     'device_property2'}:{'default':value, 'type':'bool'},`\r\n>\r\n> `                     'device_property3'}:{'default':'value','type':'enum','options':['option 1','option 2']}}`\r\n\r\nIt also establishes the `program_device_properties` state machine method which works in parallel to the `program_devices` method. In order to program these properties, the BLACS\\_worker must define a `program_properties` method in order to control any specified device properties. \r\n\r\nThis requires [PR #93 from labscript\\_utils](#!/labscript_suite/labscript_utils/pull-requests/93/add-enumoutput-widget-type/diff). The enum controls have only been tested for basic functionality. That said, most of the functionality is lifted from the AO and DO devices so I suspect it will be fairly robust.\r\n\r\nKnown Issues remaining:\r\n\r\n* Currently, automatic layout is done either by hand or using `auto_place_widgets` method with a custom group name defined by the user. When mixing types of outputs, it isn't particularly pretty. A separate method for property widgets with more refined layout control is likely necessary. In particular, `auto_place_widgets` does not play nice with the camera tab layouts at the moment. \r\n* Default values are not respected. For the AO and DO properties this isn\u2019t a big issue. For the EO output this is a pretty big problem. Right now it selects the output based on alphabetical sorting \\(necessitated by laziness while also wanting to allow list, dict, and tuple inputs for the \u2018options\u2019\\) which often will place the device in an unusable state at initial startup. This is particularly true when many interacting settings are being controlled at once.\r\n* Remote value checking is still up in the air. I initially thought that the `check_remote_values` method of the worker should populate the properties values as well as the output values. In getting my camera up and running with some test widgets, I found this to be problematic since all properties are read at once, which causes needless slowdowns. I need to work out how to limit the properties read during `check_remote_values` to only those in the device\\_properties definition.\r\n\r\nI\u2019ve gotten a test case working for the Pylon camera which I\u2019ll put up as a third PR to labscript\\_devices. Usage is still pretty rough but I wanted to get feedback on the approach before sinking more time in. Beyond the above issues, I\u2019d like some input on:\r\n\r\n* How best to integrate all of this with the labscript device itself? Should device properties still be configured from device instantiation args or should we move to controlled properties being used more like standard Outputs? I lean towards the former.\r\n* Right now I am working towards having the controlled device properties be largely incorporated into the standard outputs workflow of the device with regards to smart programming and checking remote values, while having a separate programming workflow. Is that a good idea?\r\n* The meta-class is ultimately going to make this all easier. Is there any special conventions we\u2019d like to incorporate beyond moving already statically defined things to it?\r\n\r\n\u200c", "title": "Device properties", "destination": {"commit": {"hash": "1b4c69c290bd", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/blacs/commit/1b4c69c290bd.json"}, "html": {"href": "#!/labscript_suite/blacs/commits/1b4c69c290bd"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs.json"}, "html": {"href": "#!/labscript_suite/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}ts=249915"}}, "type": "repository", "name": "BLACS", "full_name": "labscript_suite/blacs", "uuid": "{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "8b5909f70bbf", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/blacs/commit/8b5909f70bbf"}, "html": {"href": "#!/dihm/blacs/commits/8b5909f70bbf"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/blacs"}, "html": {"href": "#!/dihm/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{5d6c277c-4faa-4fa2-af9f-e3e49c4673b3}ts=python"}}, "type": "repository", "name": "BLACS", "full_name": "dihm/blacs", "uuid": "{5d6c277c-4faa-4fa2-af9f-e3e49c4673b3}"}, "branch": {"name": "device_properties"}}, "state": "OPEN", "author": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "date": "2019-10-29T20:40:24.134376+00:00"}, "pull_request": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75/comments/122502914.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75/_/diff#comment-122502914"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}, "content": {"raw": "So we had a pressing need for this functionality in the lab so I went ahead and implemented a first pass on one of our devices, a SRS SG380 series function generator. In the process realized I hadn\u2019t exposed the index to the user in a satisfactory way. So I went ahead and added a required kwarg \\('return\\_type'\\) to the EO properties. This kwarg sets whether the \u2018index\u2019 or the \u2018value\u2019 is returned by the widget/output when requested. This is the current look of the functioning tab:\n\n![](data/bitbucket.org/repo/dR5qxr/images/1737565931-image.png)\nSince this is a more typical device, I\u2019ve started looking more closely at how to integrate remote value checks and smart programming. I\u2019m a little worried about the `check_remote_values` state machine method: it has a lot of hard-coding/assumptions built into it that would require a fair amount of rework to account for mixed-type outputs stored in a different output dictionary. Way I see it now I can either split the properties into a parallel `check_remote_properties` path or rework everything in `check_remote_values` to squash the input lists of `_last_remote_values` and `_last_programmed_values` to include device properties, global search `_DDS`, `_AO`, `_DO`, and `_devProp` dictionaries for the correct output, and then use inheritance checks to determine the correct formatting for the value change resolution. I\u2019m still leaning to having parallel programming/remote checking paths so I think I\u2019ll wait on some input from the group before moving on in the implementation.\n\n\u200c", "markup": "markdown", "html": "<p>So we had a pressing need for this functionality in the lab so I went ahead and implemented a first pass on one of our devices, a SRS SG380 series function generator. In the process realized I hadn\u2019t exposed the index to the user in a satisfactory way. So I went ahead and added a required kwarg ('return_type') to the EO properties. This kwarg sets whether the \u2018index\u2019 or the \u2018value\u2019 is returned by the widget/output when requested. This is the current look of the functioning tab:</p>\n<p><img alt=\"\" src=\"data/bitbucket.org/repo/dR5qxr/images/1737565931-image.png\" />\nSince this is a more typical device, I\u2019ve started looking more closely at how to integrate remote value checks and smart programming. I\u2019m a little worried about the <code>check_remote_values</code> state machine method: it has a lot of hard-coding/assumptions built into it that would require a fair amount of rework to account for mixed-type outputs stored in a different output dictionary. Way I see it now I can either split the properties into a parallel <code>check_remote_properties</code> path or rework everything in <code>check_remote_values</code> to squash the input lists of <code>_last_remote_values</code> and <code>_last_programmed_values</code> to include device properties, global search <code>_DDS</code>, <code>_AO</code>, <code>_DO</code>, and <code>_devProp</code> dictionaries for the correct output, and then use inheritance checks to determine the correct formatting for the value change resolution. I\u2019m still leaning to having parallel programming/remote checking paths so I think I\u2019ll wait on some input from the group before moving on in the implementation.</p>\n<p>\u200c</p>", "type": "rendered"}, "created_on": "2019-10-28T20:09:23.111864+00:00", "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "updated_on": "2019-10-28T20:09:23.368672+00:00", "type": "pullrequest_comment", "id": 122502914}, "pull_request": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}}, {"update": {"description": "This PR addresses the more general discussion about how to incorporate manual control of device settings from BLACS is [labscript\\_utils issue 26](#!/labscript_suite/labscript_utils/issues/26/add-enum-control-widget). This PR aspires to add the framework for device\\_properties widgets in a device BLACS tab in much the same way AO, DO, DDS, and Image outputs are handled now.\r\n\r\nConfiguration is done using a new style of property dictionary that uses either an AO, DO, or new EO output for each property.\r\n\r\n> `device_properties = {'device_property':{'default':value, 'type':'num', 'min':0, 'max':1, 'base_unit':'V', 'step':0.1, 'decimals':1}, `\r\n>\r\n> `                     'device_property2'}:{'default':value, 'type':'bool'},`\r\n>\r\n> `                     'device_property3'}:{'default':'value','type':'enum','options':['option 1','option 2']}}`\r\n\r\nIt also establishes the `program_device_properties` state machine method which works in parallel to the `program_devices` method. In order to program these properties, the BLACS\\_worker must define a `program_properties` method in order to control any specified device properties. \r\n\r\nThis requires [PR #93 from labscript\\_utils](#!/labscript_suite/labscript_utils/pull-requests/93/add-enumoutput-widget-type/diff). The enum controls have only been tested for basic functionality. That said, most of the functionality is lifted from the AO and DO devices so I suspect it will be fairly robust.\r\n\r\nKnown Issues remaining:\r\n\r\n* Currently, automatic layout is done either by hand or using `auto_place_widgets` method with a custom group name defined by the user. When mixing types of outputs, it isn't particularly pretty. A separate method for property widgets with more refined layout control is likely necessary. In particular, `auto_place_widgets` does not play nice with the camera tab layouts at the moment. \r\n* Default values are not respected. For the AO and DO properties this isn\u2019t a big issue. For the EO output this is a pretty big problem. Right now it selects the output based on alphabetical sorting \\(necessitated by laziness while also wanting to allow list, dict, and tuple inputs for the \u2018options\u2019\\) which often will place the device in an unusable state at initial startup. This is particularly true when many interacting settings are being controlled at once.\r\n* Remote value checking is still up in the air. I initially thought that the `check_remote_values` method of the worker should populate the properties values as well as the output values. In getting my camera up and running with some test widgets, I found this to be problematic since all properties are read at once, which causes needless slowdowns. I need to work out how to limit the properties read during `check_remote_values` to only those in the device\\_properties definition.\r\n\r\nI\u2019ve gotten a test case working for the Pylon camera which I\u2019ll put up as a third PR to labscript\\_devices. Usage is still pretty rough but I wanted to get feedback on the approach before sinking more time in. Beyond the above issues, I\u2019d like some input on:\r\n\r\n* How best to integrate all of this with the labscript device itself? Should device properties still be configured from device instantiation args or should we move to controlled properties being used more like standard Outputs? I lean towards the former.\r\n* Right now I am working towards having the controlled device properties be largely incorporated into the standard outputs workflow of the device with regards to smart programming and checking remote values, while having a separate programming workflow. Is that a good idea?\r\n* The meta-class is ultimately going to make this all easier. Is there any special conventions we\u2019d like to incorporate beyond moving already statically defined things to it?\r\n\r\n\u200c", "title": "Device properties", "destination": {"commit": {"hash": "1b4c69c290bd", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/blacs/commit/1b4c69c290bd.json"}, "html": {"href": "#!/labscript_suite/blacs/commits/1b4c69c290bd"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs.json"}, "html": {"href": "#!/labscript_suite/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}ts=249915"}}, "type": "repository", "name": "BLACS", "full_name": "labscript_suite/blacs", "uuid": "{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "c75191703cf8", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/blacs/commit/c75191703cf8"}, "html": {"href": "#!/dihm/blacs/commits/c75191703cf8"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/blacs"}, "html": {"href": "#!/dihm/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{5d6c277c-4faa-4fa2-af9f-e3e49c4673b3}ts=python"}}, "type": "repository", "name": "BLACS", "full_name": "dihm/blacs", "uuid": "{5d6c277c-4faa-4fa2-af9f-e3e49c4673b3}"}, "branch": {"name": "device_properties"}}, "state": "OPEN", "author": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "date": "2019-10-28T19:27:46.936700+00:00"}, "pull_request": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}}, {"update": {"description": "This PR addresses the more general discussion about how to incorporate manual control of device settings from BLACS is [labscript\\_utils issue 26](#!/labscript_suite/labscript_utils/issues/26/add-enum-control-widget). This PR aspires to add the framework for device\\_properties widgets in a device BLACS tab in much the same way AO, DO, DDS, and Image outputs are handled now.\r\n\r\nConfiguration is done using a new style of property dictionary that uses either an AO, DO, or new EO output for each property.\r\n\r\n> `device_properties = {'device_property':{'default':value, 'type':'num', 'min':0, 'max':1, 'base_unit':'V', 'step':0.1, 'decimals':1}, `\r\n>\r\n> `                     'device_property2'}:{'default':value, 'type':'bool'},`\r\n>\r\n> `                     'device_property3'}:{'default':'value','type':'enum','options':['option 1','option 2']}}`\r\n\r\nIt also establishes the `program_device_properties` state machine method which works in parallel to the `program_devices` method. In order to program these properties, the BLACS\\_worker must define a `program_properties` method in order to control any specified device properties. \r\n\r\nThis requires [PR #93 from labscript\\_utils](#!/labscript_suite/labscript_utils/pull-requests/93/add-enumoutput-widget-type/diff). The enum controls have only been tested for basic functionality. That said, most of the functionality is lifted from the AO and DO devices so I suspect it will be fairly robust.\r\n\r\nKnown Issues remaining:\r\n\r\n* Currently, automatic layout is done either by hand or using `auto_place_widgets` method with a custom group name defined by the user. When mixing types of outputs, it isn't particularly pretty. A separate method for property widgets with more refined layout control is likely necessary. In particular, `auto_place_widgets` does not play nice with the camera tab layouts at the moment. \r\n* Default values are not respected. For the AO and DO properties this isn\u2019t a big issue. For the EO output this is a pretty big problem. Right now it selects the output based on alphabetical sorting \\(necessitated by laziness while also wanting to allow list, dict, and tuple inputs for the \u2018options\u2019\\) which often will place the device in an unusable state at initial startup. This is particularly true when many interacting settings are being controlled at once.\r\n* Remote value checking is still up in the air. I initially thought that the `check_remote_values` method of the worker should populate the properties values as well as the output values. In getting my camera up and running with some test widgets, I found this to be problematic since all properties are read at once, which causes needless slowdowns. I need to work out how to limit the properties read during `check_remote_values` to only those in the device\\_properties definition.\r\n\r\nI\u2019ve gotten a test case working for the Pylon camera which I\u2019ll put up as a third PR to labscript\\_devices. Usage is still pretty rough but I wanted to get feedback on the approach before sinking more time in. Beyond the above issues, I\u2019d like some input on:\r\n\r\n* How best to integrate all of this with the labscript device itself? Should device properties still be configured from device instantiation args or should we move to controlled properties being used more like standard Outputs? I lean towards the former.\r\n* Right now I am working towards having the controlled device properties be largely incorporated into the standard outputs workflow of the device with regards to smart programming and checking remote values, while having a separate programming workflow. Is that a good idea?\r\n* The meta-class is ultimately going to make this all easier. Is there any special conventions we\u2019d like to incorporate beyond moving already statically defined things to it?\r\n\r\n\u200c", "title": "Device properties", "destination": {"commit": {"hash": "1b4c69c290bd", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/blacs/commit/1b4c69c290bd.json"}, "html": {"href": "#!/labscript_suite/blacs/commits/1b4c69c290bd"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs.json"}, "html": {"href": "#!/labscript_suite/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}ts=249915"}}, "type": "repository", "name": "BLACS", "full_name": "labscript_suite/blacs", "uuid": "{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "80366167a9af", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/blacs/commit/80366167a9af"}, "html": {"href": "#!/dihm/blacs/commits/80366167a9af"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/blacs"}, "html": {"href": "#!/dihm/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{5d6c277c-4faa-4fa2-af9f-e3e49c4673b3}ts=python"}}, "type": "repository", "name": "BLACS", "full_name": "dihm/blacs", "uuid": "{5d6c277c-4faa-4fa2-af9f-e3e49c4673b3}"}, "branch": {"name": "device_properties"}}, "state": "OPEN", "author": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "date": "2019-10-28T12:35:32.772513+00:00"}, "pull_request": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75/comments/122313844.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75/_/diff#comment-122313844"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}, "content": {"raw": "I\u2019ve done some reworking of the EO output class. It now uses a shared StandardItemModel for data storage more directly. \n\nI\u2019ve also allowed for the ability to define tooltips for enum options in the ComboBox pull-down menu, made the EO output respect the `\u2018default\u2019 ` definition, and made some other minor tweaks to the look of the EO class.\n\nAs for respecting `'default'` values in properties, I\u2019ve decided to just commit and modify the AO/DO/EO classes to accept a `default_value` kwarg. For AO/DO this kwarg is optional for backwards compatibility.\n\nStill to do:\n\n1. Final decision on programming workflow.\n2. Decide on and Implement meta\\_class\n\n\u200c", "markup": "markdown", "html": "<p>I\u2019ve done some reworking of the EO output class. It now uses a shared StandardItemModel for data storage more directly. </p>\n<p>I\u2019ve also allowed for the ability to define tooltips for enum options in the ComboBox pull-down menu, made the EO output respect the <code>\u2018default\u2019</code> definition, and made some other minor tweaks to the look of the EO class.</p>\n<p>As for respecting <code>'default'</code> values in properties, I\u2019ve decided to just commit and modify the AO/DO/EO classes to accept a <code>default_value</code> kwarg. For AO/DO this kwarg is optional for backwards compatibility.</p>\n<p>Still to do:</p>\n<ol>\n<li>Final decision on programming workflow.</li>\n<li>Decide on and Implement meta_class</li>\n</ol>\n<p>\u200c</p>", "type": "rendered"}, "created_on": "2019-10-25T19:59:22.390898+00:00", "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "updated_on": "2019-10-25T19:59:22.636602+00:00", "type": "pullrequest_comment", "id": 122313844}, "pull_request": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}}, {"update": {"description": "This PR addresses the more general discussion about how to incorporate manual control of device settings from BLACS is [labscript\\_utils issue 26](#!/labscript_suite/labscript_utils/issues/26/add-enum-control-widget). This PR aspires to add the framework for device\\_properties widgets in a device BLACS tab in much the same way AO, DO, DDS, and Image outputs are handled now.\r\n\r\nConfiguration is done using a new style of property dictionary that uses either an AO, DO, or new EO output for each property.\r\n\r\n> `device_properties = {'device_property':{'default':value, 'type':'num', 'min':0, 'max':1, 'base_unit':'V', 'step':0.1, 'decimals':1}, `\r\n>\r\n> `                     'device_property2'}:{'default':value, 'type':'bool'},`\r\n>\r\n> `                     'device_property3'}:{'default':'value','type':'enum','options':['option 1','option 2']}}`\r\n\r\nIt also establishes the `program_device_properties` state machine method which works in parallel to the `program_devices` method. In order to program these properties, the BLACS\\_worker must define a `program_properties` method in order to control any specified device properties. \r\n\r\nThis requires [PR #93 from labscript\\_utils](#!/labscript_suite/labscript_utils/pull-requests/93/add-enumoutput-widget-type/diff). The enum controls have only been tested for basic functionality. That said, most of the functionality is lifted from the AO and DO devices so I suspect it will be fairly robust.\r\n\r\nKnown Issues remaining:\r\n\r\n* Currently, automatic layout is done either by hand or using `auto_place_widgets` method with a custom group name defined by the user. When mixing types of outputs, it isn't particularly pretty. A separate method for property widgets with more refined layout control is likely necessary. In particular, `auto_place_widgets` does not play nice with the camera tab layouts at the moment. \r\n* Default values are not respected. For the AO and DO properties this isn\u2019t a big issue. For the EO output this is a pretty big problem. Right now it selects the output based on alphabetical sorting \\(necessitated by laziness while also wanting to allow list, dict, and tuple inputs for the \u2018options\u2019\\) which often will place the device in an unusable state at initial startup. This is particularly true when many interacting settings are being controlled at once.\r\n* Remote value checking is still up in the air. I initially thought that the `check_remote_values` method of the worker should populate the properties values as well as the output values. In getting my camera up and running with some test widgets, I found this to be problematic since all properties are read at once, which causes needless slowdowns. I need to work out how to limit the properties read during `check_remote_values` to only those in the device\\_properties definition.\r\n\r\nI\u2019ve gotten a test case working for the Pylon camera which I\u2019ll put up as a third PR to labscript\\_devices. Usage is still pretty rough but I wanted to get feedback on the approach before sinking more time in. Beyond the above issues, I\u2019d like some input on:\r\n\r\n* How best to integrate all of this with the labscript device itself? Should device properties still be configured from device instantiation args or should we move to controlled properties being used more like standard Outputs? I lean towards the former.\r\n* Right now I am working towards having the controlled device properties be largely incorporated into the standard outputs workflow of the device with regards to smart programming and checking remote values, while having a separate programming workflow. Is that a good idea?\r\n* The meta-class is ultimately going to make this all easier. Is there any special conventions we\u2019d like to incorporate beyond moving already statically defined things to it?\r\n\r\n\u200c", "title": "Device properties", "destination": {"commit": {"hash": "1b4c69c290bd", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/blacs/commit/1b4c69c290bd.json"}, "html": {"href": "#!/labscript_suite/blacs/commits/1b4c69c290bd"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs.json"}, "html": {"href": "#!/labscript_suite/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}ts=249915"}}, "type": "repository", "name": "BLACS", "full_name": "labscript_suite/blacs", "uuid": "{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "398ceadeb5fa", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/blacs/commit/398ceadeb5fa"}, "html": {"href": "#!/dihm/blacs/commits/398ceadeb5fa"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/blacs"}, "html": {"href": "#!/dihm/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{5d6c277c-4faa-4fa2-af9f-e3e49c4673b3}ts=python"}}, "type": "repository", "name": "BLACS", "full_name": "dihm/blacs", "uuid": "{5d6c277c-4faa-4fa2-af9f-e3e49c4673b3}"}, "branch": {"name": "device_properties"}}, "state": "OPEN", "author": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "date": "2019-10-25T19:55:05.784072+00:00"}, "pull_request": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}}, {"update": {"description": "This PR addresses the more general discussion about how to incorporate manual control of device settings from BLACS is [labscript\\_utils issue 26](#!/labscript_suite/labscript_utils/issues/26/add-enum-control-widget). This PR aspires to add the framework for device\\_properties widgets in a device BLACS tab in much the same way AO, DO, DDS, and Image outputs are handled now.\r\n\r\nConfiguration is done using a new style of property dictionary that uses either an AO, DO, or new EO output for each property.\r\n\r\n> `device_properties = {'device_property':{'default':value, 'type':'num', 'min':0, 'max':1, 'base_unit':'V', 'step':0.1, 'decimals':1}, `\r\n>\r\n> `                     'device_property2'}:{'default':value, 'type':'bool'},`\r\n>\r\n> `                     'device_property3'}:{'default':'value','type':'enum','options':['option 1','option 2']}}`\r\n\r\nIt also establishes the `program_device_properties` state machine method which works in parallel to the `program_devices` method. In order to program these properties, the BLACS\\_worker must define a `program_properties` method in order to control any specified device properties. \r\n\r\nThis requires [PR #93 from labscript\\_utils](#!/labscript_suite/labscript_utils/pull-requests/93/add-enumoutput-widget-type/diff). The enum controls have only been tested for basic functionality. That said, most of the functionality is lifted from the AO and DO devices so I suspect it will be fairly robust.\r\n\r\nKnown Issues remaining:\r\n\r\n* Currently, automatic layout is done either by hand or using `auto_place_widgets` method with a custom group name defined by the user. When mixing types of outputs, it isn't particularly pretty. A separate method for property widgets with more refined layout control is likely necessary. In particular, `auto_place_widgets` does not play nice with the camera tab layouts at the moment. \r\n* Default values are not respected. For the AO and DO properties this isn\u2019t a big issue. For the EO output this is a pretty big problem. Right now it selects the output based on alphabetical sorting \\(necessitated by laziness while also wanting to allow list, dict, and tuple inputs for the \u2018options\u2019\\) which often will place the device in an unusable state at initial startup. This is particularly true when many interacting settings are being controlled at once.\r\n* Remote value checking is still up in the air. I initially thought that the `check_remote_values` method of the worker should populate the properties values as well as the output values. In getting my camera up and running with some test widgets, I found this to be problematic since all properties are read at once, which causes needless slowdowns. I need to work out how to limit the properties read during `check_remote_values` to only those in the device\\_properties definition.\r\n\r\nI\u2019ve gotten a test case working for the Pylon camera which I\u2019ll put up as a third PR to labscript\\_devices. Usage is still pretty rough but I wanted to get feedback on the approach before sinking more time in. Beyond the above issues, I\u2019d like some input on:\r\n\r\n* How best to integrate all of this with the labscript device itself? Should device properties still be configured from device instantiation args or should we move to controlled properties being used more like standard Outputs? I lean towards the former.\r\n* Right now I am working towards having the controlled device properties be largely incorporated into the standard outputs workflow of the device with regards to smart programming and checking remote values, while having a separate programming workflow. Is that a good idea?\r\n* The meta-class is ultimately going to make this all easier. Is there any special conventions we\u2019d like to incorporate beyond moving already statically defined things to it?\r\n\r\n\u200c", "title": "Device properties", "destination": {"commit": {"hash": "1b4c69c290bd", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/blacs/commit/1b4c69c290bd.json"}, "html": {"href": "#!/labscript_suite/blacs/commits/1b4c69c290bd"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs.json"}, "html": {"href": "#!/labscript_suite/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}ts=249915"}}, "type": "repository", "name": "BLACS", "full_name": "labscript_suite/blacs", "uuid": "{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "860dfd39ef8f", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/blacs/commit/860dfd39ef8f"}, "html": {"href": "#!/dihm/blacs/commits/860dfd39ef8f"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/blacs"}, "html": {"href": "#!/dihm/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{5d6c277c-4faa-4fa2-af9f-e3e49c4673b3}ts=python"}}, "type": "repository", "name": "BLACS", "full_name": "dihm/blacs", "uuid": "{5d6c277c-4faa-4fa2-af9f-e3e49c4673b3}"}, "branch": {"name": "device_properties"}}, "state": "OPEN", "author": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "date": "2019-10-25T17:36:59.331440+00:00"}, "pull_request": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75/comments/121331676.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75/_/diff#comment-121331676"}}, "parent": {"id": 121146522, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75/comments/121146522.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75/_/diff#comment-121146522"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}, "content": {"raw": "1. Agree this is low priority. My working assumption at the moment is that these widgets will be best organized using custom implementations anyway much like the ddsoutput master widget already in labscript\\_utils, but rather stored with the device file.\n2. I agree the natural place is to augment all the output classes, but I\u2019m trying to be a minimally disruptive as possible to existing code. Circumventing through `_create_device_property_object` is a good idea. As for the complication, I\u2019ve already hit that line of code actually thanks to the EO output. The somewhat simple fix that I don\u2019t hate too much is to just save the enum index as the base\\_value. Assuming the enum labels are sorted and don\u2019t change in quantity this is stable. I\u2019ll need a little error checking on the default setting from saved front panel settings to actually make that stable. \n3. It all comes back to that meta class. I was really hoping to make these changes without requiring the meta class to be implemented as well. Of course, I could just move the static definitions for the general PylonCamera to a new class and solve this particular issue just as you say. I\u2019m also pondering how one could use meta classes to from the connection table to specify different device implementations for the same generalized parent device. My haziness on that point is largely why I avoiding it for the moment.\n4. Good. The latter seemed pretty complicated anyway.\n5. Certainly a unified workflow makes the programming easier, I\u2019m worried that unifying them means the timeouts and communication loads can\u2019t be distributed sensibly. Again, I\u2019m thinking ahead to other devices I have that will greatly benefit from manual property control that have a lot of potential properties. Having to read/write many 10s of values for the properties every time an output is changed seems wildly inefficient and possibly problem inducing. In fact, if it were easier I\u2019d be inclined to separate the remote values check as well. If I remember correctly, that runs afoul of front\\_panel\\_settings since it expect a complete dictionary, not a subset.\n6. Agreed that the internal structure should be as free as possible. I\u2019m just wondering how the meta classes can be used from the connection table in a sensible way. Short of doing things how they are done in NI\\_DAQmx \\(which doesn\u2019t quite work here since we don\u2019t want to bring in the whole labscript device everywhere\\), my best idea is a kwarg instantiation argument that points to the meta class. That feels a bit kludgy to me though.\n\n\u200c", "markup": "markdown", "html": "<ol>\n<li>Agree this is low priority. My working assumption at the moment is that these widgets will be best organized using custom implementations anyway much like the ddsoutput master widget already in labscript_utils, but rather stored with the device file.</li>\n<li>I agree the natural place is to augment all the output classes, but I\u2019m trying to be a minimally disruptive as possible to existing code. Circumventing through <code>_create_device_property_object</code> is a good idea. As for the complication, I\u2019ve already hit that line of code actually thanks to the EO output. The somewhat simple fix that I don\u2019t hate too much is to just save the enum index as the base_value. Assuming the enum labels are sorted and don\u2019t change in quantity this is stable. I\u2019ll need a little error checking on the default setting from saved front panel settings to actually make that stable. </li>\n<li>It all comes back to that meta class. I was really hoping to make these changes without requiring the meta class to be implemented as well. Of course, I could just move the static definitions for the general PylonCamera to a new class and solve this particular issue just as you say. I\u2019m also pondering how one could use meta classes to from the connection table to specify different device implementations for the same generalized parent device. My haziness on that point is largely why I avoiding it for the moment.</li>\n<li>Good. The latter seemed pretty complicated anyway.</li>\n<li>Certainly a unified workflow makes the programming easier, I\u2019m worried that unifying them means the timeouts and communication loads can\u2019t be distributed sensibly. Again, I\u2019m thinking ahead to other devices I have that will greatly benefit from manual property control that have a lot of potential properties. Having to read/write many 10s of values for the properties every time an output is changed seems wildly inefficient and possibly problem inducing. In fact, if it were easier I\u2019d be inclined to separate the remote values check as well. If I remember correctly, that runs afoul of front_panel_settings since it expect a complete dictionary, not a subset.</li>\n<li>Agreed that the internal structure should be as free as possible. I\u2019m just wondering how the meta classes can be used from the connection table in a sensible way. Short of doing things how they are done in NI_DAQmx (which doesn\u2019t quite work here since we don\u2019t want to bring in the whole labscript device everywhere), my best idea is a kwarg instantiation argument that points to the meta class. That feels a bit kludgy to me though.</li>\n</ol>\n<p>\u200c</p>", "type": "rendered"}, "created_on": "2019-10-18T13:41:17.124830+00:00", "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "updated_on": "2019-10-18T13:41:17.411753+00:00", "type": "pullrequest_comment", "id": 121331676}, "pull_request": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75/comments/121320508.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75/_/diff#comment-121320508"}}, "parent": {"id": 121146522, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75/comments/121146522.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75/_/diff#comment-121146522"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}, "content": {"raw": "You are right, I missed a commit. Both the EO automatic generation commit and the corresponding test case for the PylonCamera are now in the PRs. I also found an issue with using the mock camera from the PylonCamera wrapper that I\u2019ve fixed as well, so everything but the actual device programming can be tested by whomever. Thanks again @{557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3} for a nice, robust mock testing camera class.", "markup": "markdown", "html": "<p>You are right, I missed a commit. Both the EO automatic generation commit and the corresponding test case for the PylonCamera are now in the PRs. I also found an issue with using the mock camera from the PylonCamera wrapper that I\u2019ve fixed as well, so everything but the actual device programming can be tested by whomever. Thanks again <span class=\"ap-mention\" data-atlassian-id=\"557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3\">@Chris Billington</span> for a nice, robust mock testing camera class.</p>", "type": "rendered"}, "created_on": "2019-10-18T12:43:44.932100+00:00", "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "updated_on": "2019-10-18T12:43:45.122027+00:00", "type": "pullrequest_comment", "id": 121320508}, "pull_request": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}}, {"update": {"description": "This PR addresses the more general discussion about how to incorporate manual control of device settings from BLACS is [labscript\\_utils issue 26](#!/labscript_suite/labscript_utils/issues/26/add-enum-control-widget). This PR aspires to add the framework for device\\_properties widgets in a device BLACS tab in much the same way AO, DO, DDS, and Image outputs are handled now.\r\n\r\nConfiguration is done using a new style of property dictionary that uses either an AO, DO, or new EO output for each property.\r\n\r\n> `device_properties = {'device_property':{'default':value, 'type':'num', 'min':0, 'max':1, 'base_unit':'V', 'step':0.1, 'decimals':1}, `\r\n>\r\n> `                     'device_property2'}:{'default':value, 'type':'bool'},`\r\n>\r\n> `                     'device_property3'}:{'default':'value','type':'enum','options':['option 1','option 2']}}`\r\n\r\nIt also establishes the `program_device_properties` state machine method which works in parallel to the `program_devices` method. In order to program these properties, the BLACS\\_worker must define a `program_properties` method in order to control any specified device properties. \r\n\r\nThis requires [PR #93 from labscript\\_utils](#!/labscript_suite/labscript_utils/pull-requests/93/add-enumoutput-widget-type/diff). The enum controls have only been tested for basic functionality. That said, most of the functionality is lifted from the AO and DO devices so I suspect it will be fairly robust.\r\n\r\nKnown Issues remaining:\r\n\r\n* Currently, automatic layout is done either by hand or using `auto_place_widgets` method with a custom group name defined by the user. When mixing types of outputs, it isn't particularly pretty. A separate method for property widgets with more refined layout control is likely necessary. In particular, `auto_place_widgets` does not play nice with the camera tab layouts at the moment. \r\n* Default values are not respected. For the AO and DO properties this isn\u2019t a big issue. For the EO output this is a pretty big problem. Right now it selects the output based on alphabetical sorting \\(necessitated by laziness while also wanting to allow list, dict, and tuple inputs for the \u2018options\u2019\\) which often will place the device in an unusable state at initial startup. This is particularly true when many interacting settings are being controlled at once.\r\n* Remote value checking is still up in the air. I initially thought that the `check_remote_values` method of the worker should populate the properties values as well as the output values. In getting my camera up and running with some test widgets, I found this to be problematic since all properties are read at once, which causes needless slowdowns. I need to work out how to limit the properties read during `check_remote_values` to only those in the device\\_properties definition.\r\n\r\nI\u2019ve gotten a test case working for the Pylon camera which I\u2019ll put up as a third PR to labscript\\_devices. Usage is still pretty rough but I wanted to get feedback on the approach before sinking more time in. Beyond the above issues, I\u2019d like some input on:\r\n\r\n* How best to integrate all of this with the labscript device itself? Should device properties still be configured from device instantiation args or should we move to controlled properties being used more like standard Outputs? I lean towards the former.\r\n* Right now I am working towards having the controlled device properties be largely incorporated into the standard outputs workflow of the device with regards to smart programming and checking remote values, while having a separate programming workflow. Is that a good idea?\r\n* The meta-class is ultimately going to make this all easier. Is there any special conventions we\u2019d like to incorporate beyond moving already statically defined things to it?\r\n\r\n\u200c", "title": "Device properties", "destination": {"commit": {"hash": "1b4c69c290bd", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/blacs/commit/1b4c69c290bd.json"}, "html": {"href": "#!/labscript_suite/blacs/commits/1b4c69c290bd"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs.json"}, "html": {"href": "#!/labscript_suite/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}ts=249915"}}, "type": "repository", "name": "BLACS", "full_name": "labscript_suite/blacs", "uuid": "{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "31e89d623afe", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/blacs/commit/31e89d623afe"}, "html": {"href": "#!/dihm/blacs/commits/31e89d623afe"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/blacs"}, "html": {"href": "#!/dihm/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{5d6c277c-4faa-4fa2-af9f-e3e49c4673b3}ts=python"}}, "type": "repository", "name": "BLACS", "full_name": "dihm/blacs", "uuid": "{5d6c277c-4faa-4fa2-af9f-e3e49c4673b3}"}, "branch": {"name": "device_properties"}}, "state": "OPEN", "author": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "date": "2019-10-18T12:26:59.013699+00:00"}, "pull_request": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75/comments/121146522.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75/_/diff#comment-121146522"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}, "content": {"raw": "1. I think UI improvements can probably come later. Maybe a more serious evaluation of the output widget UIs would help us come up with a more effective general purpose method. I don\u2019t want to get too bogged down in it though as I suspect it will be easier once we have more concrete examples!\n2. I think you can solve the default value issue by updating the `_create_device_property_object` method to populate the `self.settings` dictionary appropriately for channels that do not exist in it already. I suppose ideally such code would live in the AO/DO/EO/DDS/Image classes and they would accept a \u201cdefault\u201d value kwarg, that way the feature could be extended to all of the output channels as well via the same mechanism you are using \\(`'default'` key in the `device_properties` dictionary\\). Note that this is going to be complicated by [this line of code](#!/labscript_suite/blacs/src/1b4c69c290bddf43a5573d9e6c0e27d6cc67875b/front_panel_settings.py#lines-356). front\\_panel\\_settings.py is a horrible, horrible mess, and likely the worse piece of code I\u2019ve ever written \\(some of that is to do with trying to massage all of the output value data into a HDF5 table\u2026which was probably a bad idea!\\)\n3. If the properties are defined in the device meta class, then it can be imported into the worker process. Ensuring you only query the relevant properties becomes a device implementation issue then right?\n4. Also lean towards the former\n5. I\u2019m uncertain. Maybe it makes sense to have only one programming method/workflow? I\u2019m not sure I see any downsides to having it all in one and it aligns better with the integration into existing remote\\_values\\_check/smart\\_programming.\n6. I don\u2019t think so at this stage. I do like having as much freedom as possible when writing device code as you are less likely to run into an arbitrary limitation enforced by the framework. I suspect some similarities will appear once we do this for a few devices and we can reassess then\n\nBTW, it doesn\u2019t look like the code below allows you to instantiate an EO object as an output or a property. Is there a commit missing?", "markup": "markdown", "html": "<ol>\n<li>I think UI improvements can probably come later. Maybe a more serious evaluation of the output widget UIs would help us come up with a more effective general purpose method. I don\u2019t want to get too bogged down in it though as I suspect it will be easier once we have more concrete examples!</li>\n<li>I think you can solve the default value issue by updating the <code>_create_device_property_object</code> method to populate the <code>self.settings</code> dictionary appropriately for channels that do not exist in it already. I suppose ideally such code would live in the AO/DO/EO/DDS/Image classes and they would accept a \u201cdefault\u201d value kwarg, that way the feature could be extended to all of the output channels as well via the same mechanism you are using (<code>'default'</code> key in the <code>device_properties</code> dictionary). Note that this is going to be complicated by <a data-is-external-link=\"true\" href=\"#!/labscript_suite/blacs/src/1b4c69c290bddf43a5573d9e6c0e27d6cc67875b/front_panel_settings.py#lines-356\" rel=\"nofollow\">this line of code</a>. front_panel_settings.py is a horrible, horrible mess, and likely the worse piece of code I\u2019ve ever written (some of that is to do with trying to massage all of the output value data into a HDF5 table\u2026which was probably a bad idea!)</li>\n<li>If the properties are defined in the device meta class, then it can be imported into the worker process. Ensuring you only query the relevant properties becomes a device implementation issue then right?</li>\n<li>Also lean towards the former</li>\n<li>I\u2019m uncertain. Maybe it makes sense to have only one programming method/workflow? I\u2019m not sure I see any downsides to having it all in one and it aligns better with the integration into existing remote_values_check/smart_programming.</li>\n<li>I don\u2019t think so at this stage. I do like having as much freedom as possible when writing device code as you are less likely to run into an arbitrary limitation enforced by the framework. I suspect some similarities will appear once we do this for a few devices and we can reassess then</li>\n</ol>\n<p>BTW, it doesn\u2019t look like the code below allows you to instantiate an EO object as an output or a property. Is there a commit missing?</p>", "type": "rendered"}, "created_on": "2019-10-17T13:01:21.463231+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{0147401a-13ed-4e39-a0d0-63108c18738b}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D"}, "html": {"href": "https://bitbucket.org/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/fa0698c306b3470c00717c146b5296e9d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "philipstarkey", "type": "user", "account_id": "557058:2f99420c-1dbd-4837-952c-82c421b8fbdd"}, "updated_on": "2019-10-17T13:01:21.471145+00:00", "type": "pullrequest_comment", "id": 121146522}, "pull_request": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}}, {"update": {"description": "This PR addresses the more general discussion about how to incorporate manual control of device settings from BLACS is [labscript\\_utils issue 26](#!/labscript_suite/labscript_utils/issues/26/add-enum-control-widget). This PR aspires to add the framework for device\\_properties widgets in a device BLACS tab in much the same way AO, DO, DDS, and Image outputs are handled now.\r\n\r\nConfiguration is done using a new style of property dictionary that uses either an AO, DO, or new EO output for each property.\r\n\r\n> `device_properties = {'device_property':{'default':value, 'type':'num', 'min':0, 'max':1, 'base_unit':'V', 'step':0.1, 'decimals':1}, `\r\n>\r\n> `                     'device_property2'}:{'default':value, 'type':'bool'},`\r\n>\r\n> `                     'device_property3'}:{'default':'value','type':'enum','options':['option 1','option 2']}}`\r\n\r\nIt also establishes the `program_device_properties` state machine method which works in parallel to the `program_devices` method. In order to program these properties, the BLACS\\_worker must define a `program_properties` method in order to control any specified device properties. \r\n\r\nThis requires [PR #93 from labscript\\_utils](#!/labscript_suite/labscript_utils/pull-requests/93/add-enumoutput-widget-type/diff). The enum controls have only been tested for basic functionality. That said, most of the functionality is lifted from the AO and DO devices so I suspect it will be fairly robust.\r\n\r\nKnown Issues remaining:\r\n\r\n* Currently, automatic layout is done either by hand or using `auto_place_widgets` method with a custom group name defined by the user. When mixing types of outputs, it isn't particularly pretty. A separate method for property widgets with more refined layout control is likely necessary. In particular, `auto_place_widgets` does not play nice with the camera tab layouts at the moment. \r\n* Default values are not respected. For the AO and DO properties this isn\u2019t a big issue. For the EO output this is a pretty big problem. Right now it selects the output based on alphabetical sorting \\(necessitated by laziness while also wanting to allow list, dict, and tuple inputs for the \u2018options\u2019\\) which often will place the device in an unusable state at initial startup. This is particularly true when many interacting settings are being controlled at once.\r\n* Remote value checking is still up in the air. I initially thought that the `check_remote_values` method of the worker should populate the properties values as well as the output values. In getting my camera up and running with some test widgets, I found this to be problematic since all properties are read at once, which causes needless slowdowns. I need to work out how to limit the properties read during `check_remote_values` to only those in the device\\_properties definition.\r\n\r\nI\u2019ve gotten a test case working for the Pylon camera which I\u2019ll put up as a third PR to labscript\\_devices. Usage is still pretty rough but I wanted to get feedback on the approach before sinking more time in. Beyond the above issues, I\u2019d like some input on:\r\n\r\n* How best to integrate all of this with the labscript device itself? Should device properties still be configured from device instantiation args or should we move to controlled properties being used more like standard Outputs? I lean towards the former.\r\n* Right now I am working towards having the controlled device properties be largely incorporated into the standard outputs workflow of the device with regards to smart programming and checking remote values, while having a separate programming workflow. Is that a good idea?\r\n* The meta-class is ultimately going to make this all easier. Is there any special conventions we\u2019d like to incorporate beyond moving already statically defined things to it?\r\n\r\n\u200c", "title": "Device properties", "destination": {"commit": {"hash": "1b4c69c290bd", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/blacs/commit/1b4c69c290bd.json"}, "html": {"href": "#!/labscript_suite/blacs/commits/1b4c69c290bd"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs.json"}, "html": {"href": "#!/labscript_suite/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}ts=249915"}}, "type": "repository", "name": "BLACS", "full_name": "labscript_suite/blacs", "uuid": "{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "ee3a1dfa9ffa", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/blacs/commit/ee3a1dfa9ffa"}, "html": {"href": "#!/dihm/blacs/commits/ee3a1dfa9ffa"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/blacs"}, "html": {"href": "#!/dihm/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{5d6c277c-4faa-4fa2-af9f-e3e49c4673b3}ts=python"}}, "type": "repository", "name": "BLACS", "full_name": "dihm/blacs", "uuid": "{5d6c277c-4faa-4fa2-af9f-e3e49c4673b3}"}, "branch": {"name": "device_properties"}}, "state": "OPEN", "author": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "date": "2019-10-09T00:02:03.648830+00:00"}, "pull_request": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}}, {"update": {"description": "This PR addresses the more general discussion about how to incorporate manual control of device settings from BLACS is [labscript\\_utils issue 26](#!/labscript_suite/labscript_utils/issues/26/add-enum-control-widget). This PR aspires to add the framework for device\\_properties widgets in a device BLACS tab in much the same way AO, DO, DDS, and Image outputs are handled now.\r\n\r\nConfiguration is done using a new style of property dictionary that uses either an AO, DO, or new EO output for each property.\r\n\r\n> `device_properties = {'device_property':{'default':value, 'type':'num', 'min':0, 'max':1, 'base_unit':'V', 'step':0.1, 'decimals':1}, `\r\n>\r\n> `                     'device_property2'}:{'default':value, 'type':'bool'},`\r\n>\r\n> `                     'device_property3'}:{'default':'value','type':'enum','options':['option 1','option 2']}}`\r\n\r\nIt also establishes the `program_device_properties` state machine method which works in parallel to the `program_devices` method. In order to program these properties, the BLACS\\_worker must define a `program_properties` method in order to control any specified device properties. \r\n\r\nThis requires [PR #93 from labscript\\_utils](#!/labscript_suite/labscript_utils/pull-requests/93/add-enumoutput-widget-type/diff). The enum controls have only been tested for basic functionality. That said, most of the functionality is lifted from the AO and DO devices so I suspect it will be fairly robust.\r\n\r\nKnown Issues remaining:\r\n\r\n* Currently, automatic layout is done either by hand or using `auto_place_widgets` method with a custom group name defined by the user. When mixing types of outputs, it isn't particularly pretty. A separate method for property widgets with more refined layout control is likely necessary. In particular, `auto_place_widgets` does not play nice with the camera tab layouts at the moment. \r\n* Default values are not respected. For the AO and DO properties this isn\u2019t a big issue. For the EO output this is a pretty big problem. Right now it selects the output based on alphabetical sorting \\(necessitated by laziness while also wanting to allow list, dict, and tuple inputs for the \u2018options\u2019\\) which often will place the device in an unusable state at initial startup. This is particularly true when many interacting settings are being controlled at once.\r\n* Remote value checking is still up in the air. I initially thought that the `check_remote_values` method of the worker should populate the properties values as well as the output values. In getting my camera up and running with some test widgets, I found this to be problematic since all properties are read at once, which causes needless slowdowns. I need to work out how to limit the properties read during `check_remote_values` to only those in the device\\_properties definition.\r\n\r\nI\u2019ve gotten a test case working for the Pylon camera which I\u2019ll put up as a third PR to labscript\\_devices. Usage is still pretty rough but I wanted to get feedback on the approach before sinking more time in. Beyond the above issues, I\u2019d like some input on:\r\n\r\n* How best to integrate all of this with the labscript device itself? Should device properties still be configured from device instantiation args or should we move to controlled properties being used more like standard Outputs? I lean towards the former.\r\n* Right now I am working towards having the controlled device properties be largely incorporated into the standard outputs workflow of the device with regards to smart programming and checking remote values, while having a separate programming workflow. Is that a good idea?\r\n* The meta-class is ultimately going to make this all easier. Is there any special conventions we\u2019d like to incorporate beyond moving already statically defined things to it?\r\n\r\n\u200c", "title": "Device properties", "destination": {"commit": {"hash": "1b4c69c290bd", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/blacs/commit/1b4c69c290bd.json"}, "html": {"href": "#!/labscript_suite/blacs/commits/1b4c69c290bd"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/blacs.json"}, "html": {"href": "#!/labscript_suite/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}ts=249915"}}, "type": "repository", "name": "BLACS", "full_name": "labscript_suite/blacs", "uuid": "{50ed1eb9-8c1b-4afe-a8b8-8e0a33b39a05}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "ee3a1dfa9ffa", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/blacs/commit/ee3a1dfa9ffa"}, "html": {"href": "#!/dihm/blacs/commits/ee3a1dfa9ffa"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/dihm/blacs"}, "html": {"href": "#!/dihm/blacs"}, "avatar": {"href": "data/bytebucket.org/ravatar/{5d6c277c-4faa-4fa2-af9f-e3e49c4673b3}ts=python"}}, "type": "repository", "name": "BLACS", "full_name": "dihm/blacs", "uuid": "{5d6c277c-4faa-4fa2-af9f-e3e49c4673b3}"}, "branch": {"name": "device_properties"}}, "state": "OPEN", "author": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "date": "2019-10-09T00:02:03.590055+00:00"}, "pull_request": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}}]}