{"links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75/comments/122502914.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75/_/diff#comment-122502914"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/75.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/75"}}, "title": "Device properties"}, "content": {"raw": "So we had a pressing need for this functionality in the lab so I went ahead and implemented a first pass on one of our devices, a SRS SG380 series function generator. In the process realized I hadn\u2019t exposed the index to the user in a satisfactory way. So I went ahead and added a required kwarg \\('return\\_type'\\) to the EO properties. This kwarg sets whether the \u2018index\u2019 or the \u2018value\u2019 is returned by the widget/output when requested. This is the current look of the functioning tab:\n\n![](data/bitbucket.org/repo/dR5qxr/images/1737565931-image.png)\nSince this is a more typical device, I\u2019ve started looking more closely at how to integrate remote value checks and smart programming. I\u2019m a little worried about the `check_remote_values` state machine method: it has a lot of hard-coding/assumptions built into it that would require a fair amount of rework to account for mixed-type outputs stored in a different output dictionary. Way I see it now I can either split the properties into a parallel `check_remote_properties` path or rework everything in `check_remote_values` to squash the input lists of `_last_remote_values` and `_last_programmed_values` to include device properties, global search `_DDS`, `_AO`, `_DO`, and `_devProp` dictionaries for the correct output, and then use inheritance checks to determine the correct formatting for the value change resolution. I\u2019m still leaning to having parallel programming/remote checking paths so I think I\u2019ll wait on some input from the group before moving on in the implementation.\n\n\u200c", "markup": "markdown", "html": "<p>So we had a pressing need for this functionality in the lab so I went ahead and implemented a first pass on one of our devices, a SRS SG380 series function generator. In the process realized I hadn\u2019t exposed the index to the user in a satisfactory way. So I went ahead and added a required kwarg ('return_type') to the EO properties. This kwarg sets whether the \u2018index\u2019 or the \u2018value\u2019 is returned by the widget/output when requested. This is the current look of the functioning tab:</p>\n<p><img alt=\"\" src=\"data/bitbucket.org/repo/dR5qxr/images/1737565931-image.png\" />\nSince this is a more typical device, I\u2019ve started looking more closely at how to integrate remote value checks and smart programming. I\u2019m a little worried about the <code>check_remote_values</code> state machine method: it has a lot of hard-coding/assumptions built into it that would require a fair amount of rework to account for mixed-type outputs stored in a different output dictionary. Way I see it now I can either split the properties into a parallel <code>check_remote_properties</code> path or rework everything in <code>check_remote_values</code> to squash the input lists of <code>_last_remote_values</code> and <code>_last_programmed_values</code> to include device properties, global search <code>_DDS</code>, <code>_AO</code>, <code>_DO</code>, and <code>_devProp</code> dictionaries for the correct output, and then use inheritance checks to determine the correct formatting for the value change resolution. I\u2019m still leaning to having parallel programming/remote checking paths so I think I\u2019ll wait on some input from the group before moving on in the implementation.</p>\n<p>\u200c</p>", "type": "rendered"}, "created_on": "2019-10-28T20:09:23.111864+00:00", "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "updated_on": "2019-10-28T20:09:23.368672+00:00", "type": "pullrequest_comment", "id": 122502914}