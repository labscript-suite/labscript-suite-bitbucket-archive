{"links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/9/comments/38955770.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/9/_/diff#comment-38955770"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 9, "links": {"self": {"href": "data/repositories/labscript_suite/blacs/pullrequests/9.json"}, "html": {"href": "#!/labscript_suite/blacs/pull-requests/9"}}, "title": "\"delete repeated shots\" functionality"}, "content": {"raw": "- So as of a [recent pull request](#!/labscript_suite/lyse/pull-requests/10/make-lyse-handle-gracefully-shot-files/) (explicitly motivated by the need for this feature), lyse handles it well. However, JQI's current implementation doesn't handle it so well, this pull request is a re-implementation rather than a straight copy of it - the problem with JQI's current implementation is that it overwrites old shot files - just loops around the rep numbers and overwrites the files. There's basically no way for lyse to deal with that without insidious race conditions, so whilst lyse here was modified so that at least it wouldn't crash by itself, it would still crash if you ran single-shot analysis on old shots. The recent pull request makes lyse deal well with deleted shots so long as they have unique filenames still, which whilst incompatible with JQI's current implementation of shot deletion, should work well with this pull request's way of doing it, since the shot filenames are unique. You should check out that pull request if you want to know more about what lyse does there, but basically it will handle things well. Even if user code crashes due to file deletion (which is improbable - but not impossible - because lyse checks before running each analysis routine if the shot exists), lyse can see afterward that the shot no longer exists and that clearly the error doesn't matter, so it moves on without pausing. Shot data remains in the dataframe so that multishot analysis can still be done with deleted files.\n\n- It does work in both repeat modes. No, it doesn't keep n copies of each individual file, it keeps n shot files in total, regardless of whether they are reps from the same shot or not.\n\n- The idea of keeping a few shots is to leave time to run and re-run some single-shot analysis before the shots go poof. I did make zero the lowest option originally, but then the shots were deleted immediately and BLACS was unable to use them to make the next rep file, so it seems 1 is a sensible minimum. Whilst there are a small number of broad categories of behaviour people are likely to use at any one time: (keep not many, keep an intermediate amount, keep a lot), making extra GUI controls for any of those categories, when they could also be entered via the spinbox, might be more GUI clutter than it's worth.", "markup": "markdown", "html": "<ul>\n<li>\n<p>So as of a <a data-is-external-link=\"true\" href=\"#!/labscript_suite/lyse/pull-requests/10/make-lyse-handle-gracefully-shot-files/\" rel=\"nofollow\">recent pull request</a> (explicitly motivated by the need for this feature), lyse handles it well. However, JQI's current implementation doesn't handle it so well, this pull request is a re-implementation rather than a straight copy of it - the problem with JQI's current implementation is that it overwrites old shot files - just loops around the rep numbers and overwrites the files. There's basically no way for lyse to deal with that without insidious race conditions, so whilst lyse here was modified so that at least it wouldn't crash by itself, it would still crash if you ran single-shot analysis on old shots. The recent pull request makes lyse deal well with deleted shots so long as they have unique filenames still, which whilst incompatible with JQI's current implementation of shot deletion, should work well with this pull request's way of doing it, since the shot filenames are unique. You should check out that pull request if you want to know more about what lyse does there, but basically it will handle things well. Even if user code crashes due to file deletion (which is improbable - but not impossible - because lyse checks before running each analysis routine if the shot exists), lyse can see afterward that the shot no longer exists and that clearly the error doesn't matter, so it moves on without pausing. Shot data remains in the dataframe so that multishot analysis can still be done with deleted files.</p>\n</li>\n<li>\n<p>It does work in both repeat modes. No, it doesn't keep n copies of each individual file, it keeps n shot files in total, regardless of whether they are reps from the same shot or not.</p>\n</li>\n<li>\n<p>The idea of keeping a few shots is to leave time to run and re-run some single-shot analysis before the shots go poof. I did make zero the lowest option originally, but then the shots were deleted immediately and BLACS was unable to use them to make the next rep file, so it seems 1 is a sensible minimum. Whilst there are a small number of broad categories of behaviour people are likely to use at any one time: (keep not many, keep an intermediate amount, keep a lot), making extra GUI controls for any of those categories, when they could also be entered via the spinbox, might be more GUI clutter than it's worth.</p>\n</li>\n</ul>", "type": "rendered"}, "created_on": "2017-06-16T05:03:25.030420+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-06-16T05:03:25.032956+00:00", "type": "pullrequest_comment", "id": 38955770}