{"priority": "minor", "kind": "bug", "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "links": {"attachments": {"href": "data/repositories/labscript_suite/labscript/issues/10/attachments_page=1.json"}, "self": {"href": "data/repositories/labscript_suite/labscript/issues/10.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript/issues/10/watch"}, "comments": {"href": "data/repositories/labscript_suite/labscript/issues/10/comments_page=1.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/10/unexpected-results-when-importing"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript/issues/10/vote"}}, "reporter": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "title": "Unexpected results when importing connection table", "component": null, "votes": 0, "watches": 1, "content": {"raw": "If a user offloads their connection table to a separate module and imports it from their main experiment script, it works fine, at first.\r\n\r\nThe second time they click 'engage' in runmanager, however, they will find that they have no devices defined.\r\n\r\nThis is because the module was imported, and their code is running in the same interpreter process as before, and so the import statement just returns a cached module. The module has not changed, so ModuleWatcher does not reload it. This would be fine if the connection table defined objects to be referred to, but it doesn't - those `Device.__init__` methods are special, and it is important that they actually run again each time.\r\n\r\nI'm not totally sure what to do about this. One solution is documentation: \r\n\r\n\"Dear user, these may look like object definitions, but they are actually procedural. You need this code to actually run, not just be imported, and the fact that code runs when imported is actually bad practise and shouldn't be relied upon. It only does so the first time, and your module can never know how many times it is going to be expected to run its code. Please wrap your connection table in a function called something like `define_connection_table()`, and call it, rather than relying on the fact that module-level code gets run on the first import\"\r\n\r\nThe other solutions are likely the darkest black magic, and would make Guido cry. I don't want to make Guido cry, and so would only really consider other solutions if they were sufficiently nonmagical.\r\n\r\nMuch easier to tolerate though, is the sort of magic required to detect when a Device class is being instantiated at the toplevel of anything but the main labscript file, and shoot the above warning at the user. In fact, not a warning, an exception probably.\r\n\r\nYes, I think that is the correct solution, but I need to think about how it might interact with another issue I'm about to create, in which I'll document our previous decision that stuff we're currently inserting into builtins should actually be placed in a dynamically generated module for user import. Because regardless of the resolution of *this* issue, the builtins hammering would certainly have the [BDFL](http://en.wikipedia.org/wiki/Guido_van_Rossum) in tears.", "markup": "markdown", "html": "<p>If a user offloads their connection table to a separate module and imports it from their main experiment script, it works fine, at first.</p>\n<p>The second time they click 'engage' in runmanager, however, they will find that they have no devices defined.</p>\n<p>This is because the module was imported, and their code is running in the same interpreter process as before, and so the import statement just returns a cached module. The module has not changed, so ModuleWatcher does not reload it. This would be fine if the connection table defined objects to be referred to, but it doesn't - those <code>Device.__init__</code> methods are special, and it is important that they actually run again each time.</p>\n<p>I'm not totally sure what to do about this. One solution is documentation: </p>\n<p>\"Dear user, these may look like object definitions, but they are actually procedural. You need this code to actually run, not just be imported, and the fact that code runs when imported is actually bad practise and shouldn't be relied upon. It only does so the first time, and your module can never know how many times it is going to be expected to run its code. Please wrap your connection table in a function called something like <code>define_connection_table()</code>, and call it, rather than relying on the fact that module-level code gets run on the first import\"</p>\n<p>The other solutions are likely the darkest black magic, and would make Guido cry. I don't want to make Guido cry, and so would only really consider other solutions if they were sufficiently nonmagical.</p>\n<p>Much easier to tolerate though, is the sort of magic required to detect when a Device class is being instantiated at the toplevel of anything but the main labscript file, and shoot the above warning at the user. In fact, not a warning, an exception probably.</p>\n<p>Yes, I think that is the correct solution, but I need to think about how it might interact with another issue I'm about to create, in which I'll document our previous decision that stuff we're currently inserting into builtins should actually be placed in a dynamically generated module for user import. Because regardless of the resolution of <em>this</em> issue, the builtins hammering would certainly have the <a data-is-external-link=\"true\" href=\"http://en.wikipedia.org/wiki/Guido_van_Rossum\" rel=\"nofollow\">BDFL</a> in tears.</p>", "type": "rendered"}, "assignee": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "state": "new", "version": null, "edited_on": null, "created_on": "2014-10-04T00:13:15.035862+00:00", "milestone": null, "updated_on": "2014-10-05T03:45:48.295197+00:00", "type": "issue", "id": 10}