{"priority": "major", "kind": "enhancement", "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "links": {"attachments": {"href": "data/repositories/labscript_suite/labscript/issues/11/attachments_page=1.json"}, "self": {"href": "data/repositories/labscript_suite/labscript/issues/11.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript/issues/11/watch"}, "comments": {"href": "data/repositories/labscript_suite/labscript/issues/11/comments_page=1.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/11/globals-and-devices-should-be-in-modules"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript/issues/11/vote"}}, "reporter": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "title": "Globals and devices should be in modules, not builtins: `shot_globals` and `shot_devices`", "component": null, "votes": 0, "watches": 2, "content": {"raw": "I used to not think it mattered much that we were modifying builtins to put our globals in them. Mainly because, although completely sacrilegious, we have a sort-of domain specific language here, damnit, we should be able to do what we like.\r\n\r\nBut more pragmatically I figured it wouldn't affect anything. Our code is the toplevel code, and nothing is relying on it conforming to good practices. Code we use will be unaffected because scoping rules.\r\n\r\n\r\nThis is not true. There is correct, unbuggy code out there that relies on getting NameErrors on things:\r\n\r\n```\r\n#!bash\r\n\r\nbilbo:~ $ grep -R 'except NameError' /usr/lib/python2.7/ | wc -l\r\n301\r\n```\r\noften for telling the difference between different versions of Python, but also for other totally innocent reasons.\r\n\r\nBut also I acknowledge that deviating from accepted practices confuses people, even when it doesn't to do any harm. This inhibits their ability to make good assumptions about how your software behaves.\r\n\r\nSo all the code that puts stuff into builtins should instead put them in two programmatically created modules, called `shot_globals` and `shot_devices`. These will be inserted into sys.modules so the user can import them from anywhere.\r\n\r\nThe user will probably want to import * from both (but they don't have to), and either way it makes it clearer in there code where stuff can be coming from, and no code that doesn't want to see our crap has to.\r\n\r\nThe only other question is: do we still make device instantiation put device objects into the global namespace they're being defined in? This is important because the user will often be immediately using the device they just defined as the parent of subsequently defined child devices.\r\n\r\nI think we should not do this. The user should define their connection table and *then* do from shot_devices import * (or whatever they want to import).\r\n\r\nTo handle the fact that devices are needed within the connection table, we should change it such that parent devices are specified with *strings* instead of python identidiers from the current namespace.\r\n\r\nAny other methods the user wants to call on devices halfway through the connection table should generally wait until the end, but if necessary, the user can import `shot_devices` as is, or import specific devices from it at any point. So long as they save their `import *` until the end. I can add an import hook that will take note of `import *` for the shot_devices module, such that `Device.__init__` can raise an exception if a new device is being added after an `import *` was done. Using the same introspection that I'll be using to give labscript users better errors about compilation, I'll even be able to store the traceback to the `import *` call. No more of this `error: something was imported once, I don't know when, but don't do that!' like h5_lock and lyse's figure manager do (both of which should be changed to turn on their functionality on a function call, rather than as an import side effect).\r\n\r\nDiscussion welcome.", "markup": "markdown", "html": "<p>I used to not think it mattered much that we were modifying builtins to put our globals in them. Mainly because, although completely sacrilegious, we have a sort-of domain specific language here, damnit, we should be able to do what we like.</p>\n<p>But more pragmatically I figured it wouldn't affect anything. Our code is the toplevel code, and nothing is relying on it conforming to good practices. Code we use will be unaffected because scoping rules.</p>\n<p>This is not true. There is correct, unbuggy code out there that relies on getting NameErrors on things:</p>\n<div class=\"codehilite language-bash\"><pre><span></span>bilbo:~ $ grep -R <span class=\"s1\">&#39;except NameError&#39;</span> /usr/lib/python2.7/ <span class=\"p\">|</span> wc -l\n<span class=\"m\">301</span>\n</pre></div>\n\n\n<p>often for telling the difference between different versions of Python, but also for other totally innocent reasons.</p>\n<p>But also I acknowledge that deviating from accepted practices confuses people, even when it doesn't to do any harm. This inhibits their ability to make good assumptions about how your software behaves.</p>\n<p>So all the code that puts stuff into builtins should instead put them in two programmatically created modules, called <code>shot_globals</code> and <code>shot_devices</code>. These will be inserted into sys.modules so the user can import them from anywhere.</p>\n<p>The user will probably want to import * from both (but they don't have to), and either way it makes it clearer in there code where stuff can be coming from, and no code that doesn't want to see our crap has to.</p>\n<p>The only other question is: do we still make device instantiation put device objects into the global namespace they're being defined in? This is important because the user will often be immediately using the device they just defined as the parent of subsequently defined child devices.</p>\n<p>I think we should not do this. The user should define their connection table and <em>then</em> do from shot_devices import * (or whatever they want to import).</p>\n<p>To handle the fact that devices are needed within the connection table, we should change it such that parent devices are specified with <em>strings</em> instead of python identidiers from the current namespace.</p>\n<p>Any other methods the user wants to call on devices halfway through the connection table should generally wait until the end, but if necessary, the user can import <code>shot_devices</code> as is, or import specific devices from it at any point. So long as they save their <code>import *</code> until the end. I can add an import hook that will take note of <code>import *</code> for the shot_devices module, such that <code>Device.__init__</code> can raise an exception if a new device is being added after an <code>import *</code> was done. Using the same introspection that I'll be using to give labscript users better errors about compilation, I'll even be able to store the traceback to the <code>import *</code> call. No more of this `error: something was imported once, I don't know when, but don't do that!' like h5_lock and lyse's figure manager do (both of which should be changed to turn on their functionality on a function call, rather than as an import side effect).</p>\n<p>Discussion welcome.</p>", "type": "rendered"}, "assignee": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "state": "new", "version": null, "edited_on": null, "created_on": "2014-10-04T00:47:19.242010+00:00", "milestone": null, "updated_on": "2014-10-04T03:52:38.827803+00:00", "type": "issue", "id": 11}