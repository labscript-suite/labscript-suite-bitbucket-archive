{"priority": "major", "kind": "proposal", "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "links": {"attachments": {"href": "data/repositories/labscript_suite/labscript/issues/18/attachments_page=1.json"}, "self": {"href": "data/repositories/labscript_suite/labscript/issues/18.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript/issues/18/watch"}, "comments": {"href": "data/repositories/labscript_suite/labscript/issues/18/comments_page=1.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/18/execution-of-small-or-time-critical"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript/issues/18/vote"}}, "reporter": {"display_name": "Ian B. Spielman", "uuid": "{bff0d3df-2ed5-4ff6-b13d-ce6cd935edb1}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D"}, "html": {"href": "https://bitbucket.org/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/54beee087619e1a612011791e203f277d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsIS-0.png"}}, "nickname": "Ian Spielman", "type": "user", "account_id": "557058:b0e98d01-12e7-4a9d-a274-a195def255d2"}, "title": "Execution of small or time-critical analysis scripts as part of running shot", "component": null, "votes": 0, "watches": 1, "content": {"raw": "Description:\r\n\r\nAdd a feature that allows the execution of small or time-critical scripts within the context of an individual labscript shot.  The intended application of this tool is for cases where in-shot or time-critical processing of data is required, for example when images or traces have been acquired that are used to feedback to the next shot to stabilize the magnetic field.\r\n\r\nProposed syntax:\r\n\r\n\r\n```\r\n#!python\r\n\r\n# Initialize a script executing \u201cdevice\u201d.\r\n# These can be launched locally or remotly (using the to be implemented methods to start\r\n# devices on remote computers.\r\n\r\nScripterLocal = ScriptManager(start_order=-1, stop_order=1)\r\nScripterRemote = ScriptManager(host=192.168.2.5, start_order=-1, stop_order=2)\r\n\r\nfrom Scripts import Script1, Script2, Script3\r\n\r\n# These will be executed after the shot completes in order on the local computer\r\nScripterLocal.AttachScript(Script1)\r\nScripterLocal.AttachScript(Script2)\r\n\r\n# this will be executed on a remote computer after the shot stops, on the remote computer\r\nScripterRemote(Script3)\r\n```\r\n\r\n\r\nComments:\r\n\r\nAs \u201cdevices\u201d these will have Blacs tabs each with suitable error reporting.  start_order and stop_order are two new kwargs to be present in the lowest level device class.  These dictate the order in which devices are sent to buffered mode (start_order) and then back to manuals (stop_order).  These default to 0 (so all 0's are started together, all 1's together and so forth).\r\n\r\nScript1,2,3 are callable python functions.  With the call syntax TBD, for example each should expect to be given a path to the current h5 file (or to the group were it should save any data), and current variables (?) and it should expect some action to be taken from its return values (such as having them sent to runmanager or something).\r\n\r\nPersistence can be achieved by assuming that the returns of the current cycle will be passed to the function next time.  OR each ScripterLocal can maintain a persistent local cache [I like this one]", "markup": "markdown", "html": "<p>Description:</p>\n<p>Add a feature that allows the execution of small or time-critical scripts within the context of an individual labscript shot.  The intended application of this tool is for cases where in-shot or time-critical processing of data is required, for example when images or traces have been acquired that are used to feedback to the next shot to stabilize the magnetic field.</p>\n<p>Proposed syntax:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"c1\"># Initialize a script executing \u201cdevice\u201d.</span>\n<span class=\"c1\"># These can be launched locally or remotly (using the to be implemented methods to start</span>\n<span class=\"c1\"># devices on remote computers.</span>\n\n<span class=\"n\">ScripterLocal</span> <span class=\"o\">=</span> <span class=\"n\">ScriptManager</span><span class=\"p\">(</span><span class=\"n\">start_order</span><span class=\"o\">=-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">stop_order</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">ScripterRemote</span> <span class=\"o\">=</span> <span class=\"n\">ScriptManager</span><span class=\"p\">(</span><span class=\"n\">host</span><span class=\"o\">=</span><span class=\"mf\">192.168</span><span class=\"o\">.</span><span class=\"mf\">2.5</span><span class=\"p\">,</span> <span class=\"n\">start_order</span><span class=\"o\">=-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">stop_order</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">Scripts</span> <span class=\"kn\">import</span> <span class=\"n\">Script1</span><span class=\"p\">,</span> <span class=\"n\">Script2</span><span class=\"p\">,</span> <span class=\"n\">Script3</span>\n\n<span class=\"c1\"># These will be executed after the shot completes in order on the local computer</span>\n<span class=\"n\">ScripterLocal</span><span class=\"o\">.</span><span class=\"n\">AttachScript</span><span class=\"p\">(</span><span class=\"n\">Script1</span><span class=\"p\">)</span>\n<span class=\"n\">ScripterLocal</span><span class=\"o\">.</span><span class=\"n\">AttachScript</span><span class=\"p\">(</span><span class=\"n\">Script2</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># this will be executed on a remote computer after the shot stops, on the remote computer</span>\n<span class=\"n\">ScripterRemote</span><span class=\"p\">(</span><span class=\"n\">Script3</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>Comments:</p>\n<p>As \u201cdevices\u201d these will have Blacs tabs each with suitable error reporting.  start_order and stop_order are two new kwargs to be present in the lowest level device class.  These dictate the order in which devices are sent to buffered mode (start_order) and then back to manuals (stop_order).  These default to 0 (so all 0's are started together, all 1's together and so forth).</p>\n<p>Script1,2,3 are callable python functions.  With the call syntax TBD, for example each should expect to be given a path to the current h5 file (or to the group were it should save any data), and current variables (?) and it should expect some action to be taken from its return values (such as having them sent to runmanager or something).</p>\n<p>Persistence can be achieved by assuming that the returns of the current cycle will be passed to the function next time.  OR each ScripterLocal can maintain a persistent local cache [I like this one]</p>", "type": "rendered"}, "assignee": null, "state": "new", "version": null, "edited_on": null, "created_on": "2017-04-20T16:25:24.636478+00:00", "milestone": null, "updated_on": "2018-08-08T19:48:08.834582+00:00", "type": "issue", "id": 18}