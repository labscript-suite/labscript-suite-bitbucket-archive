{"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18/comments/47067802.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/18#comment-47067802"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18.json"}}, "type": "issue", "id": 18, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "Execution of small or time-critical analysis scripts as part of running shot"}, "content": {"raw": "> For cases where we want to perform feedback, would the running script directly send the updated variables to runmanager using the new interface?\n\nYes, this is what I'm imagining at present. Though, the script runner class could easily provide syntactic sugar for this, such as interpreting the return values of the function as variables to be updated for the next shot as in your current implementation.  But extra layers of syntactic sugar are not preferable compared to making the underlying implementation easy to use in the first place, so I will try to make the the runmanager remote API as simple as possible, perhaps making wrappers around them more trouble than they're worth.\n\n> I think that functions are the at least \"a\" way to go, if not \"the\" way to go. What kind of call signature were you expecting for these functions? It could be as simple as,\n\nI'm inclined to agree. That function signature seems fine, and I think I'll go with it for the time being unless any issues reveal themselves.\n\n> If these functions return anything, what should that mean?\n\nAs a first implementation, maybe nothing. I can imagine making it so that they can return true or false as to whether they were successful or not, or things like that...but trying to anticipate something now seems premature. Would prefer to indicate failure via an exception, anyhow - and if an exception is to be ignored, the calling code can print the traceback, save a flag of some sort indicating failure, and keep running.\n\n>  If we want access to the current variables are they to be extracted from the h5 file, or provided as an additional argument to the function?\n\nPerhaps the h5 file provided should be not open already - that way you can instantiate a lyse.Run(h5_filename) object, or call lyse.data(h5_filename) on it, which would be how you could get shot globals and save analysis results. If this interface is unsatisfactory (Phil has recently been pointing out the obtuseness of some of the interface and proposed that the globals be an attribute of the Run() object instead of requiring a separate call to lyse.data(), that sort of thing), then I would prefer to fix it there rather than introduce another interface.\n\n> If we want persistence of information how should that be managed? It could be 100% in the runmanager variables that are sent to run-manager, or ...\n\nIf using the lyse API, there is a persistent storage mechanism, or you could save state to disk, or the script_runner worker process could provide a dictionary or something as a dumping ground for persistence. I would lean toward the latter, though unless the data is on disk, it wouldn't persist across \"device\" restarts. If the user wants to store data on disk, probably we should leave them on their own, there are plenty of ways to do this that would be complicated by an additional wrapper, and should be just used directly. But probably a dictionary per function/scriptlet/whatever you want to call it that will persist from one shot to the next would be good, and would probably sensibly be provided as a keyword argument to the user function.", "markup": "markdown", "html": "<blockquote>\n<p>For cases where we want to perform feedback, would the running script directly send the updated variables to runmanager using the new interface?</p>\n</blockquote>\n<p>Yes, this is what I'm imagining at present. Though, the script runner class could easily provide syntactic sugar for this, such as interpreting the return values of the function as variables to be updated for the next shot as in your current implementation.  But extra layers of syntactic sugar are not preferable compared to making the underlying implementation easy to use in the first place, so I will try to make the the runmanager remote API as simple as possible, perhaps making wrappers around them more trouble than they're worth.</p>\n<blockquote>\n<p>I think that functions are the at least \"a\" way to go, if not \"the\" way to go. What kind of call signature were you expecting for these functions? It could be as simple as,</p>\n</blockquote>\n<p>I'm inclined to agree. That function signature seems fine, and I think I'll go with it for the time being unless any issues reveal themselves.</p>\n<blockquote>\n<p>If these functions return anything, what should that mean?</p>\n</blockquote>\n<p>As a first implementation, maybe nothing. I can imagine making it so that they can return true or false as to whether they were successful or not, or things like that...but trying to anticipate something now seems premature. Would prefer to indicate failure via an exception, anyhow - and if an exception is to be ignored, the calling code can print the traceback, save a flag of some sort indicating failure, and keep running.</p>\n<blockquote>\n<p>If we want access to the current variables are they to be extracted from the h5 file, or provided as an additional argument to the function?</p>\n</blockquote>\n<p>Perhaps the h5 file provided should be not open already - that way you can instantiate a lyse.Run(h5_filename) object, or call lyse.data(h5_filename) on it, which would be how you could get shot globals and save analysis results. If this interface is unsatisfactory (Phil has recently been pointing out the obtuseness of some of the interface and proposed that the globals be an attribute of the Run() object instead of requiring a separate call to lyse.data(), that sort of thing), then I would prefer to fix it there rather than introduce another interface.</p>\n<blockquote>\n<p>If we want persistence of information how should that be managed? It could be 100% in the runmanager variables that are sent to run-manager, or ...</p>\n</blockquote>\n<p>If using the lyse API, there is a persistent storage mechanism, or you could save state to disk, or the script_runner worker process could provide a dictionary or something as a dumping ground for persistence. I would lean toward the latter, though unless the data is on disk, it wouldn't persist across \"device\" restarts. If the user wants to store data on disk, probably we should leave them on their own, there are plenty of ways to do this that would be complicated by an additional wrapper, and should be just used directly. But probably a dictionary per function/scriptlet/whatever you want to call it that will persist from one shot to the next would be good, and would probably sensibly be provided as a keyword argument to the user function.</p>", "type": "rendered"}, "created_on": "2018-08-01T18:05:14.720531+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": null, "type": "issue_comment", "id": 47067802}