{"pagelen": 100, "values": [{"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18/comments/36111415.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/18#comment-36111415"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18.json"}}, "type": "issue", "id": 18, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "Execution of small or time-critical analysis scripts as part of running shot"}, "content": {"raw": null, "markup": "markdown", "html": "", "type": "rendered"}, "created_on": "2017-04-20T23:49:17.378492+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}, "updated_on": null, "type": "issue_comment", "id": 36111415}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18/comments/36111594.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/18#comment-36111594"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18.json"}}, "type": "issue", "id": 18, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "Execution of small or time-critical analysis scripts as part of running shot"}, "content": {"raw": "Hi Ian, \n\nIn general I support this proposal. I think this sort of framework may come in handy once we rewrite BIAS in Python (which I hope will be able to be implemented as a remote BLACS tab)\n\nI do have a couple of questions about the details of the proposal:\n\n1. Would making a BLACS tab run a single-shot lyse script solve the same problem? I believe lyse scripts can be run without the lyse GUI, as long as the path to the h5 file is passed in. I guess the concern is if doing this would be slow? But if it's feasible, I think it would be better than having 2 distinct ways of making analysis scripts (and also means you automatically get access to the lyse API for accessing the h5 file, which I think is a big plus).\n\n2. Is there a reason for defining this in the labscript experiment logic file? I'm not necessarily opposed to it, but as a contrasting example, we don't define the lyse analysis scripts to run on a shot from within the labscript file (even though we could). Since it's a break from the current design philosophy (only things that effect the shot, should be defined in the experiment logic), I think it would be prudent to discuss this in detail. \n\nI think it would also be good for us to flesh out how we ensure h5 files remain a complete record of the experiment given that conceivably results of analysis will effect either the current shot or the next (or subsequent) shot(s). If the change is just through runmanager globals, I think everything will be fine, but if there are other mechanisms (which I think ChrisB was discussing with me once?) then we should decide on a standard way to record this so the shots are as reproducible as possible.", "markup": "markdown", "html": "<p>Hi Ian, </p>\n<p>In general I support this proposal. I think this sort of framework may come in handy once we rewrite BIAS in Python (which I hope will be able to be implemented as a remote BLACS tab)</p>\n<p>I do have a couple of questions about the details of the proposal:</p>\n<ol>\n<li>\n<p>Would making a BLACS tab run a single-shot lyse script solve the same problem? I believe lyse scripts can be run without the lyse GUI, as long as the path to the h5 file is passed in. I guess the concern is if doing this would be slow? But if it's feasible, I think it would be better than having 2 distinct ways of making analysis scripts (and also means you automatically get access to the lyse API for accessing the h5 file, which I think is a big plus).</p>\n</li>\n<li>\n<p>Is there a reason for defining this in the labscript experiment logic file? I'm not necessarily opposed to it, but as a contrasting example, we don't define the lyse analysis scripts to run on a shot from within the labscript file (even though we could). Since it's a break from the current design philosophy (only things that effect the shot, should be defined in the experiment logic), I think it would be prudent to discuss this in detail. </p>\n</li>\n</ol>\n<p>I think it would also be good for us to flesh out how we ensure h5 files remain a complete record of the experiment given that conceivably results of analysis will effect either the current shot or the next (or subsequent) shot(s). If the change is just through runmanager globals, I think everything will be fine, but if there are other mechanisms (which I think ChrisB was discussing with me once?) then we should decide on a standard way to record this so the shots are as reproducible as possible.</p>", "type": "rendered"}, "created_on": "2017-04-21T00:15:31.425480+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}, "updated_on": null, "type": "issue_comment", "id": 36111594}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18/comments/36111828.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/18#comment-36111828"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18.json"}}, "type": "issue", "id": 18, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "Execution of small or time-critical analysis scripts as part of running shot"}, "content": {"raw": "The design goal of this is to perform computations that are an essential part of the execution of the script, for example providing information that must be ready for the desired execution of the next script.  \n\nWe have a tool like this in place already and we use it to stabilize the magnet field, but ChrisB rightly objects that it is a bit of a hack.\n\n2. Yes.  These scripts are intended to be used when they are an essential part of the experiment logic, and therefor should be included in the script defining the execution of the experiment.  They should not be used for \"analysis;\" in fact my attitude (that ChrisB does not subscribe to)  is that \"everything\" about the execution of your sequence should work 100% without lyse running at all.  to me, it is an analysis and rendering tool, not part of the closed loop operation of the sequencer.  \n\n1. I don't care strongly.  My opinion is that the desired functionality should not require the programmer know anything about lyse, but rather assume that they just know numpy scipy and enough about h5py to get the desired data out of the h5 file.  The minimal functionality should be provided by the python return statement, and our vision is to somehow get this information back to runmanager globals [I do very much think that these functions should have their results dumped into the h5 file because they are being treated as a device, and this would allow lyse to plot the results later on to track performance or whatever.].  ChrisB and I are still in discussions about how this looks in practice.  All of this is not to say that the lyse machinery could not be leveraged, but I do not think it should be required.\n\nWe already have a number of camera devices implemented in 100% python (they are indeed just devices that are given a tab of some sort in Blacs), and part of pushing the JQI changes back to the main branch will get these there for everybody.  You will shortly see a feature request appearing regarding giving Blacs the ability to launch worker processes on remote computers, which is required for this camera functionality.", "markup": "markdown", "html": "<p>The design goal of this is to perform computations that are an essential part of the execution of the script, for example providing information that must be ready for the desired execution of the next script.  </p>\n<p>We have a tool like this in place already and we use it to stabilize the magnet field, but ChrisB rightly objects that it is a bit of a hack.</p>\n<ol>\n<li>\n<p>Yes.  These scripts are intended to be used when they are an essential part of the experiment logic, and therefor should be included in the script defining the execution of the experiment.  They should not be used for \"analysis;\" in fact my attitude (that ChrisB does not subscribe to)  is that \"everything\" about the execution of your sequence should work 100% without lyse running at all.  to me, it is an analysis and rendering tool, not part of the closed loop operation of the sequencer.  </p>\n</li>\n<li>\n<p>I don't care strongly.  My opinion is that the desired functionality should not require the programmer know anything about lyse, but rather assume that they just know numpy scipy and enough about h5py to get the desired data out of the h5 file.  The minimal functionality should be provided by the python return statement, and our vision is to somehow get this information back to runmanager globals [I do very much think that these functions should have their results dumped into the h5 file because they are being treated as a device, and this would allow lyse to plot the results later on to track performance or whatever.].  ChrisB and I are still in discussions about how this looks in practice.  All of this is not to say that the lyse machinery could not be leveraged, but I do not think it should be required.</p>\n</li>\n</ol>\n<p>We already have a number of camera devices implemented in 100% python (they are indeed just devices that are given a tab of some sort in Blacs), and part of pushing the JQI changes back to the main branch will get these there for everybody.  You will shortly see a feature request appearing regarding giving Blacs the ability to launch worker processes on remote computers, which is required for this camera functionality.</p>", "type": "rendered"}, "created_on": "2017-04-21T00:40:26.051479+00:00", "user": {"display_name": "Ian B. Spielman", "uuid": "{bff0d3df-2ed5-4ff6-b13d-ce6cd935edb1}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D"}, "html": {"href": "https://bitbucket.org/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/54beee087619e1a612011791e203f277d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsIS-0.png"}}, "nickname": "Ian Spielman", "type": "user", "account_id": "557058:b0e98d01-12e7-4a9d-a274-a195def255d2"}, "updated_on": null, "type": "issue_comment", "id": 36111828}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18/comments/37563647.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/18#comment-37563647"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18.json"}}, "type": "issue", "id": 18, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "Execution of small or time-critical analysis scripts as part of running shot"}, "content": {"raw": null, "markup": "markdown", "html": "", "type": "rendered"}, "created_on": "2017-06-13T18:11:04.536751+00:00", "user": {"display_name": "Ian B. Spielman", "uuid": "{bff0d3df-2ed5-4ff6-b13d-ce6cd935edb1}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D"}, "html": {"href": "https://bitbucket.org/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/54beee087619e1a612011791e203f277d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsIS-0.png"}}, "nickname": "Ian Spielman", "type": "user", "account_id": "557058:b0e98d01-12e7-4a9d-a274-a195def255d2"}, "updated_on": null, "type": "issue_comment", "id": 37563647}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18/comments/38576536.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/18#comment-38576536"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18.json"}}, "type": "issue", "id": 18, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "Execution of small or time-critical analysis scripts as part of running shot"}, "content": {"raw": "Pull request #12 has been backed out due to regressions, so we'll think of a different way to do that! \n\nBasically the transision order needs to be defined only for Devices that are actually are programmed by BLACS, which in labscript are identified by having a BLACS_connection attribute. But inspecting that attribute isn't very compatible with using set_passed_properties. I think in labscript 3, BLACS programmable devices will be identified possibly by inheriting from a [mixin](https://en.wikipedia.org/wiki/Mixin) that adds the desired properties, but I'm happy for something hackier in the meantime.\n\nOne quick fix could be to make the transition order a connection table property instead of a device property - this would make BLACS not see a device group for the device and so would ignore it. It is still kinda silly though for devices that are not being transitioned to buffered mode to even have the attribute though. And that way it wouldn't be able to vary on a per-shot basis.", "markup": "markdown", "html": "<p><a href=\"#!/labscript_suite/labscript/pull-requests/12/provides-start_order-and-stop_order-as-per\" rel=\"nofollow\" class=\"ap-connect-link\">Pull request #12</a> has been backed out due to regressions, so we'll think of a different way to do that! </p>\n<p>Basically the transision order needs to be defined only for Devices that are actually are programmed by BLACS, which in labscript are identified by having a BLACS_connection attribute. But inspecting that attribute isn't very compatible with using set_passed_properties. I think in labscript 3, BLACS programmable devices will be identified possibly by inheriting from a <a data-is-external-link=\"true\" href=\"https://en.wikipedia.org/wiki/Mixin\" rel=\"nofollow\">mixin</a> that adds the desired properties, but I'm happy for something hackier in the meantime.</p>\n<p>One quick fix could be to make the transition order a connection table property instead of a device property - this would make BLACS not see a device group for the device and so would ignore it. It is still kinda silly though for devices that are not being transitioned to buffered mode to even have the attribute though. And that way it wouldn't be able to vary on a per-shot basis.</p>", "type": "rendered"}, "created_on": "2017-07-26T20:01:19.918340+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": null, "type": "issue_comment", "id": 38576536}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18/comments/47066303.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/18#comment-47066303"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18.json"}}, "type": "issue", "id": 18, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "Execution of small or time-critical analysis scripts as part of running shot"}, "content": {"raw": "Here's a checklist of what needs to be done to get this working:\n\n### labscript: ###\n* ~~The ability to specify an order in which devices transition to static and to buffered mode~~. Addressed in [labscript pull request 37](#!/labscript_suite/labscript/pull-requests/37/start_order-and-stop_order/)\n\n### zprocess: ###\n* ~~Allow an event to connect to a remote broker by specifying a host and port numbers~~. Implemented in [zprocess 2.6](https://bitbucket.org/cbillington/zprocess/commits/835c5017d7ce12341bb2713e8190ba51a3fa886a)\n\n### BLACS: ###\n* Server should have a method to give BLACS version number (so that future dependencies on communication with the server can be tracked), and another to give broker\n  ports to allow subscribers to subscribe to its events.\n* Emit a zprocess event (which is a wrapper around a zmq.PUB message) whenever the queue decreases in size saying how many shots are left in the queue (including zero)\n* Implement ordered transition to static and transition to buffered based on settings\n  saved by labscript as above. Backward compatible if the settings don't exist.\n\n### runmanager: ###\n* A \"remote API\", `runmanager.remote` for interacting with a running instance of runmanager and setting globals, getting globals, clicking 'engage', and more to be added later.\n\n* A tab showing the compilation queue, including variables that differ between different shots in the queue. Support re-ordering and deletion, and make it a TreeView grouping by sequence. Show compilation progress bars.\n\n* A checkbox for \"just-in-time\" compilation vs ahead of time compilation. The 'set\n  global' remote command can have a 'where' argument that says whether to set it\n  in the globals interface, or the queued shots, or both.\n\n* A setting for when the shots should be compiled in \"just-in-time\" mode - when BLACS has an empty queue, or when it has one remaining shot, or ten? This is optional - as a first implementation this should be just \"compile them when BLACS has an empty queue\"\n\n* depend on the version of zprocess allowing connection to remote broker, and listen for events telling you when to submit a shot.\n\n* There needs to be an option to keep the apparatus warm if the compilation queue runs dry. This could probably be implemented at first as 'repeat all/repeat last' options to the compilation queue, identical to those in the BLACS queue, which is the mechanism currently used to keep experiments warm in ahead-of-time-compiled shots. In the longer run, a notion of a \"default shot\", could be useful, in which runmanager has a 'current value' and a 'default value' for globals. the 'default value' could be used to submit 'keep warm' shots. A diff between default globals and current globals would also be super useful for quickly inspecting what has changed about the globals. But this is a separate feature.\n\n### labscript_devices: ###\n* A \"script_runner\" device that either stores functions or whole scripts to execute\n  at the end of a shot, specified at compile time. Leaning toward letting these\n  be functions rather than actually being runnable lyse routines - I think they are distinct, though there's\n  no reason why the lyse API can't be used to save results. The script runner may need\n  to interact with the lyse API to specify the name of the group to which any results\n  are saved, since it cannot be introspected as it usually is in a lyse routine.", "markup": "markdown", "html": "<p>Here's a checklist of what needs to be done to get this working:</p>\n<h3 id=\"markdown-header-labscript\">labscript:</h3>\n<ul>\n<li><del>The ability to specify an order in which devices transition to static and to buffered mode</del>. Addressed in <a data-is-external-link=\"true\" href=\"#!/labscript_suite/labscript/pull-requests/37/start_order-and-stop_order/\" rel=\"nofollow\">labscript pull request 37</a></li>\n</ul>\n<h3 id=\"markdown-header-zprocess\">zprocess:</h3>\n<ul>\n<li><del>Allow an event to connect to a remote broker by specifying a host and port numbers</del>. Implemented in <a data-is-external-link=\"true\" href=\"https://bitbucket.org/cbillington/zprocess/commits/835c5017d7ce12341bb2713e8190ba51a3fa886a\" rel=\"nofollow\">zprocess 2.6</a></li>\n</ul>\n<h3 id=\"markdown-header-blacs\">BLACS:</h3>\n<ul>\n<li>Server should have a method to give BLACS version number (so that future dependencies on communication with the server can be tracked), and another to give broker\n  ports to allow subscribers to subscribe to its events.</li>\n<li>Emit a zprocess event (which is a wrapper around a zmq.PUB message) whenever the queue decreases in size saying how many shots are left in the queue (including zero)</li>\n<li>Implement ordered transition to static and transition to buffered based on settings\n  saved by labscript as above. Backward compatible if the settings don't exist.</li>\n</ul>\n<h3 id=\"markdown-header-runmanager\">runmanager:</h3>\n<ul>\n<li>\n<p>A \"remote API\", <code>runmanager.remote</code> for interacting with a running instance of runmanager and setting globals, getting globals, clicking 'engage', and more to be added later.</p>\n</li>\n<li>\n<p>A tab showing the compilation queue, including variables that differ between different shots in the queue. Support re-ordering and deletion, and make it a TreeView grouping by sequence. Show compilation progress bars.</p>\n</li>\n<li>\n<p>A checkbox for \"just-in-time\" compilation vs ahead of time compilation. The 'set\n  global' remote command can have a 'where' argument that says whether to set it\n  in the globals interface, or the queued shots, or both.</p>\n</li>\n<li>\n<p>A setting for when the shots should be compiled in \"just-in-time\" mode - when BLACS has an empty queue, or when it has one remaining shot, or ten? This is optional - as a first implementation this should be just \"compile them when BLACS has an empty queue\"</p>\n</li>\n<li>\n<p>depend on the version of zprocess allowing connection to remote broker, and listen for events telling you when to submit a shot.</p>\n</li>\n<li>\n<p>There needs to be an option to keep the apparatus warm if the compilation queue runs dry. This could probably be implemented at first as 'repeat all/repeat last' options to the compilation queue, identical to those in the BLACS queue, which is the mechanism currently used to keep experiments warm in ahead-of-time-compiled shots. In the longer run, a notion of a \"default shot\", could be useful, in which runmanager has a 'current value' and a 'default value' for globals. the 'default value' could be used to submit 'keep warm' shots. A diff between default globals and current globals would also be super useful for quickly inspecting what has changed about the globals. But this is a separate feature.</p>\n</li>\n</ul>\n<h3 id=\"markdown-header-labscript_devices\">labscript_devices:</h3>\n<ul>\n<li>A \"script_runner\" device that either stores functions or whole scripts to execute\n  at the end of a shot, specified at compile time. Leaning toward letting these\n  be functions rather than actually being runnable lyse routines - I think they are distinct, though there's\n  no reason why the lyse API can't be used to save results. The script runner may need\n  to interact with the lyse API to specify the name of the group to which any results\n  are saved, since it cannot be introspected as it usually is in a lyse routine.</li>\n</ul>", "type": "rendered"}, "created_on": "2018-08-01T16:03:50.166893+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-08-01T20:30:55.832683+00:00", "type": "issue_comment", "id": 47066303}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18/comments/47066563.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/18#comment-47066563"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18.json"}}, "type": "issue", "id": 18, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "Execution of small or time-critical analysis scripts as part of running shot"}, "content": {"raw": "For cases where we want to perform feedback, would the running script directly send the updated variables to runmanager using the new interface?\n\nI think that functions are the at least \"a\" way to go, if not \"the\" way to go.  What kind of call signature were you expecting for these functions?  It could be as simple as,\n\n    def mini_function(h5file):\n        \"\"\"\n        h5file is an open reference to the current shot file in its current state.  \n        It has already been locked by h5lock and will be closed when the script\n        is done\n        \"\"\"\n\n        # do stuff\n\n        pass\n\nIf these functions return anything, what should that mean?  If we want access to the current variables are they to be extracted from the h5 file, or provided as an additional argument to the function?\n\nIf we want persistence of information how should that be managed?  It could be 100% in the runmanager variables that are sent to run-manager, or ...", "markup": "markdown", "html": "<p>For cases where we want to perform feedback, would the running script directly send the updated variables to runmanager using the new interface?</p>\n<p>I think that functions are the at least \"a\" way to go, if not \"the\" way to go.  What kind of call signature were you expecting for these functions?  It could be as simple as,</p>\n<div class=\"codehilite\"><pre><span></span>def mini_function(h5file):\n    &quot;&quot;&quot;\n    h5file is an open reference to the current shot file in its current state.  \n    It has already been locked by h5lock and will be closed when the script\n    is done\n    &quot;&quot;&quot;\n\n    # do stuff\n\n    pass\n</pre></div>\n\n\n<p>If these functions return anything, what should that mean?  If we want access to the current variables are they to be extracted from the h5 file, or provided as an additional argument to the function?</p>\n<p>If we want persistence of information how should that be managed?  It could be 100% in the runmanager variables that are sent to run-manager, or ...</p>", "type": "rendered"}, "created_on": "2018-08-01T16:24:33.708207+00:00", "user": {"display_name": "Ian B. Spielman", "uuid": "{bff0d3df-2ed5-4ff6-b13d-ce6cd935edb1}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D"}, "html": {"href": "https://bitbucket.org/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/54beee087619e1a612011791e203f277d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsIS-0.png"}}, "nickname": "Ian Spielman", "type": "user", "account_id": "557058:b0e98d01-12e7-4a9d-a274-a195def255d2"}, "updated_on": null, "type": "issue_comment", "id": 47066563}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18/comments/47067802.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/18#comment-47067802"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18.json"}}, "type": "issue", "id": 18, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "Execution of small or time-critical analysis scripts as part of running shot"}, "content": {"raw": "> For cases where we want to perform feedback, would the running script directly send the updated variables to runmanager using the new interface?\n\nYes, this is what I'm imagining at present. Though, the script runner class could easily provide syntactic sugar for this, such as interpreting the return values of the function as variables to be updated for the next shot as in your current implementation.  But extra layers of syntactic sugar are not preferable compared to making the underlying implementation easy to use in the first place, so I will try to make the the runmanager remote API as simple as possible, perhaps making wrappers around them more trouble than they're worth.\n\n> I think that functions are the at least \"a\" way to go, if not \"the\" way to go. What kind of call signature were you expecting for these functions? It could be as simple as,\n\nI'm inclined to agree. That function signature seems fine, and I think I'll go with it for the time being unless any issues reveal themselves.\n\n> If these functions return anything, what should that mean?\n\nAs a first implementation, maybe nothing. I can imagine making it so that they can return true or false as to whether they were successful or not, or things like that...but trying to anticipate something now seems premature. Would prefer to indicate failure via an exception, anyhow - and if an exception is to be ignored, the calling code can print the traceback, save a flag of some sort indicating failure, and keep running.\n\n>  If we want access to the current variables are they to be extracted from the h5 file, or provided as an additional argument to the function?\n\nPerhaps the h5 file provided should be not open already - that way you can instantiate a lyse.Run(h5_filename) object, or call lyse.data(h5_filename) on it, which would be how you could get shot globals and save analysis results. If this interface is unsatisfactory (Phil has recently been pointing out the obtuseness of some of the interface and proposed that the globals be an attribute of the Run() object instead of requiring a separate call to lyse.data(), that sort of thing), then I would prefer to fix it there rather than introduce another interface.\n\n> If we want persistence of information how should that be managed? It could be 100% in the runmanager variables that are sent to run-manager, or ...\n\nIf using the lyse API, there is a persistent storage mechanism, or you could save state to disk, or the script_runner worker process could provide a dictionary or something as a dumping ground for persistence. I would lean toward the latter, though unless the data is on disk, it wouldn't persist across \"device\" restarts. If the user wants to store data on disk, probably we should leave them on their own, there are plenty of ways to do this that would be complicated by an additional wrapper, and should be just used directly. But probably a dictionary per function/scriptlet/whatever you want to call it that will persist from one shot to the next would be good, and would probably sensibly be provided as a keyword argument to the user function.", "markup": "markdown", "html": "<blockquote>\n<p>For cases where we want to perform feedback, would the running script directly send the updated variables to runmanager using the new interface?</p>\n</blockquote>\n<p>Yes, this is what I'm imagining at present. Though, the script runner class could easily provide syntactic sugar for this, such as interpreting the return values of the function as variables to be updated for the next shot as in your current implementation.  But extra layers of syntactic sugar are not preferable compared to making the underlying implementation easy to use in the first place, so I will try to make the the runmanager remote API as simple as possible, perhaps making wrappers around them more trouble than they're worth.</p>\n<blockquote>\n<p>I think that functions are the at least \"a\" way to go, if not \"the\" way to go. What kind of call signature were you expecting for these functions? It could be as simple as,</p>\n</blockquote>\n<p>I'm inclined to agree. That function signature seems fine, and I think I'll go with it for the time being unless any issues reveal themselves.</p>\n<blockquote>\n<p>If these functions return anything, what should that mean?</p>\n</blockquote>\n<p>As a first implementation, maybe nothing. I can imagine making it so that they can return true or false as to whether they were successful or not, or things like that...but trying to anticipate something now seems premature. Would prefer to indicate failure via an exception, anyhow - and if an exception is to be ignored, the calling code can print the traceback, save a flag of some sort indicating failure, and keep running.</p>\n<blockquote>\n<p>If we want access to the current variables are they to be extracted from the h5 file, or provided as an additional argument to the function?</p>\n</blockquote>\n<p>Perhaps the h5 file provided should be not open already - that way you can instantiate a lyse.Run(h5_filename) object, or call lyse.data(h5_filename) on it, which would be how you could get shot globals and save analysis results. If this interface is unsatisfactory (Phil has recently been pointing out the obtuseness of some of the interface and proposed that the globals be an attribute of the Run() object instead of requiring a separate call to lyse.data(), that sort of thing), then I would prefer to fix it there rather than introduce another interface.</p>\n<blockquote>\n<p>If we want persistence of information how should that be managed? It could be 100% in the runmanager variables that are sent to run-manager, or ...</p>\n</blockquote>\n<p>If using the lyse API, there is a persistent storage mechanism, or you could save state to disk, or the script_runner worker process could provide a dictionary or something as a dumping ground for persistence. I would lean toward the latter, though unless the data is on disk, it wouldn't persist across \"device\" restarts. If the user wants to store data on disk, probably we should leave them on their own, there are plenty of ways to do this that would be complicated by an additional wrapper, and should be just used directly. But probably a dictionary per function/scriptlet/whatever you want to call it that will persist from one shot to the next would be good, and would probably sensibly be provided as a keyword argument to the user function.</p>", "type": "rendered"}, "created_on": "2018-08-01T18:05:14.720531+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": null, "type": "issue_comment", "id": 47067802}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18/comments/47068112.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/18#comment-47068112"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18.json"}}, "type": "issue", "id": 18, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "Execution of small or time-critical analysis scripts as part of running shot"}, "content": {"raw": "Great, but lets follow up on\n\n\"\"\"\nPerhaps the h5 file provided should be not open already - that way you can instantiate a lyse.Run(h5_filename) object, or call lyse.data(h5_filename) on it, which would be how you could get shot globals and save analysis results. If this interface is unsatisfactory (Phil has recently been pointing out the obtuseness of some of the interface and proposed that the globals be an attribute of the Run() object instead of requiring a separate call to lyse.data(), that sort of thing), then I would prefer to fix it there rather than introduce another interface.\n\"\"\"\n\nI would suggest two things: \n\n1. Lyse should be able to deal with open references to the h5file, which is an easy check anyway\n2. I am totally happy with the option to allow people to use the lyse infrastructure, but I think that labscript might benefit for a more streamlined interface to pick out globals that does not involve instantiating a large object.  Such as:\n```\n#!python\n\none_global = ShotGlobals(h5file, global_name) # for a global\nglobals = ShotGlobals(h5file, [global1, global2, ...]) # for some globals\nglobals = ShotGlobals(h5file) # for all globals\n\n```\nthe idea is that these would just be fast function calls that get data from an h5 file or a reference\n\nOne more thought comes to mind that one would want to define somehow: in labscript, devices generally store data to places in the h5 file related to the name of the device.  Since the same script might be run by several different \"devices\" (why, I don't know, but it could).  As a result, the device should be involved in informing the script where its data \"should\" go.  It could be as simple as having a call signature that provides two references, one read-only reference (is this even possible?) to the whole h5 file (so you can access the images you want to analyze, for example) and a second to r/w reference to the data storage location.", "markup": "markdown", "html": "<p>Great, but lets follow up on</p>\n<p>\"\"\"\nPerhaps the h5 file provided should be not open already - that way you can instantiate a lyse.Run(h5_filename) object, or call lyse.data(h5_filename) on it, which would be how you could get shot globals and save analysis results. If this interface is unsatisfactory (Phil has recently been pointing out the obtuseness of some of the interface and proposed that the globals be an attribute of the Run() object instead of requiring a separate call to lyse.data(), that sort of thing), then I would prefer to fix it there rather than introduce another interface.\n\"\"\"</p>\n<p>I would suggest two things: </p>\n<ol>\n<li>Lyse should be able to deal with open references to the h5file, which is an easy check anyway</li>\n<li>I am totally happy with the option to allow people to use the lyse infrastructure, but I think that labscript might benefit for a more streamlined interface to pick out globals that does not involve instantiating a large object.  Such as:</li>\n</ol>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"n\">one_global</span> <span class=\"o\">=</span> <span class=\"n\">ShotGlobals</span><span class=\"p\">(</span><span class=\"n\">h5file</span><span class=\"p\">,</span> <span class=\"n\">global_name</span><span class=\"p\">)</span> <span class=\"c1\"># for a global</span>\n<span class=\"nb\">globals</span> <span class=\"o\">=</span> <span class=\"n\">ShotGlobals</span><span class=\"p\">(</span><span class=\"n\">h5file</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">global1</span><span class=\"p\">,</span> <span class=\"n\">global2</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">])</span> <span class=\"c1\"># for some globals</span>\n<span class=\"nb\">globals</span> <span class=\"o\">=</span> <span class=\"n\">ShotGlobals</span><span class=\"p\">(</span><span class=\"n\">h5file</span><span class=\"p\">)</span> <span class=\"c1\"># for all globals</span>\n</pre></div>\n\n\n<p>the idea is that these would just be fast function calls that get data from an h5 file or a reference</p>\n<p>One more thought comes to mind that one would want to define somehow: in labscript, devices generally store data to places in the h5 file related to the name of the device.  Since the same script might be run by several different \"devices\" (why, I don't know, but it could).  As a result, the device should be involved in informing the script where its data \"should\" go.  It could be as simple as having a call signature that provides two references, one read-only reference (is this even possible?) to the whole h5 file (so you can access the images you want to analyze, for example) and a second to r/w reference to the data storage location.</p>", "type": "rendered"}, "created_on": "2018-08-01T18:30:17.751535+00:00", "user": {"display_name": "Ian B. Spielman", "uuid": "{bff0d3df-2ed5-4ff6-b13d-ce6cd935edb1}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D"}, "html": {"href": "https://bitbucket.org/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/54beee087619e1a612011791e203f277d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsIS-0.png"}}, "nickname": "Ian Spielman", "type": "user", "account_id": "557058:b0e98d01-12e7-4a9d-a274-a195def255d2"}, "updated_on": null, "type": "issue_comment", "id": 47068112}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18/comments/47179724.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/18#comment-47179724"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18.json"}}, "type": "issue", "id": 18, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "Execution of small or time-critical analysis scripts as part of running shot"}, "content": {"raw": "I have been thinking about persistent variables that you want to retain from shot to shot, and I have a different suggestion than the above.  I suggest a mechanism whereby there is a provided function such as:\n\n    SetPersistentVariable(name, value)\n\nwhere these persistent variables are in reality stored in the next h5 file in the device group for this specific device and the function\n\n    var = GetPersistantVariable(h5file, name)\n\nwill get that specific persistent variable from the current h5 file.   I guess this could equally well be done using the future ability to updated globals to runmanager, in which case the GetPersistantVariable function is not needed.\n\nThis suggests a useful syntax would be:\n\n    SetRunMangerVariable(name, value)\n\n\nMy reasoning for this suggestion is that it is preferable that this state information be retained in the history of shot files.", "markup": "markdown", "html": "<p>I have been thinking about persistent variables that you want to retain from shot to shot, and I have a different suggestion than the above.  I suggest a mechanism whereby there is a provided function such as:</p>\n<div class=\"codehilite\"><pre><span></span>SetPersistentVariable(name, value)\n</pre></div>\n\n\n<p>where these persistent variables are in reality stored in the next h5 file in the device group for this specific device and the function</p>\n<div class=\"codehilite\"><pre><span></span>var = GetPersistantVariable(h5file, name)\n</pre></div>\n\n\n<p>will get that specific persistent variable from the current h5 file.   I guess this could equally well be done using the future ability to updated globals to runmanager, in which case the GetPersistantVariable function is not needed.</p>\n<p>This suggests a useful syntax would be:</p>\n<div class=\"codehilite\"><pre><span></span>SetRunMangerVariable(name, value)\n</pre></div>\n\n\n<p>My reasoning for this suggestion is that it is preferable that this state information be retained in the history of shot files.</p>", "type": "rendered"}, "created_on": "2018-08-08T19:03:18.814723+00:00", "user": {"display_name": "Ian B. Spielman", "uuid": "{bff0d3df-2ed5-4ff6-b13d-ce6cd935edb1}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D"}, "html": {"href": "https://bitbucket.org/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/54beee087619e1a612011791e203f277d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsIS-0.png"}}, "nickname": "Ian Spielman", "type": "user", "account_id": "557058:b0e98d01-12e7-4a9d-a274-a195def255d2"}, "updated_on": "2018-08-08T19:07:50.167790+00:00", "type": "issue_comment", "id": 47179724}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18/comments/47180183.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/18#comment-47180183"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/18.json"}}, "type": "issue", "id": 18, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "Execution of small or time-critical analysis scripts as part of running shot"}, "content": {"raw": "I think that would be a bit tricky! Ensuring the data gets to the next HDF5 file would require it be stored somewhere in the meantime, since the next HDF5 file may not exist yet. And if the next shot file does exist because shots have been pre-compiled, then the notion of 'next' is a bit fuzzy since shots can be re-ordered before execution. For just-in-time-compiled shots, if the data is stored in runmanager ready to be added to the next shot file, then runmanager will need to store it to disk, since runmanager can be restarted and the data would be lost.\n\nWe could do that, but it's many hoops to jump though considering that there are a number of ways to do disk persistence in Python, from manually using `h5py` to using the `shelve` standard library module, or np.save, or pickle (`shelve` is probably the best for this kind of purpose), I suspect users using these things directly for disk persistence is the best solution (and when we get around to documenting this functionality, pointing users in that direction would be good). For non-disk-persistent  data, some object that attributes can just be saved to as in lyse would be adequate. We could instantiate a `shelf` for the user so they don't have to choose a filename, but other than that there isn't much functionality I think we could add that isn't best served by the user using the standard library themselves.", "markup": "markdown", "html": "<p>I think that would be a bit tricky! Ensuring the data gets to the next HDF5 file would require it be stored somewhere in the meantime, since the next HDF5 file may not exist yet. And if the next shot file does exist because shots have been pre-compiled, then the notion of 'next' is a bit fuzzy since shots can be re-ordered before execution. For just-in-time-compiled shots, if the data is stored in runmanager ready to be added to the next shot file, then runmanager will need to store it to disk, since runmanager can be restarted and the data would be lost.</p>\n<p>We could do that, but it's many hoops to jump though considering that there are a number of ways to do disk persistence in Python, from manually using <code>h5py</code> to using the <code>shelve</code> standard library module, or np.save, or pickle (<code>shelve</code> is probably the best for this kind of purpose), I suspect users using these things directly for disk persistence is the best solution (and when we get around to documenting this functionality, pointing users in that direction would be good). For non-disk-persistent  data, some object that attributes can just be saved to as in lyse would be adequate. We could instantiate a <code>shelf</code> for the user so they don't have to choose a filename, but other than that there isn't much functionality I think we could add that isn't best served by the user using the standard library themselves.</p>", "type": "rendered"}, "created_on": "2018-08-08T19:48:08.821780+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": null, "type": "issue_comment", "id": 47180183}], "page": 1, "size": 11}