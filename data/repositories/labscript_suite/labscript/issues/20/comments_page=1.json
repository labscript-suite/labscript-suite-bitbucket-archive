{"pagelen": 100, "values": [{"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/20/comments/36112776.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/20#comment-36112776"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/20.json"}}, "type": "issue", "id": 20, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "#20: Ability to run directly from the console with ease."}, "content": {"raw": "Brain dump of my thoughts on this (at least the ones I can remember...now seems a good idea to write them down!)\n\n* For BLACS we'll need a new event framework (like twisted? or similar?) I think, as we use the Qt GUI event loop as a way to ensure thread safety (by posting events back to the main thread). \n* Do we allow only one or multiple clients to connect to the server? If multiple, how do we handle conflicts in GUI state.\n* The classes (in blacs/output_classes.py) that handle the backend of widgets are tightly coupled to their widgets\n* How do we handle the concept of \"plugins\" (currently undocumented but this is how the connection table recompilation is implemented) given that these are very GUI based, but will need to exist in both the client GUI and the server", "markup": "markdown", "html": "<p>Brain dump of my thoughts on this (at least the ones I can remember...now seems a good idea to write them down!)</p>\n<ul>\n<li>For BLACS we'll need a new event framework (like twisted? or similar?) I think, as we use the Qt GUI event loop as a way to ensure thread safety (by posting events back to the main thread). </li>\n<li>Do we allow only one or multiple clients to connect to the server? If multiple, how do we handle conflicts in GUI state.</li>\n<li>The classes (in blacs/output_classes.py) that handle the backend of widgets are tightly coupled to their widgets</li>\n<li>How do we handle the concept of \"plugins\" (currently undocumented but this is how the connection table recompilation is implemented) given that these are very GUI based, but will need to exist in both the client GUI and the server</li>\n</ul>", "type": "rendered"}, "created_on": "2017-04-21T02:24:16.722137+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}, "updated_on": null, "type": "issue_comment", "id": 36112776}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/20/comments/36113321.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/20#comment-36113321"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/20.json"}}, "type": "issue", "id": 20, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "#20: Ability to run directly from the console with ease."}, "content": {"raw": "A first approach to this might be just to make lots of things scriptable without thinking too hard about getting rid of GUIs or managing multiple clients.\n\nFor example, runmanager is probably going to grow a 'remote' API for setting variables and submitting shots and whatever. Pretty much every API call would correspond to something the user *could* do in the GUI, but the function would be being called programatically instead of by button-click. If BLACS grew a similar API whereby you could call functions to pause the queue, set an output to a value, inspect whether any tabs have errors, and that sort of thing, and the other programs grew these things too, it would make the suite scriptable even though the GUIs were still there. You could write a script that would program something into the front panel of BLACS, add analysis routines to lyse and then tell runmanager to start submitting shots.\n\nA sledgehammer way of \"managing\" the possibility of multiple clients is to allow a client to just take a lock on the \"write\" parts of the remote APIs - like setting a runmanager variable or setting a BLACS front panel value, and other clients would just have to wait or time out, and the GUI would grey out or something so the user couldn't click buttons and interfere. \"get\" methods like \"what is the value of this global\" or \"what is the current front panel value set to\" ought to still work, no reason they should be locked out. Your script would just acquire a lock for the entire set of operations it was doing, not just on a per-API-call basis.\n\nMaking the GUIs be 'just another client' is nice but quite ambitious I think, and allowing the GUI to continue to exist even if nobody is looking at, whist being remotely controllable would be most of the way there.\n\nQt can be headless, though. I think you just have to use a QCoreApplication instead of a QApplication.", "markup": "markdown", "html": "<p>A first approach to this might be just to make lots of things scriptable without thinking too hard about getting rid of GUIs or managing multiple clients.</p>\n<p>For example, runmanager is probably going to grow a 'remote' API for setting variables and submitting shots and whatever. Pretty much every API call would correspond to something the user <em>could</em> do in the GUI, but the function would be being called programatically instead of by button-click. If BLACS grew a similar API whereby you could call functions to pause the queue, set an output to a value, inspect whether any tabs have errors, and that sort of thing, and the other programs grew these things too, it would make the suite scriptable even though the GUIs were still there. You could write a script that would program something into the front panel of BLACS, add analysis routines to lyse and then tell runmanager to start submitting shots.</p>\n<p>A sledgehammer way of \"managing\" the possibility of multiple clients is to allow a client to just take a lock on the \"write\" parts of the remote APIs - like setting a runmanager variable or setting a BLACS front panel value, and other clients would just have to wait or time out, and the GUI would grey out or something so the user couldn't click buttons and interfere. \"get\" methods like \"what is the value of this global\" or \"what is the current front panel value set to\" ought to still work, no reason they should be locked out. Your script would just acquire a lock for the entire set of operations it was doing, not just on a per-API-call basis.</p>\n<p>Making the GUIs be 'just another client' is nice but quite ambitious I think, and allowing the GUI to continue to exist even if nobody is looking at, whist being remotely controllable would be most of the way there.</p>\n<p>Qt can be headless, though. I think you just have to use a QCoreApplication instead of a QApplication.</p>", "type": "rendered"}, "created_on": "2017-04-21T03:22:10.948817+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-04-21T03:22:24.583711+00:00", "type": "issue_comment", "id": 36113321}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/20/comments/36113672.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/20#comment-36113672"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/20.json"}}, "type": "issue", "id": 20, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "#20: Ability to run directly from the console with ease."}, "content": {"raw": "Qt can be headless, yes, but I think there may be issues compiling Qt on some headless systems if they, for instance, don't have X11 or something like that. Seems like an odd choice to keep Qt on Python just for the event managing bits, but I guess we'll see how it evolves.", "markup": "markdown", "html": "<p>Qt can be headless, yes, but I think there may be issues compiling Qt on some headless systems if they, for instance, don't have X11 or something like that. Seems like an odd choice to keep Qt on Python just for the event managing bits, but I guess we'll see how it evolves.</p>", "type": "rendered"}, "created_on": "2017-04-21T03:54:46.351877+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}, "updated_on": null, "type": "issue_comment", "id": 36113672}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/20/comments/36113711.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/20#comment-36113711"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/20.json"}}, "type": "issue", "id": 20, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "#20: Ability to run directly from the console with ease."}, "content": {"raw": "Oh, I was just mentioning it, I am not attached to Qt for a headless program - I would keep it if it made porting easier by a big enough margin, but otherwise not. Our event loop needs, once there's no GUI are very modest, so I think many things would suffice. Python 3 even comes with its own event loop in the standard library nowadays I believe, it's possible that would do, but I'm not very familiar with it.", "markup": "markdown", "html": "<p>Oh, I was just mentioning it, I am not attached to Qt for a headless program - I would keep it if it made porting easier by a big enough margin, but otherwise not. Our event loop needs, once there's no GUI are very modest, so I think many things would suffice. Python 3 even comes with its own event loop in the standard library nowadays I believe, it's possible that would do, but I'm not very familiar with it.</p>", "type": "rendered"}, "created_on": "2017-04-21T03:58:55.594966+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": null, "type": "issue_comment", "id": 36113711}], "page": 1, "size": 4}