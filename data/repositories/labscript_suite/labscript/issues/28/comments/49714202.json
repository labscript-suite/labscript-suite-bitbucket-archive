{"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/28/comments/49714202.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/28#comment-49714202"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/28.json"}}, "type": "issue", "id": 28, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "Remote launching of all Blacs devices"}, "content": {"raw": "Hello,\n\nNot sure if I'm reinventing the wheel, but here's how I implemented remote device worker launch / control:\n\nIn `zprocess` there's already `RemoteProcessClient` and `RemoteProcessServer` classes half-implemented. What seems to be missing is that in the function `Process.subprocess()`, if there's a remote process client specified, some sort of proxy tunnel between the client and the server should be established and the parent / heartbeat / broker host and port info being passed to the worker should be replaced by the proxy port established by the remote process server. I took liberty to implement the proxy server / client as a pair of zeromq dealer-router. I also have the proxy server and client listen for heartbeats from the workers so unused proxy tunnels will be closed if the worker terminated. See [zprocess:proxy-support](https://bitbucket.org/fanyangphy/zprocess/branch/proxy-support). The Server can be started by executing `python __main__.py <tui>` under `zprocess/remote/`, where the option `tui` will give you a curses-based ui for monitoring connected remote process clients, associated processes and proxy tunnels.\n\nWhile the remote process server is running on the remote computer where devices are physically present, I made the following changes in `BLACS/__main__.py` and `labscript.py`:\n\n1. In `Device.__init__()`, a kwarg `remote_device` is expected to be a dictionary containing host and port info of the `RemoteProcessServer` and saved to the connection table.\n2. Then `Tab.__init__()` will take this information to instantiate `RemoteProcessClient`.\n3. `DeviceTab.create_worker()` instantiates the worker class with the remote process client passed, which basically calls Process.subprocess() to start the connection with the remote process server.\n\n[blacs:remote-process](#!/fanyangphy/blacs/branch/remote-process)\n\n[labscript:remote-process](#!/fanyangphy/labscript/branch/remote-process)\n\nTo set up a remote device, supply kwarg of the form `remote_device={'host': <host>, 'port': <port>, 'proxy_port': <port>}` to the device entry in `connectiontable.py`, start the remote process server on the remote computer, open the ports (7340 and 7440 are the defaults) in the firewall, and it should be ready to go.\n\nThe rationale behind having a zeromq proxy server is that it simplifies the network setup: only two ports need to be configured in the firewall of the remote process server: the \"control port\" which is the good old ZMQServer port, and the \"proxy port\" that is the port of the zeromq router-dealer pair. It seems tricky to get the ip address of the client connecting to a zeromq socket as they don't expose that information in the API, and even if we could it won't be of much use if the client lives behind NAT. So a zeromq proxy seems like the best bet.\n\nOne problem that I have't fixed is that the worker would need to have read (and write, if it's an acquisition device) access to the h5 file during transition to buffer and transition to manual. My idea would be to replace the filename with a [python file-like object](http://docs.h5py.org/en/stable/high/file.html#python-file-like-objects). This file-like object can be a custom class made to access the file through the zeromq proxy tunnel. \n\nBasically the client end would look like:\n\n```\n#!python\nclass RemoteBytesIO(object):\n    def __init__(self, socket):\n        self.socket = socket\n\n    def __getattr__(self, name):\n        if name not in ['read', 'write', 'seek', 'tell', 'truncate', 'flush']:\n            raise AttributeError\n        def func(*args, **kwargs):\n            if name == 'write':\n                args = (bytearray(args[0]),)\n            self.socket.send_pyobj([name, args, kwargs])\n            if self.socket.poll(timeout=1000) == 0:\n                raise TimeoutError\n            retval = self.socket.recv_pyobj()\n            return retval\n```\nand the server end would look like:\n```\n#!python\nwith io.open(fname, 'r+b') as f:\n\n    while True:\n        try:\n            cmd, args, kwargs = socket.recv_pyobj()\n            print(cmd, args, kwargs)\n            result = getattr(f, cmd)(*args, **kwargs)\n            print(result)\n            socket.send_pyobj(result)\n        except KeyboardInterrupt:\n            break\n\n```\nThis approach does not require copying the whole file back and forth, which can be a problem if there are more than a couple remote devices.\n\nThe code has been tested but may need to be cleaned up a bit.", "markup": "markdown", "html": "<p>Hello,</p>\n<p>Not sure if I'm reinventing the wheel, but here's how I implemented remote device worker launch / control:</p>\n<p>In <code>zprocess</code> there's already <code>RemoteProcessClient</code> and <code>RemoteProcessServer</code> classes half-implemented. What seems to be missing is that in the function <code>Process.subprocess()</code>, if there's a remote process client specified, some sort of proxy tunnel between the client and the server should be established and the parent / heartbeat / broker host and port info being passed to the worker should be replaced by the proxy port established by the remote process server. I took liberty to implement the proxy server / client as a pair of zeromq dealer-router. I also have the proxy server and client listen for heartbeats from the workers so unused proxy tunnels will be closed if the worker terminated. See <a data-is-external-link=\"true\" href=\"https://bitbucket.org/fanyangphy/zprocess/branch/proxy-support\" rel=\"nofollow\">zprocess:proxy-support</a>. The Server can be started by executing <code>python __main__.py &lt;tui&gt;</code> under <code>zprocess/remote/</code>, where the option <code>tui</code> will give you a curses-based ui for monitoring connected remote process clients, associated processes and proxy tunnels.</p>\n<p>While the remote process server is running on the remote computer where devices are physically present, I made the following changes in <code>BLACS/__main__.py</code> and <code>labscript.py</code>:</p>\n<ol>\n<li>In <code>Device.__init__()</code>, a kwarg <code>remote_device</code> is expected to be a dictionary containing host and port info of the <code>RemoteProcessServer</code> and saved to the connection table.</li>\n<li>Then <code>Tab.__init__()</code> will take this information to instantiate <code>RemoteProcessClient</code>.</li>\n<li><code>DeviceTab.create_worker()</code> instantiates the worker class with the remote process client passed, which basically calls Process.subprocess() to start the connection with the remote process server.</li>\n</ol>\n<p><a data-is-external-link=\"true\" href=\"#!/fanyangphy/blacs/branch/remote-process\" rel=\"nofollow\">blacs:remote-process</a></p>\n<p><a data-is-external-link=\"true\" href=\"#!/fanyangphy/labscript/branch/remote-process\" rel=\"nofollow\">labscript:remote-process</a></p>\n<p>To set up a remote device, supply kwarg of the form <code>remote_device={'host': &lt;host&gt;, 'port': &lt;port&gt;, 'proxy_port': &lt;port&gt;}</code> to the device entry in <code>connectiontable.py</code>, start the remote process server on the remote computer, open the ports (7340 and 7440 are the defaults) in the firewall, and it should be ready to go.</p>\n<p>The rationale behind having a zeromq proxy server is that it simplifies the network setup: only two ports need to be configured in the firewall of the remote process server: the \"control port\" which is the good old ZMQServer port, and the \"proxy port\" that is the port of the zeromq router-dealer pair. It seems tricky to get the ip address of the client connecting to a zeromq socket as they don't expose that information in the API, and even if we could it won't be of much use if the client lives behind NAT. So a zeromq proxy seems like the best bet.</p>\n<p>One problem that I have't fixed is that the worker would need to have read (and write, if it's an acquisition device) access to the h5 file during transition to buffer and transition to manual. My idea would be to replace the filename with a <a data-is-external-link=\"true\" href=\"http://docs.h5py.org/en/stable/high/file.html#python-file-like-objects\" rel=\"nofollow\">python file-like object</a>. This file-like object can be a custom class made to access the file through the zeromq proxy tunnel. </p>\n<p>Basically the client end would look like:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">RemoteBytesIO</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">socket</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">socket</span> <span class=\"o\">=</span> <span class=\"n\">socket</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__getattr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">name</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"p\">[</span><span class=\"s1\">&#39;read&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;write&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;seek&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;tell&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;truncate&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;flush&#39;</span><span class=\"p\">]:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">AttributeError</span>\n        <span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;write&#39;</span><span class=\"p\">:</span>\n                <span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nb\">bytearray</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]),)</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">socket</span><span class=\"o\">.</span><span class=\"n\">send_pyobj</span><span class=\"p\">([</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"n\">kwargs</span><span class=\"p\">])</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">socket</span><span class=\"o\">.</span><span class=\"n\">poll</span><span class=\"p\">(</span><span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"mi\">1000</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n                <span class=\"k\">raise</span> <span class=\"n\">TimeoutError</span>\n            <span class=\"n\">retval</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">socket</span><span class=\"o\">.</span><span class=\"n\">recv_pyobj</span><span class=\"p\">()</span>\n            <span class=\"k\">return</span> <span class=\"n\">retval</span>\n</pre></div>\n\n\n<p>and the server end would look like:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">with</span> <span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"n\">fname</span><span class=\"p\">,</span> <span class=\"s1\">&#39;r+b&#39;</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">f</span><span class=\"p\">:</span>\n\n    <span class=\"k\">while</span> <span class=\"bp\">True</span><span class=\"p\">:</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"n\">cmd</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"n\">kwargs</span> <span class=\"o\">=</span> <span class=\"n\">socket</span><span class=\"o\">.</span><span class=\"n\">recv_pyobj</span><span class=\"p\">()</span>\n            <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">cmd</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"n\">kwargs</span><span class=\"p\">)</span>\n            <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">cmd</span><span class=\"p\">)(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n            <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">)</span>\n            <span class=\"n\">socket</span><span class=\"o\">.</span><span class=\"n\">send_pyobj</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">)</span>\n        <span class=\"k\">except</span> <span class=\"ne\">KeyboardInterrupt</span><span class=\"p\">:</span>\n            <span class=\"k\">break</span>\n</pre></div>\n\n\n<p>This approach does not require copying the whole file back and forth, which can be a problem if there are more than a couple remote devices.</p>\n<p>The code has been tested but may need to be cleaned up a bit.</p>", "type": "rendered"}, "created_on": "2019-01-03T00:57:48.349800+00:00", "user": {"display_name": "Fan Yang", "uuid": "{84e9513b-672d-44f3-97a0-3c988cb8bd6f}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B84e9513b-672d-44f3-97a0-3c988cb8bd6f%7D"}, "html": {"href": "https://bitbucket.org/%7B84e9513b-672d-44f3-97a0-3c988cb8bd6f%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/ce3c9c93ff364578bf09813bd854f924d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsFY-1.png"}}, "nickname": "fanyangphy", "type": "user", "account_id": "5c1b1564f9cb4734ae1bc982"}, "updated_on": null, "type": "issue_comment", "id": 49714202}