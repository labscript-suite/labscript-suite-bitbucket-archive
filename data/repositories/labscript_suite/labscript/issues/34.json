{"priority": "major", "kind": "enhancement", "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "links": {"attachments": {"href": "data/repositories/labscript_suite/labscript/issues/34/attachments_page=1.json"}, "self": {"href": "data/repositories/labscript_suite/labscript/issues/34.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript/issues/34/watch"}, "comments": {"href": "data/repositories/labscript_suite/labscript/issues/34/comments_page=1.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/34/ramp-splitting"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript/issues/34/vote"}}, "reporter": {"display_name": "ReneKolb", "uuid": "{a14da38a-5a42-4215-a657-8d03e2e12c62}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Ba14da38a-5a42-4215-a657-8d03e2e12c62%7D"}, "html": {"href": "https://bitbucket.org/%7Ba14da38a-5a42-4215-a657-8d03e2e12c62%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/fdb60d6ad1bfc79b620af131e1ff76acd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsR-3.png"}}, "nickname": "ReneKolb", "type": "user", "account_id": "557058:cee66bea-c1f2-4230-9ace-11e2dc725285"}, "title": "Ramp splitting", "component": null, "votes": 0, "watches": 3, "content": {"raw": "If an AnalogOutput on Clockline1 does a ramp and another DigitaOut on Clockline2 should change its state during the ramp (at t=t2), the compile process adds an instruction to both clocklines at t=t2. This additional clock-tick may lead to clock ticks on ClockLine1 which the AnalogOutput card cannot handle\r\n\r\nIn order to fix this issue the ramp could be split into multiple sections, in which the ClockLine1 emmits pulses at the appropriate ramp samplerate, stop at t2, emmit a single clocktick on Clockline2 and continue ticking an ClockLine1 with the ramp samplerate. \r\n\r\nI wrote a (maybe hacky) solution, but it seems to work (see attachment).\r\nIn Line 486 \"def self.collect_change_times(...)\" I collect all times which are during a ramp and return them as list in a dict with the clockline.name as key.\r\n\r\nIn Line 596: def expand_change_times(), I analyse the split times and check if multiple times belong to the same \"split\" ( mutliple times are in between two ramp ticks). Also I analyse if a split time is simultaneous to a ramp tick, so the pseudoclock has to emmit clock signals on both ClockLines.\r\n\r\nThen the actual ramp instructions are added to the clock list. Afterwards the other instructions are inserted at the correct list index, to keep time ordering.\r\n\r\nI also calculate the correct step size for all the clock instructions.\r\n\r\nI also attached a runviewer screenshot of a compiled example script. (don't be confused about the short graphs for Cooler_TTL and Oszi_Trigger. This seems to be a bug in our runviewer implementation)\r\nA1_clockline and D1_clockline are the both clocklines. A1_clockline for the AnalogOut TiSa1_Amplitude, D1_clockline for the DigitalOuts Cooler_TTL and Oszi_Trigger.\r\nTiSa1_Amplitude does the ramp.\r\nCooler_TTL and Oszi_Trigger change their states during the ramp.\r\n\r\nI don't think this is the best or cleanest solution, but maybe you can use the idea ;-)", "markup": "markdown", "html": "<p>If an AnalogOutput on Clockline1 does a ramp and another DigitaOut on Clockline2 should change its state during the ramp (at t=t2), the compile process adds an instruction to both clocklines at t=t2. This additional clock-tick may lead to clock ticks on ClockLine1 which the AnalogOutput card cannot handle</p>\n<p>In order to fix this issue the ramp could be split into multiple sections, in which the ClockLine1 emmits pulses at the appropriate ramp samplerate, stop at t2, emmit a single clocktick on Clockline2 and continue ticking an ClockLine1 with the ramp samplerate. </p>\n<p>I wrote a (maybe hacky) solution, but it seems to work (see attachment).\nIn Line 486 \"def self.collect_change_times(...)\" I collect all times which are during a ramp and return them as list in a dict with the clockline.name as key.</p>\n<p>In Line 596: def expand_change_times(), I analyse the split times and check if multiple times belong to the same \"split\" ( mutliple times are in between two ramp ticks). Also I analyse if a split time is simultaneous to a ramp tick, so the pseudoclock has to emmit clock signals on both ClockLines.</p>\n<p>Then the actual ramp instructions are added to the clock list. Afterwards the other instructions are inserted at the correct list index, to keep time ordering.</p>\n<p>I also calculate the correct step size for all the clock instructions.</p>\n<p>I also attached a runviewer screenshot of a compiled example script. (don't be confused about the short graphs for Cooler_TTL and Oszi_Trigger. This seems to be a bug in our runviewer implementation)\nA1_clockline and D1_clockline are the both clocklines. A1_clockline for the AnalogOut TiSa1_Amplitude, D1_clockline for the DigitalOuts Cooler_TTL and Oszi_Trigger.\nTiSa1_Amplitude does the ramp.\nCooler_TTL and Oszi_Trigger change their states during the ramp.</p>\n<p>I don't think this is the best or cleanest solution, but maybe you can use the idea ;-)</p>", "type": "rendered"}, "assignee": null, "state": "new", "version": null, "edited_on": null, "created_on": "2017-05-30T13:16:29.639971+00:00", "milestone": null, "updated_on": "2017-05-31T16:06:24.249470+00:00", "type": "issue", "id": 34}