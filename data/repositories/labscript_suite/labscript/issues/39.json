{"priority": "major", "kind": "bug", "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "links": {"attachments": {"href": "data/repositories/labscript_suite/labscript/issues/39/attachments_page=1.json"}, "self": {"href": "data/repositories/labscript_suite/labscript/issues/39.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript/issues/39/watch"}, "comments": {"href": "data/repositories/labscript_suite/labscript/issues/39/comments_page=1.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/39/non-looping-clock-ticks-may-be-too-short"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript/issues/39/vote"}}, "reporter": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}, "title": "Non-looping clock ticks may be too short if they happen during a ramp", "component": null, "votes": 0, "watches": 1, "content": {"raw": "There is a bug in labscript where the non-looping clock ticks can be too short.\r\n\r\nThis is because ramps (a looping clock) is broken up into [two pseudoclock instructions](#!/labscript_suite/labscript/src/72f10b9ab0a00ed12833f42216229611574bdfac/labscript.py?at=default&fileviewer=file-view-default#labscript.py-686)*, the first where non-looping clocks and looping clocks tick, and then second where only looping clocks tick. However, the maximum rate is calculated based on the fastest ramp, and the maximum allowed ramping rate (the [`local_clock_limit`](#!/labscript_suite/labscript/src/72f10b9ab0a00ed12833f42216229611574bdfac/labscript.py?at=default&fileviewer=file-view-default#labscript.py-628)) determined by ramping clockline. This then ignores the clock limit for clocklines that are not ramping, but need updating during the first tick of the ramp.\r\n\r\nI'm not sure what the fix should be. We have options like:\r\n\r\n1. Force the maximum ramp rate to be limited by the clock limit of any non-ramping clocks that are commanded at the start/end or during a ramp (this is likely to make everyone's existing labscript files fail to compile)\r\n\r\n2. Somehow break the ramps at the pseudoclock device instruction level so that non-looping clocks have a period that matches the length of the looping clock ramp (this seems quite complicated to implement though as I think it breaks the current structure of the internal representation of pseudoclock instructions). Effectively this would mean we revert to the slow/fast clock system we had a long time ago (but it would be better because the slow/fast determination is made on a per ramp basis, and we'd still maintain gating)\r\n\r\n3. ??\r\n\r\nLooking for other better suggestions!\r\n\r\n\r\nNotes:\r\n\r\n\\* by this I mean the internal labscript dictionary that describes the pseudoclock instructions, which may translate to more pseudoclock device instructions depending on how many device instructions you need per clock tick", "markup": "markdown", "html": "<p>There is a bug in labscript where the non-looping clock ticks can be too short.</p>\n<p>This is because ramps (a looping clock) is broken up into <a data-is-external-link=\"true\" href=\"#!/labscript_suite/labscript/src/72f10b9ab0a00ed12833f42216229611574bdfac/labscript.py?at=default&amp;fileviewer=file-view-default#labscript.py-686\" rel=\"nofollow\">two pseudoclock instructions</a>*, the first where non-looping clocks and looping clocks tick, and then second where only looping clocks tick. However, the maximum rate is calculated based on the fastest ramp, and the maximum allowed ramping rate (the <a data-is-external-link=\"true\" href=\"#!/labscript_suite/labscript/src/72f10b9ab0a00ed12833f42216229611574bdfac/labscript.py?at=default&amp;fileviewer=file-view-default#labscript.py-628\" rel=\"nofollow\"><code>local_clock_limit</code></a>) determined by ramping clockline. This then ignores the clock limit for clocklines that are not ramping, but need updating during the first tick of the ramp.</p>\n<p>I'm not sure what the fix should be. We have options like:</p>\n<ol>\n<li>\n<p>Force the maximum ramp rate to be limited by the clock limit of any non-ramping clocks that are commanded at the start/end or during a ramp (this is likely to make everyone's existing labscript files fail to compile)</p>\n</li>\n<li>\n<p>Somehow break the ramps at the pseudoclock device instruction level so that non-looping clocks have a period that matches the length of the looping clock ramp (this seems quite complicated to implement though as I think it breaks the current structure of the internal representation of pseudoclock instructions). Effectively this would mean we revert to the slow/fast clock system we had a long time ago (but it would be better because the slow/fast determination is made on a per ramp basis, and we'd still maintain gating)</p>\n</li>\n<li>\n<p>??</p>\n</li>\n</ol>\n<p>Looking for other better suggestions!</p>\n<p>Notes:</p>\n<p>* by this I mean the internal labscript dictionary that describes the pseudoclock instructions, which may translate to more pseudoclock device instructions depending on how many device instructions you need per clock tick</p>", "type": "rendered"}, "assignee": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}, "state": "new", "version": null, "edited_on": null, "created_on": "2017-06-27T06:26:17.530551+00:00", "milestone": null, "updated_on": "2017-06-28T08:10:24.682574+00:00", "type": "issue", "id": 39}