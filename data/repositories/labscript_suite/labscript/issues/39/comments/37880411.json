{"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/39/comments/37880411.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/39#comment-37880411"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/39.json"}}, "type": "issue", "id": 39, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "Non-looping clock ticks may be too short if they happen during a ramp"}, "content": {"raw": "So I've thought about this a little more...\n\nWe'll need to implement different behaviour depending on the capabilities of the pseudoclock. For the purposes of the below explanation, I'll call it `supports_slow_clock` (permanent variable name to be decided later).\n\nFor pseudoclocks with a single clockline or pseudoclocks with multiple clocklines without independent control over the time at which the clocklines go high and low (an theoretical example of this is below*) we should throw an error when the clock will tick too fast for other clocklines. I believe this can be achieved by de-indenting the block of code [here](#!/labscript_suite/labscript/src/72f10b9ab0a00ed12833f42216229611574bdfac/labscript.py?at=default&fileviewer=file-view-default#labscript.py-641) which is only checked for ramping (looping) clocklines at the moment, and putting it inside an `if not self.supports_slow_clock:` statement (note that the comment there is incorrect...while there is a check for non-looping clocks to ensure that instructions are not too close together, this ignores the fact that the clock tick will be at the rate of the fastest ramp at that time).\n\nFor devices like the PulseBlaster that can support multiple clocklines and has independent instructions for changing the high/low state of each clockline, we can change the format of the `clock` dictionary that stores the internal description of the pseudoclock instructions. Here we will modify [these two lines](#!/labscript_suite/labscript/src/72f10b9ab0a00ed12833f42216229611574bdfac/labscript.py?at=default&fileviewer=file-view-default#labscript.py-691) such that we only have one `clock` instruction that contains a keys for looping clocks and non looping clocks. The device implementation of `generate_code` will then be modified to the the previous 4 hardware instructions (two for each of the instructions in `clock`) into 6. These 6 will be\n\n1. looping clocks and non-looping clocks go high\n2. looping clocks go low\n3. looping clocks go high (and jump to above instruction for N/2-1 repeats where N=Y-1 where Y is number of ticks in the ramp)\n4. looping and non-looping clocks go low\n5. looping clocks go high\n6. looping clocks go low (and jump to above instruction for N/2 repeats)\n\nThis is then followed by the existing two instructions ([1 `clock` instruction](#!/labscript_suite/labscript/src/72f10b9ab0a00ed12833f42216229611574bdfac/labscript.py?at=default&fileviewer=file-view-default#labscript.py-698)) that do the final tick of the ramp at the rate that makes the clock ready for the following labscript instruction.\n\nThese additional instructions could be negated if there are no non-looping clocks present for this ramp.\n\n**Note that this would mean the non-looping clock was slightly asymmetric due to the longer clock tick at the end of the ramp. Does anyone think this would be a problem?** Alternatively, if someone has a better solution, please present it!\n\n---\n\\* An example of a theoretical pseudoclock device with multiple clocklines but without independent control over the time at which each clockline goes high and low would be a PineBlaster with multiple clockline outputs (obviously this doesn't exist -- it's just an example!). Because the PineBlaster is programmed with a list of clock periods and number of loops for each instruction, it is impossible to command a clock-line to tick at an independent rate to another. You cannot have independent rates when you program the high-wait-low-wait (a clock tick) with a single instruction (#). This is in contrast to devices like the PulseBlaster, that have one instruction for setting an output high, and one instruction for setting an output low.\n\n\\# Of course you could have a device that had two outputs with two independent sets of instructions, but that would imply a multi-threaded device (which the chipkit is not) such as a custom FPGA. In such a case, the labscript object model would be one pseudoclock device containing multiple pseudoclocks, and each pseudoclock would have one clockline. This bug only concerns itself with the case of a multiple clocklines on a pseudoclock (regardless of how many independent pseudoclocks there might be in the pseudoclock device)", "markup": "markdown", "html": "<p>So I've thought about this a little more...</p>\n<p>We'll need to implement different behaviour depending on the capabilities of the pseudoclock. For the purposes of the below explanation, I'll call it <code>supports_slow_clock</code> (permanent variable name to be decided later).</p>\n<p>For pseudoclocks with a single clockline or pseudoclocks with multiple clocklines without independent control over the time at which the clocklines go high and low (an theoretical example of this is below*) we should throw an error when the clock will tick too fast for other clocklines. I believe this can be achieved by de-indenting the block of code <a data-is-external-link=\"true\" href=\"#!/labscript_suite/labscript/src/72f10b9ab0a00ed12833f42216229611574bdfac/labscript.py?at=default&amp;fileviewer=file-view-default#labscript.py-641\" rel=\"nofollow\">here</a> which is only checked for ramping (looping) clocklines at the moment, and putting it inside an <code>if not self.supports_slow_clock:</code> statement (note that the comment there is incorrect...while there is a check for non-looping clocks to ensure that instructions are not too close together, this ignores the fact that the clock tick will be at the rate of the fastest ramp at that time).</p>\n<p>For devices like the PulseBlaster that can support multiple clocklines and has independent instructions for changing the high/low state of each clockline, we can change the format of the <code>clock</code> dictionary that stores the internal description of the pseudoclock instructions. Here we will modify <a data-is-external-link=\"true\" href=\"#!/labscript_suite/labscript/src/72f10b9ab0a00ed12833f42216229611574bdfac/labscript.py?at=default&amp;fileviewer=file-view-default#labscript.py-691\" rel=\"nofollow\">these two lines</a> such that we only have one <code>clock</code> instruction that contains a keys for looping clocks and non looping clocks. The device implementation of <code>generate_code</code> will then be modified to the the previous 4 hardware instructions (two for each of the instructions in <code>clock</code>) into 6. These 6 will be</p>\n<ol>\n<li>looping clocks and non-looping clocks go high</li>\n<li>looping clocks go low</li>\n<li>looping clocks go high (and jump to above instruction for N/2-1 repeats where N=Y-1 where Y is number of ticks in the ramp)</li>\n<li>looping and non-looping clocks go low</li>\n<li>looping clocks go high</li>\n<li>looping clocks go low (and jump to above instruction for N/2 repeats)</li>\n</ol>\n<p>This is then followed by the existing two instructions (<a data-is-external-link=\"true\" href=\"#!/labscript_suite/labscript/src/72f10b9ab0a00ed12833f42216229611574bdfac/labscript.py?at=default&amp;fileviewer=file-view-default#labscript.py-698\" rel=\"nofollow\">1 <code>clock</code> instruction</a>) that do the final tick of the ramp at the rate that makes the clock ready for the following labscript instruction.</p>\n<p>These additional instructions could be negated if there are no non-looping clocks present for this ramp.</p>\n<p><strong>Note that this would mean the non-looping clock was slightly asymmetric due to the longer clock tick at the end of the ramp. Does anyone think this would be a problem?</strong> Alternatively, if someone has a better solution, please present it!</p>\n<hr />\n<p>* An example of a theoretical pseudoclock device with multiple clocklines but without independent control over the time at which each clockline goes high and low would be a PineBlaster with multiple clockline outputs (obviously this doesn't exist -- it's just an example!). Because the PineBlaster is programmed with a list of clock periods and number of loops for each instruction, it is impossible to command a clock-line to tick at an independent rate to another. You cannot have independent rates when you program the high-wait-low-wait (a clock tick) with a single instruction (#). This is in contrast to devices like the PulseBlaster, that have one instruction for setting an output high, and one instruction for setting an output low.</p>\n<p># Of course you could have a device that had two outputs with two independent sets of instructions, but that would imply a multi-threaded device (which the chipkit is not) such as a custom FPGA. In such a case, the labscript object model would be one pseudoclock device containing multiple pseudoclocks, and each pseudoclock would have one clockline. This bug only concerns itself with the case of a multiple clocklines on a pseudoclock (regardless of how many independent pseudoclocks there might be in the pseudoclock device)</p>", "type": "rendered"}, "created_on": "2017-06-28T04:02:13.834769+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}, "updated_on": null, "type": "issue_comment", "id": 37880411}