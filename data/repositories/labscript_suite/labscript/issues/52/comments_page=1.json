{"pagelen": 100, "values": [{"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/52/comments/52934327.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/52#comment-52934327"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/52.json"}}, "type": "issue", "id": 52, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "Redefinition of digital outputs (at least) is silent"}, "content": {"raw": "Thanks for the report! I noticed the same thing recently. The NI DAQmx class isn't checking that the 'connection' strings of its children are unique, so both children get added and the instructions that get saved correspond to the second one that was added, since although the children are stored as a list, the code does this before saving instructions:\n\n```python\n        digitals = {}\n        for device in self.child_devices:\n            ...\n            elif isinstance(device, (DigitalOut, StaticDigitalOut)):\n                digitals[device.connection] = device\n            ...\n```\n\nSo it's iterating over the list but only the second device with a duplicate connection string survives in the dict it constructs.\n\nThe previous NI DAQmx code looks like it did the exact same thing, although at least it was more self-aware about it:\n\n```python\n    def add_device(self,output):\n        # TODO: check there are no duplicates, check that connection\n        # string is formatted correctly.\n        IntermediateDevice.add_device(self,output)\n```\n\nAnd I suspect the problem is widespread in labscript. We should modify `Device.add_device()` to check for uniqueness, but presently the 'connection' strings are fairly free-form and so if one were upper case and another were lower-case but they were otherwise identical, a lot of device code wouldn't care, but they wouldn't be picked up as duplicates. So probably every device's `add_device()` method just needs more error checking.\n\nI'll patch this for the NI DAQmx devices, which *do* check the format of the `'port0/line1'` etc strings rigorously enough that case matters and duplicates will always be detected, but it will still remain an issue for the other devices 'til we go through them and define more rigorously what their connection strings have to be to be valid (right now you could probably call a pulseblaster flag `'ham 1'` instead of `'flag 1'` and I think it would still work...).", "markup": "markdown", "html": "<p>Thanks for the report! I noticed the same thing recently. The NI DAQmx class isn't checking that the 'connection' strings of its children are unique, so both children get added and the instructions that get saved correspond to the second one that was added, since although the children are stored as a list, the code does this before saving instructions:</p>\n<div class=\"codehilite language-python\"><pre><span></span>        <span class=\"n\">digitals</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n        <span class=\"k\">for</span> <span class=\"n\">device</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">child_devices</span><span class=\"p\">:</span>\n            <span class=\"o\">...</span>\n            <span class=\"k\">elif</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">DigitalOut</span><span class=\"p\">,</span> <span class=\"n\">StaticDigitalOut</span><span class=\"p\">)):</span>\n                <span class=\"n\">digitals</span><span class=\"p\">[</span><span class=\"n\">device</span><span class=\"o\">.</span><span class=\"n\">connection</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">device</span>\n            <span class=\"o\">...</span>\n</pre></div>\n\n\n<p>So it's iterating over the list but only the second device with a duplicate connection string survives in the dict it constructs.</p>\n<p>The previous NI DAQmx code looks like it did the exact same thing, although at least it was more self-aware about it:</p>\n<div class=\"codehilite language-python\"><pre><span></span>    <span class=\"k\">def</span> <span class=\"nf\">add_device</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"n\">output</span><span class=\"p\">):</span>\n        <span class=\"c1\"># TODO: check there are no duplicates, check that connection</span>\n        <span class=\"c1\"># string is formatted correctly.</span>\n        <span class=\"n\">IntermediateDevice</span><span class=\"o\">.</span><span class=\"n\">add_device</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"n\">output</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>And I suspect the problem is widespread in labscript. We should modify <code>Device.add_device()</code> to check for uniqueness, but presently the 'connection' strings are fairly free-form and so if one were upper case and another were lower-case but they were otherwise identical, a lot of device code wouldn't care, but they wouldn't be picked up as duplicates. So probably every device's <code>add_device()</code> method just needs more error checking.</p>\n<p>I'll patch this for the NI DAQmx devices, which <em>do</em> check the format of the <code>'port0/line1'</code> etc strings rigorously enough that case matters and duplicates will always be detected, but it will still remain an issue for the other devices 'til we go through them and define more rigorously what their connection strings have to be to be valid (right now you could probably call a pulseblaster flag <code>'ham 1'</code> instead of <code>'flag 1'</code> and I think it would still work...).</p>", "type": "rendered"}, "created_on": "2019-07-11T00:55:12.895748+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-07-11T00:59:19.050578+00:00", "type": "issue_comment", "id": 52934327}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/52/comments/52934849.json"}, "html": {"href": "#!/labscript_suite/labscript/issues/52#comment-52934849"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/issues/52.json"}}, "type": "issue", "id": 52, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript.json"}, "html": {"href": "#!/labscript_suite/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{48848b08-1db5-463b-bbdc-911beadf8bbf}ts=249917"}}, "type": "repository", "name": "labscript", "full_name": "labscript_suite/labscript", "uuid": "{48848b08-1db5-463b-bbdc-911beadf8bbf}"}, "title": "Redefinition of digital outputs (at least) is silent"}, "content": {"raw": "Whilst the second DO defined is the one whose instructions will actually be saved, I think the first one is the one BLACS will use for its label, since this is determined by their order in the connection table, which as far as I can tell is also order of definition (no dicts anywhere, just lists) - anyway dicts in Python 3.6+ are ordered by insertion order too.\n\nSo what you're seeing doesn't totally make sense to me but in any case we should just disallow duplicates and that will fix it whatever's going on.", "markup": "markdown", "html": "<p>Whilst the second DO defined is the one whose instructions will actually be saved, I think the first one is the one BLACS will use for its label, since this is determined by their order in the connection table, which as far as I can tell is also order of definition (no dicts anywhere, just lists) - anyway dicts in Python 3.6+ are ordered by insertion order too.</p>\n<p>So what you're seeing doesn't totally make sense to me but in any case we should just disallow duplicates and that will fix it whatever's going on.</p>", "type": "rendered"}, "created_on": "2019-07-11T02:17:37.740752+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-07-11T02:18:13.304103+00:00", "type": "issue_comment", "id": 52934849}], "page": 1, "size": 2}