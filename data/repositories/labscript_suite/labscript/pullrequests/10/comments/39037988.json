{"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10/comments/39037988.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10/_/diff#comment-39037988"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 10, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10"}}, "title": "Added basis for runviewer marker functionality"}, "content": {"raw": "Labscript has an absolute time: times are translated to be relative to the start time of a pseudoclock only after the user enters them. It is not necessary to ask \"whose time\" the time markers are: they're 'labscript time'. When you call labscript.wait(), you are similarly specifying a time in labscript time. So this patch poses no problem there. The only discrepancy between labscript time and the time as measured by a wall clock is waits. In 'labscript time' waits have zero duration. So to get wall time, you need to know labscript time plus the duration of waits that have occurred so far.\n\nI already had in mind to make the progress bar take waits into account. With no extra changes to labscript compilation, I can make the WaitMonitor emit events when waits start or end, saying how long they lasted, so that the progress bar can listen to them and show the right thing.\n\nA 'software time' device could be a useful addition to labscript as well, but at the moment if you wanted one to emit events, it would have to forward events from the WaitMonitor anyway, and you'd also have the code that controls a BLACS GUI element (the progress bar) listening for events from a specific device (it would have to know what the device is called, or what the events are called - this is extra configuration that has to be stored somewhere or declared by a naming convention. We do this for the WaitMonitor, it is special, but we want to minimise how many devices are special, as it makes the abstraction increasingly leaky the more there are). Unless the progress bar were shown in the device tab itself, which would of course be pretty silly.\n\nIf there is to be code emitting events when the experiment moves to different times, I think it should be a BLACS plugin. Keeping in mind that something being implemented as a plugin in the sense of BLACS doesn't mean it's not always enabled, it just means it probably has its own thread running a main loop and a somewhat rigidly defined interface with the rest of BLACS.\n\nSo it is a good separation of concerns to have something emit events, and the progress bar listen to them (i.e they could be two plugins, one depending on the other), but I don't think it makes sense to make the thing emitting events be a device, when it is going to have to collect events from other sources such as the WaitMonitor, and potentially other things we might want to fire events for.\n\nBLACS already knows when it tells the master pseudoclock to go, and this signifies the start of the experiment. Code running in BLACS can provide events after that time without knowing anything about the pseudoclocks. \n\nSo yes, I think making a device for this is abusing the idea of a 'device', and whilst that can be a good solution when the alternatives aren't so great, we have an alternative which to me seems satisfactory.", "markup": "markdown", "html": "<p>Labscript has an absolute time: times are translated to be relative to the start time of a pseudoclock only after the user enters them. It is not necessary to ask \"whose time\" the time markers are: they're 'labscript time'. When you call labscript.wait(), you are similarly specifying a time in labscript time. So this patch poses no problem there. The only discrepancy between labscript time and the time as measured by a wall clock is waits. In 'labscript time' waits have zero duration. So to get wall time, you need to know labscript time plus the duration of waits that have occurred so far.</p>\n<p>I already had in mind to make the progress bar take waits into account. With no extra changes to labscript compilation, I can make the WaitMonitor emit events when waits start or end, saying how long they lasted, so that the progress bar can listen to them and show the right thing.</p>\n<p>A 'software time' device could be a useful addition to labscript as well, but at the moment if you wanted one to emit events, it would have to forward events from the WaitMonitor anyway, and you'd also have the code that controls a BLACS GUI element (the progress bar) listening for events from a specific device (it would have to know what the device is called, or what the events are called - this is extra configuration that has to be stored somewhere or declared by a naming convention. We do this for the WaitMonitor, it is special, but we want to minimise how many devices are special, as it makes the abstraction increasingly leaky the more there are). Unless the progress bar were shown in the device tab itself, which would of course be pretty silly.</p>\n<p>If there is to be code emitting events when the experiment moves to different times, I think it should be a BLACS plugin. Keeping in mind that something being implemented as a plugin in the sense of BLACS doesn't mean it's not always enabled, it just means it probably has its own thread running a main loop and a somewhat rigidly defined interface with the rest of BLACS.</p>\n<p>So it is a good separation of concerns to have something emit events, and the progress bar listen to them (i.e they could be two plugins, one depending on the other), but I don't think it makes sense to make the thing emitting events be a device, when it is going to have to collect events from other sources such as the WaitMonitor, and potentially other things we might want to fire events for.</p>\n<p>BLACS already knows when it tells the master pseudoclock to go, and this signifies the start of the experiment. Code running in BLACS can provide events after that time without knowing anything about the pseudoclocks. </p>\n<p>So yes, I think making a device for this is abusing the idea of a 'device', and whilst that can be a good solution when the alternatives aren't so great, we have an alternative which to me seems satisfactory.</p>", "type": "rendered"}, "created_on": "2017-06-18T21:40:51.039358+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-06-18T21:46:34.496503+00:00", "type": "pullrequest_comment", "id": 39037988}