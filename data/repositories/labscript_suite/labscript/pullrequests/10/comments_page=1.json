{"pagelen": 100, "values": [{"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10/comments/39033107.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10/_/diff#comment-39033107"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 10, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10"}}, "title": "Added basis for runviewer marker functionality"}, "content": {"raw": "@cbillington Does the dictionary of markers need to be stored in the compiler class so it doesn't clash with a global of the same name?\n\n@spielman, @rpanderson and @lincolnturner may want to weigh in with what they think of the location for storing these markers in the HDF5 file.", "markup": "markdown", "html": "<p>@cbillington Does the dictionary of markers need to be stored in the compiler class so it doesn't clash with a global of the same name?</p>\n<p>@spielman, @rpanderson and @lincolnturner may want to weigh in with what they think of the location for storing these markers in the HDF5 file.</p>", "type": "rendered"}, "created_on": "2017-06-18T08:49:52.472901+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}, "updated_on": "2017-06-18T08:49:52.505185+00:00", "type": "pullrequest_comment", "id": 39033107}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10/comments/39033153.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10/_/diff#comment-39033153"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 10, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10"}}, "title": "Added basis for runviewer marker functionality"}, "content": {"raw": "Since our group already uses this location in the HDF5 file I'm not eager to change it (unless there is a good reason to do so). ", "markup": "markdown", "html": "<p>Since our group already uses this location in the HDF5 file I'm not eager to change it (unless there is a good reason to do so). </p>", "type": "rendered"}, "created_on": "2017-06-18T08:56:44.713524+00:00", "user": {"display_name": "Jan Werkmann", "uuid": "{44c4905c-2b90-4045-a5f1-652b8e228626}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D"}, "html": {"href": "https://bitbucket.org/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5/07e5095a-4741-4dc0-a462-9c7d455f961d/128"}}, "nickname": "PhyNerd", "type": "user", "account_id": "557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5"}, "updated_on": "2017-06-18T08:56:44.776754+00:00", "type": "pullrequest_comment", "id": 39033153}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10/comments/39033197.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10/_/diff#comment-39033197"}}, "parent": {"id": 39033153, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10/comments/39033153.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10/_/diff#comment-39033153"}}, "depth": 1}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 10, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10"}}, "title": "Added basis for runviewer marker functionality"}, "content": {"raw": "That's a extremely valid point, and something we should consider. At the very least, we should ensure that runviewer is backwards compatible with loading the markers from the location you currently use if there is a compelling reason to put it somewhere else.", "markup": "markdown", "html": "<p>That's a extremely valid point, and something we should consider. At the very least, we should ensure that runviewer is backwards compatible with loading the markers from the location you currently use if there is a compelling reason to put it somewhere else.</p>", "type": "rendered"}, "created_on": "2017-06-18T09:00:39.729755+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}, "updated_on": "2017-06-18T09:00:39.732159+00:00", "type": "pullrequest_comment", "id": 39033197}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10/comments/39037666.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10/_/diff#comment-39037666"}}, "parent": {"id": 39033197, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10/comments/39033197.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10/_/diff#comment-39033197"}}, "depth": 2}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 10, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10"}}, "title": "Added basis for runviewer marker functionality"}, "content": {"raw": "The backward compatibility is the way to go I think. There's little harm to lines like \"look in this group, if it doesn't exist, try this one\" with a comment saying it's for backward compatibility. Code growing little things like that is not a big deal, because it is isolated to that little bit of code rather than all other programs having to do something strange (access a 'runviewer' group for timing info to be used outside runviewer) instead.\n\nI'd say officially we don't have to commit to any sort of backward compatibility until we stamp a version number on something, but I really don't mind an extra `except KeyError` block or whatever it would be for the sake of keeping a single group able to read files they've already made with 'pre-release' code.", "markup": "markdown", "html": "<p>The backward compatibility is the way to go I think. There's little harm to lines like \"look in this group, if it doesn't exist, try this one\" with a comment saying it's for backward compatibility. Code growing little things like that is not a big deal, because it is isolated to that little bit of code rather than all other programs having to do something strange (access a 'runviewer' group for timing info to be used outside runviewer) instead.</p>\n<p>I'd say officially we don't have to commit to any sort of backward compatibility until we stamp a version number on something, but I really don't mind an extra <code>except KeyError</code> block or whatever it would be for the sake of keeping a single group able to read files they've already made with 'pre-release' code.</p>", "type": "rendered"}, "created_on": "2017-06-18T20:46:15.820464+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-06-18T20:46:15.823048+00:00", "type": "pullrequest_comment", "id": 39037666}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10/comments/39035781.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10/_/diff#comment-39035781"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 10, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10"}}, "title": "Added basis for runviewer marker functionality"}, "content": {"raw": "As Phil suggested, I do have a viewpoint.  I don't think we want to introduce a new language construct for runviewer.  In the end this will lead to language clutter.  In the context of the discussion above I have two comments: \n\n* I instead think that we should use the device infrastructure to make a new device class for runviewer markers.  This will feel very logical since markers are placed at times just like other events occur at times.  The data would then be stored in the same tabular manner as for anything else.\n\n* I understand that a specific storage location is already implement in PhyNerd's lab, and can say two things on this.  First, in our labs were are tolerating local incompatibilities that are occurring as our changes are merged into the main branch, or second, we could add a language construct the allows the addition of hard links in the h5 file to deal with this.  ", "markup": "markdown", "html": "<p>As Phil suggested, I do have a viewpoint.  I don't think we want to introduce a new language construct for runviewer.  In the end this will lead to language clutter.  In the context of the discussion above I have two comments: </p>\n<ul>\n<li>\n<p>I instead think that we should use the device infrastructure to make a new device class for runviewer markers.  This will feel very logical since markers are placed at times just like other events occur at times.  The data would then be stored in the same tabular manner as for anything else.</p>\n</li>\n<li>\n<p>I understand that a specific storage location is already implement in PhyNerd's lab, and can say two things on this.  First, in our labs were are tolerating local incompatibilities that are occurring as our changes are merged into the main branch, or second, we could add a language construct the allows the addition of hard links in the h5 file to deal with this.  </p>\n</li>\n</ul>", "type": "rendered"}, "created_on": "2017-06-18T15:21:11.310995+00:00", "user": {"display_name": "Ian B. Spielman", "uuid": "{bff0d3df-2ed5-4ff6-b13d-ce6cd935edb1}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D"}, "html": {"href": "https://bitbucket.org/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/54beee087619e1a612011791e203f277d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsIS-0.png"}}, "nickname": "Ian Spielman", "type": "user", "account_id": "557058:b0e98d01-12e7-4a9d-a274-a195def255d2"}, "updated_on": "2017-06-18T15:21:11.313247+00:00", "type": "pullrequest_comment", "id": 39035781}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10/comments/39036770.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10/_/diff#comment-39036770"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 10, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10"}}, "title": "Added basis for runviewer marker functionality"}, "content": {"raw": "I would argue that a device is the wrong place for storing this information, because a device would imply unnecessary code in the experiment. Please correct me if I'm wrong but a device would need to be added to the connection table and I don't see any purpose in that. Also why create a whole object just for the purpose of storing a simple dict? \nI think markers should be something that you can easily be added to a experiment and a function does just that.\nAs for storing the data in a tabular manner I guess that wouldn't hurt.\n\nI don't think h5 hard links are necessary as I can just add backwards compatibility in the runviewer code.\nMaybe I expressed myself in a wrong way there. To be clear I can certainly accept changes to the storing mechanism but I really think there should be good reasoning behind it.", "markup": "markdown", "html": "<p>I would argue that a device is the wrong place for storing this information, because a device would imply unnecessary code in the experiment. Please correct me if I'm wrong but a device would need to be added to the connection table and I don't see any purpose in that. Also why create a whole object just for the purpose of storing a simple dict? \nI think markers should be something that you can easily be added to a experiment and a function does just that.\nAs for storing the data in a tabular manner I guess that wouldn't hurt.</p>\n<p>I don't think h5 hard links are necessary as I can just add backwards compatibility in the runviewer code.\nMaybe I expressed myself in a wrong way there. To be clear I can certainly accept changes to the storing mechanism but I really think there should be good reasoning behind it.</p>", "type": "rendered"}, "created_on": "2017-06-18T18:22:38.681848+00:00", "user": {"display_name": "Jan Werkmann", "uuid": "{44c4905c-2b90-4045-a5f1-652b8e228626}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D"}, "html": {"href": "https://bitbucket.org/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5/07e5095a-4741-4dc0-a462-9c7d455f961d/128"}}, "nickname": "PhyNerd", "type": "user", "account_id": "557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5"}, "updated_on": "2017-06-18T18:22:38.767570+00:00", "type": "pullrequest_comment", "id": 39036770}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10/comments/39036920.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10/_/diff#comment-39036920"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 10, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10"}}, "title": "Added basis for runviewer marker functionality"}, "content": {"raw": "I agree a device is the wrong place. It's nice for the rest of the code to be able to assume that most devices have parent devices, and that if they don't they are pseudoclocks, etc. It feels like making this feature a device would be abusing devices in place of a more general plugin/extension system. If the ability to turn features on and off (because not everybody wants them or they conflict with each other or whatever) is what's desired, then there should be an 'extensions' group in the HDF5 file in which each extension would have free-reign over a subgroup. For example, this is probably what will happen to the mercurial info saving code.\n\nHowever, I think this ought to be considered core functionality and not disableable, so I think it's fine if it gets a group at the top level of the HDF5 file. I would probably say it shouldn't be considered runviewer specific either - there should just be a toplevel group called something like \"time_markers\". And yes, it should be a dataset rather than attributes. See the \"waits\" table for an example of a dataset that includes both numbers and string names. A dataset with named columns is just as friendly to backward-compatible future modifications as a dictionary, since you can add a named column to the dataset and properly written code reading the dataset by column names will not break. \n\nOne reason I'm inclined to argue it should be core is that I'm planning on merging/reimplementing the Spielman fork's progress bar in BLACS that shows the progress of the experiment as it runs. This progress bar could use the time markers to tell you approximately what stage the experiment was up to.\n\nOne quibble about the code - I don't think \"markers\" should be added to the builtins dict. It's a mistake that we use builtins in the way we do, we should instead make a module object (from which you can `import *` to get the current behaviour) to contain the things we are putting in builtins, so whilst that change will come at some point, we shouldn't add to it!\n\nInstead, the markers dictionary should be an attribute to the global object `compiler` in the `labscript` module. Also if it's going to live at the top level and be possibly used by more than just runviewer, \"time_markers\" is a less ambiguous name:\n\n\n```\n#!python\n\nclass compiler:\n    ...\n    time_markers = {}\n\n...\ndef labscript_cleanup():\n    ...\n    compiler.time_markers = {}\n\ndef save_time_markers(hdf5_file):\n    ...\n    time_markers = compiler.time_markers\n    # Put them in a dataset\n\n```\n\nEven though the colours seem specific to runviewer - I could use them in the progress bar too! Then the colour of the bar would change to indicate the stage of the experiment, with the same colours your brain will have internalised from looking at runviewer.\n\nI'm not going to get much time to look at labsscript development stuff for the next week, and then I'm going to vanish for 3 weeks and not look at it at all, so I won't get much of a chance to look at or debate anything about this feature. So Phil, you should go ahead with this without my input, I'm happy to defer to Phil on how things should work on the runviewer side, and as for labscript my vote is: basically the same as what you've got now with minor changes:\n\n- Dataset in a top level group of the HDF5 file.\n\n- Named \"time_markers\" or something similarly slightly less ambiguous than just \"markers\n\n- Not a device or other extension: baked into labscript in exactly the way you've done it except to store the `markers` dictionary (renamed `time_markers` perhaps) in the `compiler` object rather than in builtins.\n\nThe Spielman labs use a function decorator to mark stages of the experiment - I think it's good way of doing things but it should be a wrapper around what you're doing rather than the only way of doing things, I think. So I might make a pull request to include this decorator if it looks sensible after this feature is otherwise complete.", "markup": "markdown", "html": "<p>I agree a device is the wrong place. It's nice for the rest of the code to be able to assume that most devices have parent devices, and that if they don't they are pseudoclocks, etc. It feels like making this feature a device would be abusing devices in place of a more general plugin/extension system. If the ability to turn features on and off (because not everybody wants them or they conflict with each other or whatever) is what's desired, then there should be an 'extensions' group in the HDF5 file in which each extension would have free-reign over a subgroup. For example, this is probably what will happen to the mercurial info saving code.</p>\n<p>However, I think this ought to be considered core functionality and not disableable, so I think it's fine if it gets a group at the top level of the HDF5 file. I would probably say it shouldn't be considered runviewer specific either - there should just be a toplevel group called something like \"time_markers\". And yes, it should be a dataset rather than attributes. See the \"waits\" table for an example of a dataset that includes both numbers and string names. A dataset with named columns is just as friendly to backward-compatible future modifications as a dictionary, since you can add a named column to the dataset and properly written code reading the dataset by column names will not break. </p>\n<p>One reason I'm inclined to argue it should be core is that I'm planning on merging/reimplementing the Spielman fork's progress bar in BLACS that shows the progress of the experiment as it runs. This progress bar could use the time markers to tell you approximately what stage the experiment was up to.</p>\n<p>One quibble about the code - I don't think \"markers\" should be added to the builtins dict. It's a mistake that we use builtins in the way we do, we should instead make a module object (from which you can <code>import *</code> to get the current behaviour) to contain the things we are putting in builtins, so whilst that change will come at some point, we shouldn't add to it!</p>\n<p>Instead, the markers dictionary should be an attribute to the global object <code>compiler</code> in the <code>labscript</code> module. Also if it's going to live at the top level and be possibly used by more than just runviewer, \"time_markers\" is a less ambiguous name:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">compiler</span><span class=\"p\">:</span>\n    <span class=\"o\">...</span>\n    <span class=\"n\">time_markers</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n\n<span class=\"o\">...</span>\n<span class=\"k\">def</span> <span class=\"nf\">labscript_cleanup</span><span class=\"p\">():</span>\n    <span class=\"o\">...</span>\n    <span class=\"n\">compiler</span><span class=\"o\">.</span><span class=\"n\">time_markers</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">save_time_markers</span><span class=\"p\">(</span><span class=\"n\">hdf5_file</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n    <span class=\"n\">time_markers</span> <span class=\"o\">=</span> <span class=\"n\">compiler</span><span class=\"o\">.</span><span class=\"n\">time_markers</span>\n    <span class=\"c1\"># Put them in a dataset</span>\n</pre></div>\n\n\n<p>Even though the colours seem specific to runviewer - I could use them in the progress bar too! Then the colour of the bar would change to indicate the stage of the experiment, with the same colours your brain will have internalised from looking at runviewer.</p>\n<p>I'm not going to get much time to look at labsscript development stuff for the next week, and then I'm going to vanish for 3 weeks and not look at it at all, so I won't get much of a chance to look at or debate anything about this feature. So Phil, you should go ahead with this without my input, I'm happy to defer to Phil on how things should work on the runviewer side, and as for labscript my vote is: basically the same as what you've got now with minor changes:</p>\n<ul>\n<li>\n<p>Dataset in a top level group of the HDF5 file.</p>\n</li>\n<li>\n<p>Named \"time_markers\" or something similarly slightly less ambiguous than just \"markers</p>\n</li>\n<li>\n<p>Not a device or other extension: baked into labscript in exactly the way you've done it except to store the <code>markers</code> dictionary (renamed <code>time_markers</code> perhaps) in the <code>compiler</code> object rather than in builtins.</p>\n</li>\n</ul>\n<p>The Spielman labs use a function decorator to mark stages of the experiment - I think it's good way of doing things but it should be a wrapper around what you're doing rather than the only way of doing things, I think. So I might make a pull request to include this decorator if it looks sensible after this feature is otherwise complete.</p>", "type": "rendered"}, "created_on": "2017-06-18T18:52:45.589099+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-06-18T18:52:45.591532+00:00", "type": "pullrequest_comment", "id": 39036920}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10/comments/39036947.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10/_/diff#comment-39036947"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 10, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10"}}, "title": "Added basis for runviewer marker functionality"}, "content": {"raw": "I agree by the way that language clutter is to be avoided, so we should grow an \"extensions\" system for the compiler like we have with BLACS. Then just like devices have free-reign over their subgroup of the 'devices' group, so would each extension over its subgroup. This is important for labscript to be able to grow in a sustainable and backward-compatible way, but I think that this specific addition is important enough to be a core feature, and ask you to take my word for it that I wouldn't say that about any feature I happened to like :p", "markup": "markdown", "html": "<p>I agree by the way that language clutter is to be avoided, so we should grow an \"extensions\" system for the compiler like we have with BLACS. Then just like devices have free-reign over their subgroup of the 'devices' group, so would each extension over its subgroup. This is important for labscript to be able to grow in a sustainable and backward-compatible way, but I think that this specific addition is important enough to be a core feature, and ask you to take my word for it that I wouldn't say that about any feature I happened to like :p</p>", "type": "rendered"}, "created_on": "2017-06-18T18:58:54.325213+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-06-18T18:58:54.327249+00:00", "type": "pullrequest_comment", "id": 39036947}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10/comments/39037574.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10/_/diff#comment-39037574"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 10, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10"}}, "title": "Added basis for runviewer marker functionality"}, "content": {"raw": "Made the changes and did a quick test. \nThey should work.\nThe naming of add_marker() is unchanged because it is shorter. Is there a wish to change it?", "markup": "markdown", "html": "<p>Made the changes and did a quick test. \nThey should work.\nThe naming of add_marker() is unchanged because it is shorter. Is there a wish to change it?</p>", "type": "rendered"}, "created_on": "2017-06-18T20:28:16.636796+00:00", "user": {"display_name": "Jan Werkmann", "uuid": "{44c4905c-2b90-4045-a5f1-652b8e228626}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D"}, "html": {"href": "https://bitbucket.org/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5/07e5095a-4741-4dc0-a462-9c7d455f961d/128"}}, "nickname": "PhyNerd", "type": "user", "account_id": "557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5"}, "updated_on": "2017-06-18T20:28:16.712003+00:00", "type": "pullrequest_comment", "id": 39037574}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10/comments/39037615.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10/_/diff#comment-39037615"}}, "parent": {"id": 39037574, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10/comments/39037574.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10/_/diff#comment-39037574"}}, "depth": 1}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 10, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10"}}, "title": "Added basis for runviewer marker functionality"}, "content": {"raw": "Looks good to me! I think the name probably should change - even though in the context of labscript it's pretty unambiguous, since all the other references to it are now 'time_marker' in order to reduce ambiguity in other contexts, it should probably be `add_time_marker()` in labscript in order to be consistent. Otherwise there's the potential for confusion that these might refer to different things, though there is nothing else called 'markers' presently. So that would be my vote.\n\nOther than that I would happy to merge this, pending Phil's approval.", "markup": "markdown", "html": "<p>Looks good to me! I think the name probably should change - even though in the context of labscript it's pretty unambiguous, since all the other references to it are now 'time_marker' in order to reduce ambiguity in other contexts, it should probably be <code>add_time_marker()</code> in labscript in order to be consistent. Otherwise there's the potential for confusion that these might refer to different things, though there is nothing else called 'markers' presently. So that would be my vote.</p>\n<p>Other than that I would happy to merge this, pending Phil's approval.</p>", "type": "rendered"}, "created_on": "2017-06-18T20:34:21.552814+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-06-18T20:34:21.555949+00:00", "type": "pullrequest_comment", "id": 39037615}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10/comments/39037873.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10/_/diff#comment-39037873"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 10, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10"}}, "title": "Added basis for runviewer marker functionality"}, "content": {"raw": "We should think about this more.  A marker is a type of event that occurs at a time, as are all other elements in labscript as a scripted control language.\n\nThe simple proposal of having runmanager have markers matches that, but as Chris points out, my suggestion of making this a device begs the question of \"what defines time\", but the following discussion manages to avoid that question.  It should faced head on.\n\nSo regarding the progress bar, right now that is a little visual aid that lets us know where we are in the shot, and the time is \"rough\" at best.  I have wanted for some time a software \"time\" device that starts whenever the master pseudoclock starts, and to the extent possible keeps sync even with waits.  With this, we can have an honest progress bar that responds to events sent out by this \"device.\"   I had not intended to bring up this at this point, but here it is.  \n\nIn this world, the software time-device sends out events at specific times in the script (defined ) that any listeners can respond to.  This allows for generic software actions to take place in response to events.  Run manager would naturally display these events, and of course the progress bar could also get colored from them.  This would still be linked to a pseudoclock, to at minimum emit a \"start\" event to the software clock  the proposed syntax could be like\n\n```\n#!python\n\n# Master pseudoclock\nPulseBlaster_SP2_24_100_32k('pulseblaster_0', programming_scheme='pb_stop_programming/STOP')\n\n# Initialize a sotware clock \u201cdevice\u201d.\n\nSoftClock(name='SoftwareClock', \n\tparent_device=pulseblaster_0.direct_outputs, \n\tconnection='zmq_events'\n\t)\n\n# Trivial script\nstart()\nt=0\nSoftClock.AddEvent(t, \"AwesomeMarker\", opts={'runmanager_color':'Red'})\nstop()\n```\nso my feeling with this small-seeming proposal is that it is a very natural part of a software clock that is desirable for things like adding timing to devices that can only do static outputs, but that can still be software-updated in shot.  One way to to is to make every pseudoclock class always have as part of itself such a soft-clock rather than introducing a new one, then we would have the syntax\n\n```\n#!python\n\n# Master pseudoclock\nPulseBlaster_SP2_24_100_32k('pulseblaster_0', programming_scheme='pb_stop_programming/STOP')\n\n# Trivial script\nstart()\nt=0\npulseblaster_0.AddEvent(t, \"AwesomeMarker\", opts={'runmanager_color':'Red'})\nstop()\n```\nI rather like this second solution since there are no new devices classes, and it has a syntax similar to what PhyNerd initially proposed, and it also solves Chris's issues since it _will_ be the pseudo-clock.\n\nAn initial version of this could use the code that already exists but move it into the pseudoclock ancestor class and have the current dictionary saved as an attributed to that device.  Since that device is the one defining the time that is being referenced it makes sense, much more sense that at the base level of the h5 file.\n", "markup": "markdown", "html": "<p>We should think about this more.  A marker is a type of event that occurs at a time, as are all other elements in labscript as a scripted control language.</p>\n<p>The simple proposal of having runmanager have markers matches that, but as Chris points out, my suggestion of making this a device begs the question of \"what defines time\", but the following discussion manages to avoid that question.  It should faced head on.</p>\n<p>So regarding the progress bar, right now that is a little visual aid that lets us know where we are in the shot, and the time is \"rough\" at best.  I have wanted for some time a software \"time\" device that starts whenever the master pseudoclock starts, and to the extent possible keeps sync even with waits.  With this, we can have an honest progress bar that responds to events sent out by this \"device.\"   I had not intended to bring up this at this point, but here it is.  </p>\n<p>In this world, the software time-device sends out events at specific times in the script (defined ) that any listeners can respond to.  This allows for generic software actions to take place in response to events.  Run manager would naturally display these events, and of course the progress bar could also get colored from them.  This would still be linked to a pseudoclock, to at minimum emit a \"start\" event to the software clock  the proposed syntax could be like</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"c1\"># Master pseudoclock</span>\n<span class=\"n\">PulseBlaster_SP2_24_100_32k</span><span class=\"p\">(</span><span class=\"s1\">&#39;pulseblaster_0&#39;</span><span class=\"p\">,</span> <span class=\"n\">programming_scheme</span><span class=\"o\">=</span><span class=\"s1\">&#39;pb_stop_programming/STOP&#39;</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Initialize a sotware clock \u201cdevice\u201d.</span>\n\n<span class=\"n\">SoftClock</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">&#39;SoftwareClock&#39;</span><span class=\"p\">,</span> \n    <span class=\"n\">parent_device</span><span class=\"o\">=</span><span class=\"n\">pulseblaster_0</span><span class=\"o\">.</span><span class=\"n\">direct_outputs</span><span class=\"p\">,</span> \n    <span class=\"n\">connection</span><span class=\"o\">=</span><span class=\"s1\">&#39;zmq_events&#39;</span>\n    <span class=\"p\">)</span>\n\n<span class=\"c1\"># Trivial script</span>\n<span class=\"n\">start</span><span class=\"p\">()</span>\n<span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mi\">0</span>\n<span class=\"n\">SoftClock</span><span class=\"o\">.</span><span class=\"n\">AddEvent</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"s2\">&quot;AwesomeMarker&quot;</span><span class=\"p\">,</span> <span class=\"n\">opts</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;runmanager_color&#39;</span><span class=\"p\">:</span><span class=\"s1\">&#39;Red&#39;</span><span class=\"p\">})</span>\n<span class=\"n\">stop</span><span class=\"p\">()</span>\n</pre></div>\n\n\n<p>so my feeling with this small-seeming proposal is that it is a very natural part of a software clock that is desirable for things like adding timing to devices that can only do static outputs, but that can still be software-updated in shot.  One way to to is to make every pseudoclock class always have as part of itself such a soft-clock rather than introducing a new one, then we would have the syntax</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"c1\"># Master pseudoclock</span>\n<span class=\"n\">PulseBlaster_SP2_24_100_32k</span><span class=\"p\">(</span><span class=\"s1\">&#39;pulseblaster_0&#39;</span><span class=\"p\">,</span> <span class=\"n\">programming_scheme</span><span class=\"o\">=</span><span class=\"s1\">&#39;pb_stop_programming/STOP&#39;</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Trivial script</span>\n<span class=\"n\">start</span><span class=\"p\">()</span>\n<span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mi\">0</span>\n<span class=\"n\">pulseblaster_0</span><span class=\"o\">.</span><span class=\"n\">AddEvent</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"s2\">&quot;AwesomeMarker&quot;</span><span class=\"p\">,</span> <span class=\"n\">opts</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;runmanager_color&#39;</span><span class=\"p\">:</span><span class=\"s1\">&#39;Red&#39;</span><span class=\"p\">})</span>\n<span class=\"n\">stop</span><span class=\"p\">()</span>\n</pre></div>\n\n\n<p>I rather like this second solution since there are no new devices classes, and it has a syntax similar to what PhyNerd initially proposed, and it also solves Chris's issues since it <em>will</em> be the pseudo-clock.</p>\n<p>An initial version of this could use the code that already exists but move it into the pseudoclock ancestor class and have the current dictionary saved as an attributed to that device.  Since that device is the one defining the time that is being referenced it makes sense, much more sense that at the base level of the h5 file.</p>", "type": "rendered"}, "created_on": "2017-06-18T21:20:50.981296+00:00", "user": {"display_name": "Ian B. Spielman", "uuid": "{bff0d3df-2ed5-4ff6-b13d-ce6cd935edb1}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D"}, "html": {"href": "https://bitbucket.org/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/54beee087619e1a612011791e203f277d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsIS-0.png"}}, "nickname": "Ian Spielman", "type": "user", "account_id": "557058:b0e98d01-12e7-4a9d-a274-a195def255d2"}, "updated_on": "2017-06-18T21:27:47.737702+00:00", "type": "pullrequest_comment", "id": 39037873}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10/comments/39037988.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10/_/diff#comment-39037988"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 10, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10"}}, "title": "Added basis for runviewer marker functionality"}, "content": {"raw": "Labscript has an absolute time: times are translated to be relative to the start time of a pseudoclock only after the user enters them. It is not necessary to ask \"whose time\" the time markers are: they're 'labscript time'. When you call labscript.wait(), you are similarly specifying a time in labscript time. So this patch poses no problem there. The only discrepancy between labscript time and the time as measured by a wall clock is waits. In 'labscript time' waits have zero duration. So to get wall time, you need to know labscript time plus the duration of waits that have occurred so far.\n\nI already had in mind to make the progress bar take waits into account. With no extra changes to labscript compilation, I can make the WaitMonitor emit events when waits start or end, saying how long they lasted, so that the progress bar can listen to them and show the right thing.\n\nA 'software time' device could be a useful addition to labscript as well, but at the moment if you wanted one to emit events, it would have to forward events from the WaitMonitor anyway, and you'd also have the code that controls a BLACS GUI element (the progress bar) listening for events from a specific device (it would have to know what the device is called, or what the events are called - this is extra configuration that has to be stored somewhere or declared by a naming convention. We do this for the WaitMonitor, it is special, but we want to minimise how many devices are special, as it makes the abstraction increasingly leaky the more there are). Unless the progress bar were shown in the device tab itself, which would of course be pretty silly.\n\nIf there is to be code emitting events when the experiment moves to different times, I think it should be a BLACS plugin. Keeping in mind that something being implemented as a plugin in the sense of BLACS doesn't mean it's not always enabled, it just means it probably has its own thread running a main loop and a somewhat rigidly defined interface with the rest of BLACS.\n\nSo it is a good separation of concerns to have something emit events, and the progress bar listen to them (i.e they could be two plugins, one depending on the other), but I don't think it makes sense to make the thing emitting events be a device, when it is going to have to collect events from other sources such as the WaitMonitor, and potentially other things we might want to fire events for.\n\nBLACS already knows when it tells the master pseudoclock to go, and this signifies the start of the experiment. Code running in BLACS can provide events after that time without knowing anything about the pseudoclocks. \n\nSo yes, I think making a device for this is abusing the idea of a 'device', and whilst that can be a good solution when the alternatives aren't so great, we have an alternative which to me seems satisfactory.", "markup": "markdown", "html": "<p>Labscript has an absolute time: times are translated to be relative to the start time of a pseudoclock only after the user enters them. It is not necessary to ask \"whose time\" the time markers are: they're 'labscript time'. When you call labscript.wait(), you are similarly specifying a time in labscript time. So this patch poses no problem there. The only discrepancy between labscript time and the time as measured by a wall clock is waits. In 'labscript time' waits have zero duration. So to get wall time, you need to know labscript time plus the duration of waits that have occurred so far.</p>\n<p>I already had in mind to make the progress bar take waits into account. With no extra changes to labscript compilation, I can make the WaitMonitor emit events when waits start or end, saying how long they lasted, so that the progress bar can listen to them and show the right thing.</p>\n<p>A 'software time' device could be a useful addition to labscript as well, but at the moment if you wanted one to emit events, it would have to forward events from the WaitMonitor anyway, and you'd also have the code that controls a BLACS GUI element (the progress bar) listening for events from a specific device (it would have to know what the device is called, or what the events are called - this is extra configuration that has to be stored somewhere or declared by a naming convention. We do this for the WaitMonitor, it is special, but we want to minimise how many devices are special, as it makes the abstraction increasingly leaky the more there are). Unless the progress bar were shown in the device tab itself, which would of course be pretty silly.</p>\n<p>If there is to be code emitting events when the experiment moves to different times, I think it should be a BLACS plugin. Keeping in mind that something being implemented as a plugin in the sense of BLACS doesn't mean it's not always enabled, it just means it probably has its own thread running a main loop and a somewhat rigidly defined interface with the rest of BLACS.</p>\n<p>So it is a good separation of concerns to have something emit events, and the progress bar listen to them (i.e they could be two plugins, one depending on the other), but I don't think it makes sense to make the thing emitting events be a device, when it is going to have to collect events from other sources such as the WaitMonitor, and potentially other things we might want to fire events for.</p>\n<p>BLACS already knows when it tells the master pseudoclock to go, and this signifies the start of the experiment. Code running in BLACS can provide events after that time without knowing anything about the pseudoclocks. </p>\n<p>So yes, I think making a device for this is abusing the idea of a 'device', and whilst that can be a good solution when the alternatives aren't so great, we have an alternative which to me seems satisfactory.</p>", "type": "rendered"}, "created_on": "2017-06-18T21:40:51.039358+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-06-18T21:46:34.496503+00:00", "type": "pullrequest_comment", "id": 39037988}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10/comments/39038073.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10/_/diff#comment-39038073"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 10, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10"}}, "title": "Added basis for runviewer marker functionality"}, "content": {"raw": "If the user wants an event relative to the start time of a specific pseudoclock, they can do that with @PhyNerd 's patch with:\n\n\n```\n#!python\n\nadd_time_marker(pulseblaster_0.t0 + t, \"AwesomeMarker\", color=(255,0,0))\n\n```\n\nThat will mean the time is relative to the start_time of `pulseblaster_0` (which is 0 only if `pulseblaster_0` is the master pseudoclock). But the more common use case is wanting to fire events at the time that you command other outputs, so since those other commands take absolute time, it makes sense for the default of this setting markers to be absolute time.", "markup": "markdown", "html": "<p>If the user wants an event relative to the start time of a specific pseudoclock, they can do that with @PhyNerd 's patch with:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"n\">add_time_marker</span><span class=\"p\">(</span><span class=\"n\">pulseblaster_0</span><span class=\"o\">.</span><span class=\"n\">t0</span> <span class=\"o\">+</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"s2\">&quot;AwesomeMarker&quot;</span><span class=\"p\">,</span> <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">255</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">))</span>\n</pre></div>\n\n\n<p>That will mean the time is relative to the start_time of <code>pulseblaster_0</code> (which is 0 only if <code>pulseblaster_0</code> is the master pseudoclock). But the more common use case is wanting to fire events at the time that you command other outputs, so since those other commands take absolute time, it makes sense for the default of this setting markers to be absolute time.</p>", "type": "rendered"}, "created_on": "2017-06-18T21:53:54.857654+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-06-18T21:54:02.833086+00:00", "type": "pullrequest_comment", "id": 39038073}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10/comments/39038756.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10/_/diff#comment-39038756"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 10, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10"}}, "title": "Added basis for runviewer marker functionality"}, "content": {"raw": "Well, if labscript already has a sense of labscript time that differs from the time maintained by the master pseudoclock (confusing to me), then I think that should be made explicit rather than totally hidden as it is now.  In this case I suggest introducing a new core-language class called LabScriptTime that will behave as follows:\n\n```\n# Trivial script\nstart()\nt=LabScriptTime(0)\nt += 4\nt.add_marker(\"AwesomeMarker\", opts={'runmanager_color':'Red'})\nstop()\n\n#\n# Or even have start return an object of type LabScriptTime which would look like\n#\n\nt=start()\nt += 4\nt.add_marker(\"AwesomeMarker\", opts={'runmanager_color':'Red'})\nstop()\n```\n\nsuch an object would define all behavior for += and so forth to maintain the behavior of current scripts that expect a number to be passed.  This has some flaws in implementation, for example somebody might set t = 5, which would change t into a number.", "markup": "markdown", "html": "<p>Well, if labscript already has a sense of labscript time that differs from the time maintained by the master pseudoclock (confusing to me), then I think that should be made explicit rather than totally hidden as it is now.  In this case I suggest introducing a new core-language class called LabScriptTime that will behave as follows:</p>\n<div class=\"codehilite\"><pre><span></span># Trivial script\nstart()\nt=LabScriptTime(0)\nt += 4\nt.add_marker(&quot;AwesomeMarker&quot;, opts={&#39;runmanager_color&#39;:&#39;Red&#39;})\nstop()\n\n#\n# Or even have start return an object of type LabScriptTime which would look like\n#\n\nt=start()\nt += 4\nt.add_marker(&quot;AwesomeMarker&quot;, opts={&#39;runmanager_color&#39;:&#39;Red&#39;})\nstop()\n</pre></div>\n\n\n<p>such an object would define all behavior for += and so forth to maintain the behavior of current scripts that expect a number to be passed.  This has some flaws in implementation, for example somebody might set t = 5, which would change t into a number.</p>", "type": "rendered"}, "created_on": "2017-06-18T23:26:45.888745+00:00", "user": {"display_name": "Ian B. Spielman", "uuid": "{bff0d3df-2ed5-4ff6-b13d-ce6cd935edb1}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D"}, "html": {"href": "https://bitbucket.org/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/54beee087619e1a612011791e203f277d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsIS-0.png"}}, "nickname": "Ian Spielman", "type": "user", "account_id": "557058:b0e98d01-12e7-4a9d-a274-a195def255d2"}, "updated_on": "2017-06-18T23:27:30.863334+00:00", "type": "pullrequest_comment", "id": 39038756}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10/comments/39038851.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10/_/diff#comment-39038851"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 10, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/10.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/10"}}, "title": "Added basis for runviewer marker functionality"}, "content": {"raw": "Sorry if I was misleading, labscript time *does* correspond to the time (excluding the duration of waits) since the first instruction of the master pseudoclock. But not to the time since the first instruction of *other* pseudoclocks.  And when commanding output from devices that are not clocked by the master pseudoclock, one nonetheless uses labscript time. so `output.constant(0, something)` is an error for an output clocked by a secondary pseudoclock because you can't command output until at least the triggering delay has elapsed. Every output device has a `t0` attribute that tells you when the earliest you can command output is.\n\nIf it's confusing I think documentation is the answer rather than defining a time class. It's very easy to lose a custom class representing numbers when letting users do arithmetic with it, I'd strongly suggest sticking with standard types.\n\nIf you'd like to debate further and seek input from others as well, I'd suggest filing a feature request. Since waits already take an absolute time, any change to the way we treat times is bigger than this pull request, which is simple and does not create much technical debt if we decide to change it later.", "markup": "markdown", "html": "<p>Sorry if I was misleading, labscript time <em>does</em> correspond to the time (excluding the duration of waits) since the first instruction of the master pseudoclock. But not to the time since the first instruction of <em>other</em> pseudoclocks.  And when commanding output from devices that are not clocked by the master pseudoclock, one nonetheless uses labscript time. so <code>output.constant(0, something)</code> is an error for an output clocked by a secondary pseudoclock because you can't command output until at least the triggering delay has elapsed. Every output device has a <code>t0</code> attribute that tells you when the earliest you can command output is.</p>\n<p>If it's confusing I think documentation is the answer rather than defining a time class. It's very easy to lose a custom class representing numbers when letting users do arithmetic with it, I'd strongly suggest sticking with standard types.</p>\n<p>If you'd like to debate further and seek input from others as well, I'd suggest filing a feature request. Since waits already take an absolute time, any change to the way we treat times is bigger than this pull request, which is simple and does not create much technical debt if we decide to change it later.</p>", "type": "rendered"}, "created_on": "2017-06-18T23:35:50.885571+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-06-18T23:36:07.312119+00:00", "type": "pullrequest_comment", "id": 39038851}], "page": 1, "size": 15}