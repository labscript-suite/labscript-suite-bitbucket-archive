{"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/11/comments/39201918.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/11/_/diff#comment-39201918"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 11, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/11.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/11"}}, "title": "Added the ability to split ramps."}, "content": {"raw": "Thank you for the minimal example that clearly demonstrates the problem.\n\n> It is possible that this additional tick on the analog clockline is too close to a ramp clock tick, so the physical card cannot handle the update rate and the digital Card is limited by the maximum clock_limit of the analog card during a ramp.\n\nIf this is the case, then it is a bug. The intended behaviour is that a clock tick will occur at the time the digital output changed, and this will not be limited by the maximum update rate of the NI card. The last clock tick on the analog line is only inserted if labscript determines it is within the capabilities of the device, otherwise labscript leaves it out (see  [line 666 of labscript.py](#!/labscript_suite/labscript/src/7f4bffa24052338a0971ee6b2e7ea90b2de41f12/labscript.py?at=default&fileviewer=file-view-default#labscript.py-666)). But in either case the digital output changes at the correct time, and the only downside is that the analog output's final clock tick may be too *long* by an amount up to its minimum update interval. If I run your code but with the NI_PCI_6733 clock limit artificially reduced (in order to tell labscript that the final clock tick would be too fast) I don't get a LabscriptError. Running this code:\n\n\n```\n#!python\n\nfrom labscript import *\nfrom labscript_devices.PulseBlaster_No_DDS import PulseBlaster_No_DDS\nfrom labscript_devices.NI_USB_6343 import NI_USB_6343\nfrom labscript_devices.NI_PCI_6733 import NI_PCI_6733\n\nNI_PCI_6733.clock_limit = 250\n\n#Connection Table\nPulseBlaster_No_DDS( name='pulse_blaster')\nClockLine( name='A1_clockline', pseudoclock=pulse_blaster.pseudoclock, connection='flag 0')\nClockLine( name='D1_clockline', pseudoclock=pulse_blaster.pseudoclock, connection='flag 2')\nDigitalOut( name='pb_flag4', parent_device=pulse_blaster.direct_outputs, connection='flag 4')\nNI_USB_6343(name=\"dio\", MAX_name=\"dummy\", parent_device=D1_clockline, clock_terminal=\"dummy\")\nDigitalOut( name='DO00', parent_device=dio, connection='port0/line0')\nNI_PCI_6733(name=\"ana\", MAX_name=\"dummy2\", parent_device=A1_clockline, clock_terminal=\"dummy2\")\nAnalogOut(name=\"AO0\", parent_device=ana, connection=\"ao0\")\nAnalogOut(name=\"AO1\", parent_device=ana, connection=\"ao1\")\n#Experiment Logic\nstart()\nt=0.0\nAO0. ramp(t, duration=0.03, initial=3.0, final=5.0, samplerate=200)\nDO00. go_high(t+0.01555)\nt += 0.03\nt += 0.01\nstop(t)\n```\nI get the following:\n\n![runviewerscreenshot.png](data/bitbucket.org/repo/g75Ex9/images/1713143531-runviewerscreenshot.png)\n\n\nNow, granted, the analog ramp is still affected. Its final sample before the split lasts for ~5.5 ms, instead of 5 ms.\n\nSo what labscript currently aims to do is not give you the exact clock rate you asked for, but in general *at least* the clock rate you asked for (when multiple analog ramps are requested with different sample rates on outputs clocked by the same psuedoclock, they both run at the faster sample rate of the two), with the exception that clock ticks in the situation we're talking about might be *too slow* by an amount up to the minimum sample time the device is capable of.\n\nSo if the minimal example you provided is representative of your experiment, I'd be inclined to think that there is nothing to fix about how ramps are computed, and either `NI_PCI_6733.clock_limit` is set too high for you in your case or perhaps in general (it depends on the number of outputs, I think, which I don't think labscript is taking into account ).\n\nA change would be required though if:\n\n- You really want regular clock ticks for an analog output, and can't tolerate the occasional error on the scale of the minimum sample time the device is capable, or\n\n- You need the digital output not to just update at a specific time, but to change at a rate that is actually faster than what the analog card can handle. I'm not sure what labscript does in this case, but the solution would be simpler than the patch in this pull request because the (slower) analog ramp would have at most 1 sample for each faster change in the digital output.\n\nTypically we solve these problems by buying more PuleBlasters. But, they might be fixable in software. If the latter of the above two points is the case, then I'm fairly confident we can fix it more simply than this pull request (which I'm not sure fixes it either). If the former is the case then your pull request does indeed appear to solve the problem, and the only reason I would be wary of accepting it is that it is a large amount of code, and I also suspect a simpler solution is possible (such as the algorithms Ian is alluding to), which would be more maintainable over time.", "markup": "markdown", "html": "<p>Thank you for the minimal example that clearly demonstrates the problem.</p>\n<blockquote>\n<p>It is possible that this additional tick on the analog clockline is too close to a ramp clock tick, so the physical card cannot handle the update rate and the digital Card is limited by the maximum clock_limit of the analog card during a ramp.</p>\n</blockquote>\n<p>If this is the case, then it is a bug. The intended behaviour is that a clock tick will occur at the time the digital output changed, and this will not be limited by the maximum update rate of the NI card. The last clock tick on the analog line is only inserted if labscript determines it is within the capabilities of the device, otherwise labscript leaves it out (see  <a data-is-external-link=\"true\" href=\"#!/labscript_suite/labscript/src/7f4bffa24052338a0971ee6b2e7ea90b2de41f12/labscript.py?at=default&amp;fileviewer=file-view-default#labscript.py-666\" rel=\"nofollow\">line 666 of labscript.py</a>). But in either case the digital output changes at the correct time, and the only downside is that the analog output's final clock tick may be too <em>long</em> by an amount up to its minimum update interval. If I run your code but with the NI_PCI_6733 clock limit artificially reduced (in order to tell labscript that the final clock tick would be too fast) I don't get a LabscriptError. Running this code:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">labscript</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n<span class=\"kn\">from</span> <span class=\"nn\">labscript_devices.PulseBlaster_No_DDS</span> <span class=\"kn\">import</span> <span class=\"n\">PulseBlaster_No_DDS</span>\n<span class=\"kn\">from</span> <span class=\"nn\">labscript_devices.NI_USB_6343</span> <span class=\"kn\">import</span> <span class=\"n\">NI_USB_6343</span>\n<span class=\"kn\">from</span> <span class=\"nn\">labscript_devices.NI_PCI_6733</span> <span class=\"kn\">import</span> <span class=\"n\">NI_PCI_6733</span>\n\n<span class=\"n\">NI_PCI_6733</span><span class=\"o\">.</span><span class=\"n\">clock_limit</span> <span class=\"o\">=</span> <span class=\"mi\">250</span>\n\n<span class=\"c1\">#Connection Table</span>\n<span class=\"n\">PulseBlaster_No_DDS</span><span class=\"p\">(</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">&#39;pulse_blaster&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">ClockLine</span><span class=\"p\">(</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">&#39;A1_clockline&#39;</span><span class=\"p\">,</span> <span class=\"n\">pseudoclock</span><span class=\"o\">=</span><span class=\"n\">pulse_blaster</span><span class=\"o\">.</span><span class=\"n\">pseudoclock</span><span class=\"p\">,</span> <span class=\"n\">connection</span><span class=\"o\">=</span><span class=\"s1\">&#39;flag 0&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">ClockLine</span><span class=\"p\">(</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">&#39;D1_clockline&#39;</span><span class=\"p\">,</span> <span class=\"n\">pseudoclock</span><span class=\"o\">=</span><span class=\"n\">pulse_blaster</span><span class=\"o\">.</span><span class=\"n\">pseudoclock</span><span class=\"p\">,</span> <span class=\"n\">connection</span><span class=\"o\">=</span><span class=\"s1\">&#39;flag 2&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">DigitalOut</span><span class=\"p\">(</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">&#39;pb_flag4&#39;</span><span class=\"p\">,</span> <span class=\"n\">parent_device</span><span class=\"o\">=</span><span class=\"n\">pulse_blaster</span><span class=\"o\">.</span><span class=\"n\">direct_outputs</span><span class=\"p\">,</span> <span class=\"n\">connection</span><span class=\"o\">=</span><span class=\"s1\">&#39;flag 4&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">NI_USB_6343</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s2\">&quot;dio&quot;</span><span class=\"p\">,</span> <span class=\"n\">MAX_name</span><span class=\"o\">=</span><span class=\"s2\">&quot;dummy&quot;</span><span class=\"p\">,</span> <span class=\"n\">parent_device</span><span class=\"o\">=</span><span class=\"n\">D1_clockline</span><span class=\"p\">,</span> <span class=\"n\">clock_terminal</span><span class=\"o\">=</span><span class=\"s2\">&quot;dummy&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">DigitalOut</span><span class=\"p\">(</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">&#39;DO00&#39;</span><span class=\"p\">,</span> <span class=\"n\">parent_device</span><span class=\"o\">=</span><span class=\"n\">dio</span><span class=\"p\">,</span> <span class=\"n\">connection</span><span class=\"o\">=</span><span class=\"s1\">&#39;port0/line0&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">NI_PCI_6733</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s2\">&quot;ana&quot;</span><span class=\"p\">,</span> <span class=\"n\">MAX_name</span><span class=\"o\">=</span><span class=\"s2\">&quot;dummy2&quot;</span><span class=\"p\">,</span> <span class=\"n\">parent_device</span><span class=\"o\">=</span><span class=\"n\">A1_clockline</span><span class=\"p\">,</span> <span class=\"n\">clock_terminal</span><span class=\"o\">=</span><span class=\"s2\">&quot;dummy2&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">AnalogOut</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s2\">&quot;AO0&quot;</span><span class=\"p\">,</span> <span class=\"n\">parent_device</span><span class=\"o\">=</span><span class=\"n\">ana</span><span class=\"p\">,</span> <span class=\"n\">connection</span><span class=\"o\">=</span><span class=\"s2\">&quot;ao0&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">AnalogOut</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s2\">&quot;AO1&quot;</span><span class=\"p\">,</span> <span class=\"n\">parent_device</span><span class=\"o\">=</span><span class=\"n\">ana</span><span class=\"p\">,</span> <span class=\"n\">connection</span><span class=\"o\">=</span><span class=\"s2\">&quot;ao1&quot;</span><span class=\"p\">)</span>\n<span class=\"c1\">#Experiment Logic</span>\n<span class=\"n\">start</span><span class=\"p\">()</span>\n<span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>\n<span class=\"n\">AO0</span><span class=\"o\">.</span> <span class=\"n\">ramp</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">duration</span><span class=\"o\">=</span><span class=\"mf\">0.03</span><span class=\"p\">,</span> <span class=\"n\">initial</span><span class=\"o\">=</span><span class=\"mf\">3.0</span><span class=\"p\">,</span> <span class=\"n\">final</span><span class=\"o\">=</span><span class=\"mf\">5.0</span><span class=\"p\">,</span> <span class=\"n\">samplerate</span><span class=\"o\">=</span><span class=\"mi\">200</span><span class=\"p\">)</span>\n<span class=\"n\">DO00</span><span class=\"o\">.</span> <span class=\"n\">go_high</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">+</span><span class=\"mf\">0.01555</span><span class=\"p\">)</span>\n<span class=\"n\">t</span> <span class=\"o\">+=</span> <span class=\"mf\">0.03</span>\n<span class=\"n\">t</span> <span class=\"o\">+=</span> <span class=\"mf\">0.01</span>\n<span class=\"n\">stop</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>I get the following:</p>\n<p><img alt=\"runviewerscreenshot.png\" src=\"data/bitbucket.org/repo/g75Ex9/images/1713143531-runviewerscreenshot.png\" /></p>\n<p>Now, granted, the analog ramp is still affected. Its final sample before the split lasts for ~5.5 ms, instead of 5 ms.</p>\n<p>So what labscript currently aims to do is not give you the exact clock rate you asked for, but in general <em>at least</em> the clock rate you asked for (when multiple analog ramps are requested with different sample rates on outputs clocked by the same psuedoclock, they both run at the faster sample rate of the two), with the exception that clock ticks in the situation we're talking about might be <em>too slow</em> by an amount up to the minimum sample time the device is capable of.</p>\n<p>So if the minimal example you provided is representative of your experiment, I'd be inclined to think that there is nothing to fix about how ramps are computed, and either <code>NI_PCI_6733.clock_limit</code> is set too high for you in your case or perhaps in general (it depends on the number of outputs, I think, which I don't think labscript is taking into account ).</p>\n<p>A change would be required though if:</p>\n<ul>\n<li>\n<p>You really want regular clock ticks for an analog output, and can't tolerate the occasional error on the scale of the minimum sample time the device is capable, or</p>\n</li>\n<li>\n<p>You need the digital output not to just update at a specific time, but to change at a rate that is actually faster than what the analog card can handle. I'm not sure what labscript does in this case, but the solution would be simpler than the patch in this pull request because the (slower) analog ramp would have at most 1 sample for each faster change in the digital output.</p>\n</li>\n</ul>\n<p>Typically we solve these problems by buying more PuleBlasters. But, they might be fixable in software. If the latter of the above two points is the case, then I'm fairly confident we can fix it more simply than this pull request (which I'm not sure fixes it either). If the former is the case then your pull request does indeed appear to solve the problem, and the only reason I would be wary of accepting it is that it is a large amount of code, and I also suspect a simpler solution is possible (such as the algorithms Ian is alluding to), which would be more maintainable over time.</p>", "type": "rendered"}, "created_on": "2017-06-20T16:43:23.962043+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-06-21T01:22:19.603807+00:00", "type": "pullrequest_comment", "id": 39201918}