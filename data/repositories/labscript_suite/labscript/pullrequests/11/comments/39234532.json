{"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/11/comments/39234532.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/11/_/diff#comment-39234532"}}, "parent": {"id": 39234293, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/11/comments/39234293.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/11/_/diff#comment-39234293"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 11, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/11.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/11"}}, "title": "Added the ability to split ramps."}, "content": {"raw": "If the compilation code assumes quantisation has already happened when it hasn't, then yes, but in addition to that, even if we get the quantisation right in labscript, rounding down instead of nearest could be a disaster.\n\nAt least rounding to the nearest multiple of something is stable to floating point error. Do it twice and you'll get the same result as doing it once. Rounding down is not - if you round down yourself, and then some other code rounds down again, you'd better hope your first rounding down ended up slightly on the positive side of the target number and not the negative side, otherwise an entire unit will be subtracted off again. So this could be a problem even if we are getting the rounding 'right', by which I mean 'what we thought was right'.", "markup": "markdown", "html": "<p>If the compilation code assumes quantisation has already happened when it hasn't, then yes, but in addition to that, even if we get the quantisation right in labscript, rounding down instead of nearest could be a disaster.</p>\n<p>At least rounding to the nearest multiple of something is stable to floating point error. Do it twice and you'll get the same result as doing it once. Rounding down is not - if you round down yourself, and then some other code rounds down again, you'd better hope your first rounding down ended up slightly on the positive side of the target number and not the negative side, otherwise an entire unit will be subtracted off again. So this could be a problem even if we are getting the rounding 'right', by which I mean 'what we thought was right'.</p>", "type": "rendered"}, "created_on": "2017-06-21T03:31:59.943512+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-06-21T03:32:23.862032+00:00", "type": "pullrequest_comment", "id": 39234532}