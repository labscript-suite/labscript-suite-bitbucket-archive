{"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/9/comments/39026352.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/9/_/diff#comment-39026352"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 9, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/9.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/9"}}, "title": "Check ramp collision and shutter delays"}, "content": {"raw": "I've been thinking about how to implement these checks efficiently. \n\nFor the collision of instructions with ramps, I think we should modify `Output.get_change_times()` to include the following\n\n```\n#!python\n# These lines already exist in the method\ntimes = self.instructions.keys()\ntimes.sort()\n\n# new code to be inserted\ncurrent_dict_time = None\nfor time in times:\n    if isinstance(self.instructions[time], dict) and current_dict_time is None:\n        current_dict_time = self.instructions[time]\n    elif current_dict_time is not None and current_dict_time['initial time'] < time < current_dict_time['end time']:        \n        err = (\"{:s} {:s} has an instruction at t={:.10f}s. This instruction collides with a ramp on this output at that time. \".format(self.description, self.name, time)+\n               \"The colliding {:s} is from {:.10f}s till {:.10f}s\".format(inst['description'], current_dict_time['initial time'], current_dict_time['end time']))\n        raise LabscriptError(err) \n```\n\nThere may be a more efficient way to do this, but we should check this first to avoid premature optimisation. At least this only scales with O(N) rather than O(N^2).\n\n----\n\nThe shutter collision checking is a lot more complicated. I'm not sure we can actually do it correctly before the proper introduction of the instruction class that keeps track of things. This is because the current Shutter implementation appears broken to me because it assumes that the device starts at t=0, which is not the case for secondary pseudoclocks. Since the original code was broken, the patch in this pull request is also broken because it utilises the same time calculation. I think that calls to shutters within the open/close delay of the pseudoclock trigger, provided that trigger is at least one open/close delay after t=0 will probably raise an exception deep within labscript somewhere.\n\nI'd like to do this check in `get_change_times()` as well (override it in the `Shutter` class) but because we ignore the open/close delay if we are close to t=0, then we can't back-calculate the original request time at that point with the current labscript implementation. We could demand that shutters cannot be commanded prior to `output.t0 + output.open_delay` or `output.t0 + output.close_delay` for open/close respectively I suppose?\n\nThen we could do:\n\n```\n#!python\ndef get_change_times(self, *args, **kwargs):\n    retval = DigitalOut.get_change_times(self, *args, **kwargs)\n\n    for i, time in enumerate(self.times):\n        if i < len(self.times)-1:\n            next_time = self.times[i+1]\n            # only look at instructions that contain a state change\n            if self.instructions[time] != self.instructions[next_time]:\n                # calculate original times for these instructions, \n                # make sure they were not reordered!\n                if self.open_state == self.instructions[time]:\n                    t1 = time+self.open_delay\n                else:\n                    t1 = time+self.close_delay\n\n                if self.open_state == self.instructions[next_time]:\n                    t2 = next_time+self.open_delay\n                else:\n                    t2 = next_time+self.close_delay\n\n                if t2 < t1:\n                    #raise appropriately derived error message\n\n    return retval\n\n```\nThis also scales with O(N)\n\nNot sure if that's too drastic though (the limiting of how early shutters can be opened/closed)?\n\n", "markup": "markdown", "html": "<p>I've been thinking about how to implement these checks efficiently. </p>\n<p>For the collision of instructions with ramps, I think we should modify <code>Output.get_change_times()</code> to include the following</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"c1\"># These lines already exist in the method</span>\n<span class=\"n\">times</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">instructions</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">()</span>\n<span class=\"n\">times</span><span class=\"o\">.</span><span class=\"n\">sort</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># new code to be inserted</span>\n<span class=\"n\">current_dict_time</span> <span class=\"o\">=</span> <span class=\"bp\">None</span>\n<span class=\"k\">for</span> <span class=\"n\">time</span> <span class=\"ow\">in</span> <span class=\"n\">times</span><span class=\"p\">:</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">instructions</span><span class=\"p\">[</span><span class=\"n\">time</span><span class=\"p\">],</span> <span class=\"nb\">dict</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">current_dict_time</span> <span class=\"ow\">is</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">current_dict_time</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">instructions</span><span class=\"p\">[</span><span class=\"n\">time</span><span class=\"p\">]</span>\n    <span class=\"k\">elif</span> <span class=\"n\">current_dict_time</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span> <span class=\"ow\">and</span> <span class=\"n\">current_dict_time</span><span class=\"p\">[</span><span class=\"s1\">&#39;initial time&#39;</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">time</span> <span class=\"o\">&lt;</span> <span class=\"n\">current_dict_time</span><span class=\"p\">[</span><span class=\"s1\">&#39;end time&#39;</span><span class=\"p\">]:</span>        \n        <span class=\"n\">err</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s2\">&quot;{:s} {:s} has an instruction at t={:.10f}s. This instruction collides with a ramp on this output at that time. &quot;</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">description</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">time</span><span class=\"p\">)</span><span class=\"o\">+</span>\n               <span class=\"s2\">&quot;The colliding {:s} is from {:.10f}s till {:.10f}s&quot;</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">inst</span><span class=\"p\">[</span><span class=\"s1\">&#39;description&#39;</span><span class=\"p\">],</span> <span class=\"n\">current_dict_time</span><span class=\"p\">[</span><span class=\"s1\">&#39;initial time&#39;</span><span class=\"p\">],</span> <span class=\"n\">current_dict_time</span><span class=\"p\">[</span><span class=\"s1\">&#39;end time&#39;</span><span class=\"p\">]))</span>\n        <span class=\"k\">raise</span> <span class=\"n\">LabscriptError</span><span class=\"p\">(</span><span class=\"n\">err</span><span class=\"p\">)</span> \n</pre></div>\n\n\n<p>There may be a more efficient way to do this, but we should check this first to avoid premature optimisation. At least this only scales with O(N) rather than O(N^2).</p>\n<hr />\n<p>The shutter collision checking is a lot more complicated. I'm not sure we can actually do it correctly before the proper introduction of the instruction class that keeps track of things. This is because the current Shutter implementation appears broken to me because it assumes that the device starts at t=0, which is not the case for secondary pseudoclocks. Since the original code was broken, the patch in this pull request is also broken because it utilises the same time calculation. I think that calls to shutters within the open/close delay of the pseudoclock trigger, provided that trigger is at least one open/close delay after t=0 will probably raise an exception deep within labscript somewhere.</p>\n<p>I'd like to do this check in <code>get_change_times()</code> as well (override it in the <code>Shutter</code> class) but because we ignore the open/close delay if we are close to t=0, then we can't back-calculate the original request time at that point with the current labscript implementation. We could demand that shutters cannot be commanded prior to <code>output.t0 + output.open_delay</code> or <code>output.t0 + output.close_delay</code> for open/close respectively I suppose?</p>\n<p>Then we could do:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">get_change_times</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"n\">retval</span> <span class=\"o\">=</span> <span class=\"n\">DigitalOut</span><span class=\"o\">.</span><span class=\"n\">get_change_times</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n\n    <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">time</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">times</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">times</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">:</span>\n            <span class=\"n\">next_time</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">times</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n            <span class=\"c1\"># only look at instructions that contain a state change</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">instructions</span><span class=\"p\">[</span><span class=\"n\">time</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">instructions</span><span class=\"p\">[</span><span class=\"n\">next_time</span><span class=\"p\">]:</span>\n                <span class=\"c1\"># calculate original times for these instructions, </span>\n                <span class=\"c1\"># make sure they were not reordered!</span>\n                <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">open_state</span> <span class=\"o\">==</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">instructions</span><span class=\"p\">[</span><span class=\"n\">time</span><span class=\"p\">]:</span>\n                    <span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"n\">time</span><span class=\"o\">+</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">open_delay</span>\n                <span class=\"k\">else</span><span class=\"p\">:</span>\n                    <span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"n\">time</span><span class=\"o\">+</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">close_delay</span>\n\n                <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">open_state</span> <span class=\"o\">==</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">instructions</span><span class=\"p\">[</span><span class=\"n\">next_time</span><span class=\"p\">]:</span>\n                    <span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"n\">next_time</span><span class=\"o\">+</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">open_delay</span>\n                <span class=\"k\">else</span><span class=\"p\">:</span>\n                    <span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"n\">next_time</span><span class=\"o\">+</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">close_delay</span>\n\n                <span class=\"k\">if</span> <span class=\"n\">t2</span> <span class=\"o\">&lt;</span> <span class=\"n\">t1</span><span class=\"p\">:</span>\n                    <span class=\"c1\">#raise appropriately derived error message</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">retval</span>\n</pre></div>\n\n\n<p>This also scales with O(N)</p>\n<p>Not sure if that's too drastic though (the limiting of how early shutters can be opened/closed)?</p>", "type": "rendered"}, "created_on": "2017-06-17T05:22:02.042412+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}, "updated_on": "2017-06-17T05:22:02.044726+00:00", "type": "pullrequest_comment", "id": 39026352}