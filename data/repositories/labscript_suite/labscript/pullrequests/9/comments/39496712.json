{"links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/9/comments/39496712.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/9/_/diff#comment-39496712"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 9, "links": {"self": {"href": "data/repositories/labscript_suite/labscript/pullrequests/9.json"}, "html": {"href": "#!/labscript_suite/labscript/pull-requests/9"}}, "title": "Check ramp collision and shutter delays"}, "content": {"raw": "I've been working on an experimental new timing architecture for labscript 3.0 (for now just to see whether it makes sense, but I'm happy to do this out in the open if people want to see it and comment - so far it's basically the same class hierarchy but with an extra inheritance layer or two, an `Instruction` class and much more explicit stages of when what happens during compilation), and I think the way around this might be to make `t0` (and related things that are currently attributes) a method instead of an attribute, which can take as an argument the child device or `Instruction` class that the question applies to. In this way, different outputs of a device could have different latencies, and different types of `Instruction` objects when given to an `Output` could have different latencies. So you'd implement a `ShutterOpen` and `ShutterClose` subclass of the Instruction class, and a `Shutter` subclass of the `Output` or `DigitalOutput` class (as we have already), and the `Shutter`'s implementation of `t0()` and `trigger_delay()` would return the open delay for one type of instruction and the close delay for the other. (relatedly, I think every device should implement `trigger_delay()` to allow for latencies at every connection - I would rename it `latency` or similar though since it's not necessarily about triggers).\n\nThe default implementations of these methods would not require a child device or instruction to be passed in, and would simply look for a class/instance attribute and return it, which would make things simple when output delays are constant. I could perhaps make the default implementation look for  an attribute which could be *either* a number or a dictionary. If it found the latter, it would error if the user didn't pass in a child device or Instruction class, and then would check for a dictionary entry keyed by `Instruction` classes in the case of an `Instruction`, or by connection string in the case of a child device. Any more sophisticated requirements could be met by reimplementing the method to return delay times based on anything else you like.\n\nThat way you could ask \"What's t0 for a `ShutterOpen` instruction?\", specifically.\n\nSome syntactic sugar for this could be that you pass in a special object called `t0` or `trigger_delay` similar, in place of a time, and the Instruction class's `__init__` method would see this and know to call the parent output's `t0` method with itself as the argument in order to determine the `t` value for that instruction. The type that `t0` and `trigger_delay` (or `total_latency` or whatever it ends up being called) were could grow an `__add__` method (any arithmetic other than adding and subtracting should probably be a `TypeError` unless there's a compelling reason otherwise) to store an offset so that you could pass in `t + trigger_delay` after a wait and have that do something sensible. This is sounding similar to a suggestion @spielman was making in another thread, though it's not the same - I think times should still be floats, but I like some syntactic sugar that is just a shortcut telling the code directly beneath is what methods to call and what offset to apply to get the time you mean.", "markup": "markdown", "html": "<p>I've been working on an experimental new timing architecture for labscript 3.0 (for now just to see whether it makes sense, but I'm happy to do this out in the open if people want to see it and comment - so far it's basically the same class hierarchy but with an extra inheritance layer or two, an <code>Instruction</code> class and much more explicit stages of when what happens during compilation), and I think the way around this might be to make <code>t0</code> (and related things that are currently attributes) a method instead of an attribute, which can take as an argument the child device or <code>Instruction</code> class that the question applies to. In this way, different outputs of a device could have different latencies, and different types of <code>Instruction</code> objects when given to an <code>Output</code> could have different latencies. So you'd implement a <code>ShutterOpen</code> and <code>ShutterClose</code> subclass of the Instruction class, and a <code>Shutter</code> subclass of the <code>Output</code> or <code>DigitalOutput</code> class (as we have already), and the <code>Shutter</code>'s implementation of <code>t0()</code> and <code>trigger_delay()</code> would return the open delay for one type of instruction and the close delay for the other. (relatedly, I think every device should implement <code>trigger_delay()</code> to allow for latencies at every connection - I would rename it <code>latency</code> or similar though since it's not necessarily about triggers).</p>\n<p>The default implementations of these methods would not require a child device or instruction to be passed in, and would simply look for a class/instance attribute and return it, which would make things simple when output delays are constant. I could perhaps make the default implementation look for  an attribute which could be <em>either</em> a number or a dictionary. If it found the latter, it would error if the user didn't pass in a child device or Instruction class, and then would check for a dictionary entry keyed by <code>Instruction</code> classes in the case of an <code>Instruction</code>, or by connection string in the case of a child device. Any more sophisticated requirements could be met by reimplementing the method to return delay times based on anything else you like.</p>\n<p>That way you could ask \"What's t0 for a <code>ShutterOpen</code> instruction?\", specifically.</p>\n<p>Some syntactic sugar for this could be that you pass in a special object called <code>t0</code> or <code>trigger_delay</code> similar, in place of a time, and the Instruction class's <code>__init__</code> method would see this and know to call the parent output's <code>t0</code> method with itself as the argument in order to determine the <code>t</code> value for that instruction. The type that <code>t0</code> and <code>trigger_delay</code> (or <code>total_latency</code> or whatever it ends up being called) were could grow an <code>__add__</code> method (any arithmetic other than adding and subtracting should probably be a <code>TypeError</code> unless there's a compelling reason otherwise) to store an offset so that you could pass in <code>t + trigger_delay</code> after a wait and have that do something sensible. This is sounding similar to a suggestion @spielman was making in another thread, though it's not the same - I think times should still be floats, but I like some syntactic sugar that is just a shortcut telling the code directly beneath is what methods to call and what offset to apply to get the time you mean.</p>", "type": "rendered"}, "created_on": "2017-06-24T23:31:33.224762+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-06-24T23:50:44.280283+00:00", "type": "pullrequest_comment", "id": 39496712}