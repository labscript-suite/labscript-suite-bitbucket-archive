{"priority": "major", "kind": "bug", "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "links": {"attachments": {"href": "data/repositories/labscript_suite/labscript_devices/issues/19/attachments_page=1.json"}, "self": {"href": "data/repositories/labscript_suite/labscript_devices/issues/19.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/issues/19/watch"}, "comments": {"href": "data/repositories/labscript_suite/labscript_devices/issues/19/comments_page=1.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/issues/19/acquisitions-after-wait-do-not-account-for"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/issues/19/vote"}}, "reporter": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "title": "Acquisitions after wait do not account for wait time : USB-6343", "component": null, "votes": 0, "watches": 1, "content": {"raw": "I've attached an example data run that exhibits the problem.\r\n\r\nAfter a 60Hz Trigger the execution resumes as normal. However, it appears the acquisition worker does not account for the wait time and slices out the analog inputs as if it didn't happen. The result is that the data returned by the acquisition no longer corresponds to experiment execution time after a wait making it essentially impossible to get the data desired.\r\n\r\nI think the issue is in the extract_measurements method of the Acquisition worker. It waits to ensure the wait times are calculated, but then does nothing with those times. I don't see a correct implementation in other classes so I'll start working a fix. Unless I'm greatly mistaken, I only need to update extract_measurements to properly account for unknown number of waits at different times?", "markup": "markdown", "html": "<p>I've attached an example data run that exhibits the problem.</p>\n<p>After a 60Hz Trigger the execution resumes as normal. However, it appears the acquisition worker does not account for the wait time and slices out the analog inputs as if it didn't happen. The result is that the data returned by the acquisition no longer corresponds to experiment execution time after a wait making it essentially impossible to get the data desired.</p>\n<p>I think the issue is in the extract_measurements method of the Acquisition worker. It waits to ensure the wait times are calculated, but then does nothing with those times. I don't see a correct implementation in other classes so I'll start working a fix. Unless I'm greatly mistaken, I only need to update extract_measurements to properly account for unknown number of waits at different times?</p>", "type": "rendered"}, "assignee": null, "state": "resolved", "version": null, "edited_on": null, "created_on": "2017-04-26T15:36:10.499787+00:00", "milestone": null, "updated_on": "2017-04-27T04:24:49.703270+00:00", "type": "issue", "id": 19}