{"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/issues/22/comments/48561946.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/issues/22#comment-48561946"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/issues/22.json"}}, "type": "issue", "id": 22, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "title": "Third-Party Devices"}, "content": {"raw": "It does address it somewhat.\n\nSubrepos would work.\n\nAnother option for including in-development devices would be to have `labscript_devices` scan additional directories for 'register_classes.py' files. For example, we could have a path settable in labconfig for where additional devices are located. Or, we could just have all of userlib be scanned (it's not like there's much of a performance hit for this).\n\nI'm eager to have 3rd party devices 'upstreamed', and with the possibility of subrepos, it makes it pretty transparent - such that the developers of the code are in charge of their own code whilst it still being included in mainline. But I think if devices are to be included in mainline labscript that are not maintained by the core developers, I'd prefer to still have one repo, and just allow the maintainers of that code to be in charge of it - reviewing each others' pull requests or whatever, with the core developers just rubber-stamping or raising style issues.\n\nTo get existing device code into mainline, or to have it work either in a subrepo or a separate folder, yes, you'd need to convert it to the 'new' way of doing things with 'register_devices.py' files etc. It makes sense to put a bunch of related devices all in one folder of labscript_devices, the folder structure is free, we should do whatever is sensible. For example the DAQmx code I'm working on is all within one folder, though it is for all DAQmx models and has separate classes for all of them (see [here](#!/cbillington/labscript_devices/src/NI_DAQmx/NI_DAQmx/?at=NI_DAQmx) for what that's looking like). Devices that are not converted to the new way of doing things will only continue to work if they are at the top level of labscript_devices, though of course you're free to re-add your hack to make old-style devices keep working elsewhere. But we will presumably eventually remove this 'old-style' way of looking up devices.\n\nSo how about this:\n\n* We make labscript_devices scan userlib, allowing in-development devices to be developed there, or entirely separate repos of devices to be maintained separately from the labscript_devices repository, if the code is not appropriate to share for whatever reason (though I really want to lower the bar for this - please share, even if the code is not the best quality, it can improve after it is out there. I'm more thinking there's no reason to share code for in-house devices, that sort of thing).\n\n* We agree that it is up to the users of a particular device maintain it, and defer to them to be the judges of how much testing is enough, before merging any given change. Core developers will still do the merging though, unless clicking the merge button in  response to \"this is ready for merging\" comment actually consumes too much of our time. Actually I have been doing all 3rd party merges locally to get around a deficiency in bitbucket, so I would have to share the tools I use to do that before others could do the same, or at least make sure the process is understood, as it's not quite as simple as clicking the merge button.\n\nIn the DAQmx support I'm working on at the moment, I've broken backward compatibility with previous DAQmx device classes, so I added a `__version__` attribute to be able to detect this and raise meaningful errors. In this way we can track the versions of individual labscript devices regardless of them being in the same repository, and we can mark them with a version number less than one if they are not yet considered stable.\n\nAt some point I'll be making a push for automated sphinx documentation from docstrings, at that point we can add extra information to the documentation like: \"who is maintaining this device code?\", \"which labs use this device that are happy to test?\" etc, these sorts of things could aid development as you will know who can test, who you might be breaking compatibility for etc.", "markup": "markdown", "html": "<p>It does address it somewhat.</p>\n<p>Subrepos would work.</p>\n<p>Another option for including in-development devices would be to have <code>labscript_devices</code> scan additional directories for 'register_classes.py' files. For example, we could have a path settable in labconfig for where additional devices are located. Or, we could just have all of userlib be scanned (it's not like there's much of a performance hit for this).</p>\n<p>I'm eager to have 3rd party devices 'upstreamed', and with the possibility of subrepos, it makes it pretty transparent - such that the developers of the code are in charge of their own code whilst it still being included in mainline. But I think if devices are to be included in mainline labscript that are not maintained by the core developers, I'd prefer to still have one repo, and just allow the maintainers of that code to be in charge of it - reviewing each others' pull requests or whatever, with the core developers just rubber-stamping or raising style issues.</p>\n<p>To get existing device code into mainline, or to have it work either in a subrepo or a separate folder, yes, you'd need to convert it to the 'new' way of doing things with 'register_devices.py' files etc. It makes sense to put a bunch of related devices all in one folder of labscript_devices, the folder structure is free, we should do whatever is sensible. For example the DAQmx code I'm working on is all within one folder, though it is for all DAQmx models and has separate classes for all of them (see <a data-is-external-link=\"true\" href=\"#!/cbillington/labscript_devices/src/NI_DAQmx/NI_DAQmx/?at=NI_DAQmx\" rel=\"nofollow\">here</a> for what that's looking like). Devices that are not converted to the new way of doing things will only continue to work if they are at the top level of labscript_devices, though of course you're free to re-add your hack to make old-style devices keep working elsewhere. But we will presumably eventually remove this 'old-style' way of looking up devices.</p>\n<p>So how about this:</p>\n<ul>\n<li>\n<p>We make labscript_devices scan userlib, allowing in-development devices to be developed there, or entirely separate repos of devices to be maintained separately from the labscript_devices repository, if the code is not appropriate to share for whatever reason (though I really want to lower the bar for this - please share, even if the code is not the best quality, it can improve after it is out there. I'm more thinking there's no reason to share code for in-house devices, that sort of thing).</p>\n</li>\n<li>\n<p>We agree that it is up to the users of a particular device maintain it, and defer to them to be the judges of how much testing is enough, before merging any given change. Core developers will still do the merging though, unless clicking the merge button in  response to \"this is ready for merging\" comment actually consumes too much of our time. Actually I have been doing all 3rd party merges locally to get around a deficiency in bitbucket, so I would have to share the tools I use to do that before others could do the same, or at least make sure the process is understood, as it's not quite as simple as clicking the merge button.</p>\n</li>\n</ul>\n<p>In the DAQmx support I'm working on at the moment, I've broken backward compatibility with previous DAQmx device classes, so I added a <code>__version__</code> attribute to be able to detect this and raise meaningful errors. In this way we can track the versions of individual labscript devices regardless of them being in the same repository, and we can mark them with a version number less than one if they are not yet considered stable.</p>\n<p>At some point I'll be making a push for automated sphinx documentation from docstrings, at that point we can add extra information to the documentation like: \"who is maintaining this device code?\", \"which labs use this device that are happy to test?\" etc, these sorts of things could aid development as you will know who can test, who you might be breaking compatibility for etc.</p>", "type": "rendered"}, "created_on": "2018-10-25T14:47:19.227274+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-10-25T15:02:03.984024+00:00", "type": "issue_comment", "id": 48561946}