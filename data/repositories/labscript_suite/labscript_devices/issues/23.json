{"priority": "major", "kind": "bug", "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "links": {"attachments": {"href": "data/repositories/labscript_suite/labscript_devices/issues/23/attachments_page=1.json"}, "self": {"href": "data/repositories/labscript_suite/labscript_devices/issues/23.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/issues/23/watch"}, "comments": {"href": "data/repositories/labscript_suite/labscript_devices/issues/23/comments_page=1.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/issues/23/pulseblaster-with-2323-firmware-turns-off"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/issues/23/vote"}}, "reporter": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "title": "Pulseblaster with 2323 firmware turns off all outputs during programming", "component": null, "votes": 0, "watches": 1, "content": {"raw": "We have two pulseblasters in the lab with firmwares 2323 and 3338. For whatever reason the 2323 firmware version disables all digital outputs when pb_start_programming() is called and it appears they don't re-enable until pb_start(). There isn't really anything we can do about that in particular, but it would be nice if pb_start_programming() wasn't called unnecessarily (for the sake of compatibility with the STOP programming method) so my digital lines could stay high between most of my shots, keeping the experiment warm.\r\n\r\nI'm using the following diff without issue so far. Am I missing any other edge cases?\r\n```\r\n#!diff\r\n\r\n@@ -341,18 +341,13 @@\r\n             pulse_program = group['PULSE_PROGRAM'][2:]\r\n             \r\n             #Let's get the final state of the pulseblaster. z's are the args we don't need:\r\n-            flags,z,z,z = pulse_program[-1]\r\n-            \r\n-            # Always call start_programming regardless of whether we are going to do any\r\n-            # programming or not. This is so that is the programming_scheme is 'pb_stop_programming/STOP'\r\n-            # we are ready to be triggered by a call to pb_stop_programming() even if no programming\r\n-            # occurred due to smart programming:\r\n-            pb_start_programming(PULSE_PROGRAM)\r\n+            flags,z,z,z = pulse_program[-1]                \r\n             \r\n             if fresh or (self.smart_cache['initial_values'] != initial_values) or \\\r\n                 (len(self.smart_cache['pulse_program']) != len(pulse_program)) or \\\r\n                 (self.smart_cache['pulse_program'] != pulse_program).any() or \\\r\n                 not self.smart_cache['ready_to_go']:\r\n+                pb_start_programming(PULSE_PROGRAM)\r\n             \r\n                 self.smart_cache['ready_to_go'] = True\r\n                 self.smart_cache['initial_values'] = initial_values\r\n@@ -385,17 +380,22 @@\r\n                     for args in pulse_program:\r\n                         pb_inst_pbonly(*args)\r\n                         \r\n-            if self.programming_scheme == 'pb_start/BRANCH':\r\n-                # We will be triggered by pb_start() if we are are the master pseudoclock or a single hardware trigger\r\n-                # from the master if we are not:\r\n-                pb_stop_programming()\r\n+                if self.programming_scheme == 'pb_start/BRANCH':\r\n+                    # We will be triggered by pb_start() if we are are the master pseudoclock or a single hardware trigger\r\n+                    # from the master if we are not:\r\n+                    pb_stop_programming()\r\n+                elif self.programming_scheme == 'pb_stop_programming/STOP':\r\n+                    # Don't call pb_stop_programming(). We don't want to pulseblaster to respond to hardware\r\n+                    # triggers (such as 50/60Hz line triggers) until we are ready to run.\r\n+                    # Our start_method will call pb_stop_programming() when we are ready\r\n+                    pass\r\n+                else:\r\n+                    raise ValueError('invalid programming_scheme %s'%str(self.programming_scheme))\r\n             elif self.programming_scheme == 'pb_stop_programming/STOP':\r\n-                # Don't call pb_stop_programming(). We don't want to pulseblaster to respond to hardware\r\n-                # triggers (such as 50/60Hz line triggers) until we are ready to run.\r\n-                # Our start_method will call pb_stop_programming() when we are ready\r\n-                pass\r\n-            else:\r\n-                raise ValueError('invalid programming_scheme %s'%str(self.programming_scheme))\r\n+                # Ensure start_programming called if the programming_scheme is 'pb_stop_programming/STOP'\r\n+                # so we are ready to be triggered by a call to pb_stop_programming() \r\n+                # even if no programming occurred due to smart programming:\r\n+                pb_start_programming(PULSE_PROGRAM)\r\n             \r\n             # Are there waits in use in this experiment? The monitor waiting for the end of\r\n             # the experiment will need to know:\r\n\r\n```", "markup": "markdown", "html": "<p>We have two pulseblasters in the lab with firmwares 2323 and 3338. For whatever reason the 2323 firmware version disables all digital outputs when pb_start_programming() is called and it appears they don't re-enable until pb_start(). There isn't really anything we can do about that in particular, but it would be nice if pb_start_programming() wasn't called unnecessarily (for the sake of compatibility with the STOP programming method) so my digital lines could stay high between most of my shots, keeping the experiment warm.</p>\n<p>I'm using the following diff without issue so far. Am I missing any other edge cases?</p>\n<div class=\"codehilite language-diff\"><pre><span></span><span class=\"gu\">@@ -341,18 +341,13 @@</span>\n             pulse_program = group[&#39;PULSE_PROGRAM&#39;][2:]\n\n             #Let&#39;s get the final state of the pulseblaster. z&#39;s are the args we don&#39;t need:\n<span class=\"gd\">-            flags,z,z,z = pulse_program[-1]</span>\n<span class=\"gd\">-            </span>\n<span class=\"gd\">-            # Always call start_programming regardless of whether we are going to do any</span>\n<span class=\"gd\">-            # programming or not. This is so that is the programming_scheme is &#39;pb_stop_programming/STOP&#39;</span>\n<span class=\"gd\">-            # we are ready to be triggered by a call to pb_stop_programming() even if no programming</span>\n<span class=\"gd\">-            # occurred due to smart programming:</span>\n<span class=\"gd\">-            pb_start_programming(PULSE_PROGRAM)</span>\n<span class=\"gi\">+            flags,z,z,z = pulse_program[-1]                </span>\n\n             if fresh or (self.smart_cache[&#39;initial_values&#39;] != initial_values) or \\\n                 (len(self.smart_cache[&#39;pulse_program&#39;]) != len(pulse_program)) or \\\n                 (self.smart_cache[&#39;pulse_program&#39;] != pulse_program).any() or \\\n                 not self.smart_cache[&#39;ready_to_go&#39;]:\n<span class=\"gi\">+                pb_start_programming(PULSE_PROGRAM)</span>\n\n                 self.smart_cache[&#39;ready_to_go&#39;] = True\n                 self.smart_cache[&#39;initial_values&#39;] = initial_values\n<span class=\"gu\">@@ -385,17 +380,22 @@</span>\n                     for args in pulse_program:\n                         pb_inst_pbonly(*args)\n\n<span class=\"gd\">-            if self.programming_scheme == &#39;pb_start/BRANCH&#39;:</span>\n<span class=\"gd\">-                # We will be triggered by pb_start() if we are are the master pseudoclock or a single hardware trigger</span>\n<span class=\"gd\">-                # from the master if we are not:</span>\n<span class=\"gd\">-                pb_stop_programming()</span>\n<span class=\"gi\">+                if self.programming_scheme == &#39;pb_start/BRANCH&#39;:</span>\n<span class=\"gi\">+                    # We will be triggered by pb_start() if we are are the master pseudoclock or a single hardware trigger</span>\n<span class=\"gi\">+                    # from the master if we are not:</span>\n<span class=\"gi\">+                    pb_stop_programming()</span>\n<span class=\"gi\">+                elif self.programming_scheme == &#39;pb_stop_programming/STOP&#39;:</span>\n<span class=\"gi\">+                    # Don&#39;t call pb_stop_programming(). We don&#39;t want to pulseblaster to respond to hardware</span>\n<span class=\"gi\">+                    # triggers (such as 50/60Hz line triggers) until we are ready to run.</span>\n<span class=\"gi\">+                    # Our start_method will call pb_stop_programming() when we are ready</span>\n<span class=\"gi\">+                    pass</span>\n<span class=\"gi\">+                else:</span>\n<span class=\"gi\">+                    raise ValueError(&#39;invalid programming_scheme %s&#39;%str(self.programming_scheme))</span>\n             elif self.programming_scheme == &#39;pb_stop_programming/STOP&#39;:\n<span class=\"gd\">-                # Don&#39;t call pb_stop_programming(). We don&#39;t want to pulseblaster to respond to hardware</span>\n<span class=\"gd\">-                # triggers (such as 50/60Hz line triggers) until we are ready to run.</span>\n<span class=\"gd\">-                # Our start_method will call pb_stop_programming() when we are ready</span>\n<span class=\"gd\">-                pass</span>\n<span class=\"gd\">-            else:</span>\n<span class=\"gd\">-                raise ValueError(&#39;invalid programming_scheme %s&#39;%str(self.programming_scheme))</span>\n<span class=\"gi\">+                # Ensure start_programming called if the programming_scheme is &#39;pb_stop_programming/STOP&#39;</span>\n<span class=\"gi\">+                # so we are ready to be triggered by a call to pb_stop_programming() </span>\n<span class=\"gi\">+                # even if no programming occurred due to smart programming:</span>\n<span class=\"gi\">+                pb_start_programming(PULSE_PROGRAM)</span>\n\n             # Are there waits in use in this experiment? The monitor waiting for the end of\n             # the experiment will need to know:\n</pre></div>", "type": "rendered"}, "assignee": null, "state": "new", "version": null, "edited_on": null, "created_on": "2017-10-20T20:22:45.698736+00:00", "milestone": null, "updated_on": "2017-10-20T20:22:45.698736+00:00", "type": "issue", "id": 23}