{"priority": "minor", "kind": "enhancement", "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "links": {"attachments": {"href": "data/repositories/labscript_suite/labscript_devices/issues/24/attachments_page=1.json"}, "self": {"href": "data/repositories/labscript_suite/labscript_devices/issues/24.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/issues/24/watch"}, "comments": {"href": "data/repositories/labscript_suite/labscript_devices/issues/24/comments_page=1.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/issues/24/backwards-compatible-connection-table"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/issues/24/vote"}}, "reporter": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}, "title": "Backwards compatible connection table comparisons between different versions", "component": null, "votes": 0, "watches": 1, "content": {"raw": "As discussed in [labscript_devices pull request 27](#!/labscript_suite/labscript_devices/pull-requests/27/novatech-synchronous-workaround/) and [labscript issue 45](#!/labscript_suite/labscript/issues/45/restructure-properties-and-blacs) we would like a way to ensure that new connection_table_properties in devices does not invalidate connection tables if possible.\r\n\r\nI think that this may be best solved by a new class in each labscript_devices device file that can be invoked by connection table comparison code in order to determine whether a connection_table_properties dictionary is identical if it was compiled with a different version of labscript_devices.\r\n\r\nThis would also require storing the labscript suite versions used when producing the connection table as attributes to the connection table.\r\n\r\nIt also requires development of some sort of syntax (maybe a dictionary structure of some kind?) that allows us to keep track of changes between different versions of labscript_devices and informs how comparisons should be made. This will probably have to evolve with time as we come across new use cases, but I don't see a problem with that. It might sound complicated, but I think it's doable (as similar/tangential example, the Django project has an automated tool that keeps track of database schema changes and can roll database schemas forward/backward in time which sounds way more complicated than this!)", "markup": "markdown", "html": "<p>As discussed in <a data-is-external-link=\"true\" href=\"#!/labscript_suite/labscript_devices/pull-requests/27/novatech-synchronous-workaround/\" rel=\"nofollow\">labscript_devices pull request 27</a> and <a data-is-external-link=\"true\" href=\"#!/labscript_suite/labscript/issues/45/restructure-properties-and-blacs\" rel=\"nofollow\">labscript issue 45</a> we would like a way to ensure that new connection_table_properties in devices does not invalidate connection tables if possible.</p>\n<p>I think that this may be best solved by a new class in each labscript_devices device file that can be invoked by connection table comparison code in order to determine whether a connection_table_properties dictionary is identical if it was compiled with a different version of labscript_devices.</p>\n<p>This would also require storing the labscript suite versions used when producing the connection table as attributes to the connection table.</p>\n<p>It also requires development of some sort of syntax (maybe a dictionary structure of some kind?) that allows us to keep track of changes between different versions of labscript_devices and informs how comparisons should be made. This will probably have to evolve with time as we come across new use cases, but I don't see a problem with that. It might sound complicated, but I think it's doable (as similar/tangential example, the Django project has an automated tool that keeps track of database schema changes and can roll database schemas forward/backward in time which sounds way more complicated than this!)</p>", "type": "rendered"}, "assignee": null, "state": "new", "version": null, "edited_on": null, "created_on": "2018-03-12T23:36:30.942554+00:00", "milestone": null, "updated_on": "2018-03-12T23:59:56.437204+00:00", "type": "issue", "id": 24}