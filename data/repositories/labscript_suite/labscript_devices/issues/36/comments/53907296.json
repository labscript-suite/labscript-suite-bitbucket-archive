{"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/issues/36/comments/53907296.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/issues/36#comment-53907296"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/issues/36.json"}}, "type": "issue", "id": 36, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "title": "BLACS hang with continuous camera acquisitions"}, "content": {"raw": "Sorry again for not seeing this, I think you must be correct that if you use the email response feature, bitbucket sends no notifications. Oh well, we'll be on github soon enough :p.\n\nThese results give some leads!\n\n`inmain_later` queues up a function call to occur in the main thread, and returns a `queue.Queue` object that the result of the function call (or an exception) will be put to once the function in the main thread runs. It does this by posting a custom Qt event (`qtutils.invoke_in_main.CallEvent`) that holds the function, its args, and the `Queue` that the response should be posted to. A custom event handler (`qtutils.invoke_in_main.Caller`) runs in the main thread and handles the event by calling the function and putting the result to the `Queue`. So each call to `self.update_event.get(timeout=0.1)` is waiting for the previously requested function to run in the main thread, and this is supposed to prevent a backlog. If we just called `inmain_later` without waiting for the result at any point, we definitely would get a backlog there.\n\nThe fact that your logging keeps saying \"Update event cleared\" implies that the `update()` function *is running* and looks like it keeping up. This makes me think the backlog is downstream from that, for example, perhaps `image_view.setImage()` queues up something to happen later, and is not fully synchronous.\n\nTo confirm this, you could:\n\n* comment out the line that actually does the update: `self.image_view.setImage(image.T, autoRange=False, autoLevels=False)`. If the backlog is upstream of this, it should still occur. If the backlog is downstream of this, it might stop occurring.\n* Make the call to `ImageReceiver.update()` synchonous by replacing inmain_later with inmain:\n\n```diff\ndiff -r ce230bf8846b IMAQdxCamera/blacs_tabs.py\n--- a/IMAQdxCamera/blacs_tabs.py        Mon Aug 26 16:13:28 2019 -0400\n+++ b/IMAQdxCamera/blacs_tabs.py        Sat Sep 14 16:37:52 2019 -0400\n@@ -22,7 +22,7 @@\n\n import numpy as np\n\n-from qtutils import UiLoader, inmain_later\n+from qtutils import UiLoader, inmain_later, inmain\n import qtutils.icons\n from qtutils.qt import QtWidgets, QtGui, QtCore\n import pyqtgraph as pg\n@@ -71,19 +71,7 @@\n             else:\n                 self.frame_rate = 1 / dt\n         self.last_frame_time = this_frame_time\n-        # Wait for the previous update to compete so we don't accumulate a backlog:\n-        if self.update_event is not None:\n-            while True:\n-                # Don't block, and check for self.stopping regularly in case we are\n-                # shutting down. Otherwise if shutdown is called from the main thread we\n-                # would deadlock.\n-                try:\n-                    self.update_event.get(timeout=0.1)\n-                    break\n-                except Empty:\n-                    if self.stopping:\n-                        return\n-        self.update_event = inmain_later(self.update, image, self.frame_rate)\n+        inmain(self.update, image, self.frame_rate)\n         return [b'ok']\n\n     def update(self, image, frame_rate):\n```\n\nThis will wait for the `update()` function to run in the main thread before continuing. If the issue is downstream in the pyqtgraph method calls, then it might still occur. However, this change may decrease the attainable frame rate since it delays sending 'ok' back to the sender, so it might make the problem go away solely due to the decreased frame rate and not actually fixing any underlying problem.\n\nAnother thing that might hint at where the backlog is is turning on our Python memory profiler, which saves lists of how many of each type of object there is in the interpreter. It can be used as follows:\n\n```python\nimport labscript_utils.memprof as memprof\n# Do this once to get a baseline of number of objects of each\n# type - ideally this should be called during normal usage, i.e. not at\n# BLACS startup, but before memory has ballooned. Maybe have it\n# called the first time ImageReceiver.handler() runs for example.\nmemprof.start(filepath='<some_filepath>')\n# Arrange to call this when the memory has ballooned,\n# for example after 1000 images if that is a reliable\n# number for reproducing the bug:\nmemprof.check()\n```\nThe result will then be a file at <some_filepath> containing the increase in the number of each type of object in the interpreter between the `start()` and `check()` calls.\n\nThere is also the BLACS `memory` plugin that adds menu entries to BLACS that will call memprof's start and check functions, but since the GUI won't be functioning at that point I think the plugin won't be much use!\n\nIf the objects in memfprof's output file are all qtutils `CallEvent`s and numpy arrays of image data, that would be evidence that our posting of events to the main thread might be the culprit (though I think the evidence is mostly against that explanation). If the objects are all things from pyqtgraph, then perhaps pyqtgraph is delaying updates of its own and a backlog is accumulating there.\n\nI think when I tried to reproduce the bug I was not running the latest pyqtgraph from github, whereas I think you were. Maybe something has changed and I should have another go at reproducing the problem.", "markup": "markdown", "html": "<p>Sorry again for not seeing this, I think you must be correct that if you use the email response feature, bitbucket sends no notifications. Oh well, we'll be on github soon enough :p.</p>\n<p>These results give some leads!</p>\n<p><code>inmain_later</code> queues up a function call to occur in the main thread, and returns a <code>queue.Queue</code> object that the result of the function call (or an exception) will be put to once the function in the main thread runs. It does this by posting a custom Qt event (<code>qtutils.invoke_in_main.CallEvent</code>) that holds the function, its args, and the <code>Queue</code> that the response should be posted to. A custom event handler (<code>qtutils.invoke_in_main.Caller</code>) runs in the main thread and handles the event by calling the function and putting the result to the <code>Queue</code>. So each call to <code>self.update_event.get(timeout=0.1)</code> is waiting for the previously requested function to run in the main thread, and this is supposed to prevent a backlog. If we just called <code>inmain_later</code> without waiting for the result at any point, we definitely would get a backlog there.</p>\n<p>The fact that your logging keeps saying \"Update event cleared\" implies that the <code>update()</code> function <em>is running</em> and looks like it keeping up. This makes me think the backlog is downstream from that, for example, perhaps <code>image_view.setImage()</code> queues up something to happen later, and is not fully synchronous.</p>\n<p>To confirm this, you could:</p>\n<ul>\n<li>comment out the line that actually does the update: <code>self.image_view.setImage(image.T, autoRange=False, autoLevels=False)</code>. If the backlog is upstream of this, it should still occur. If the backlog is downstream of this, it might stop occurring.</li>\n<li>Make the call to <code>ImageReceiver.update()</code> synchonous by replacing inmain_later with inmain:</li>\n</ul>\n<div class=\"codehilite language-diff\"><pre><span></span><span class=\"gh\">diff -r ce230bf8846b IMAQdxCamera/blacs_tabs.py</span>\n<span class=\"gd\">--- a/IMAQdxCamera/blacs_tabs.py        Mon Aug 26 16:13:28 2019 -0400</span>\n<span class=\"gi\">+++ b/IMAQdxCamera/blacs_tabs.py        Sat Sep 14 16:37:52 2019 -0400</span>\n<span class=\"gu\">@@ -22,7 +22,7 @@</span>\n\n import numpy as np\n\n<span class=\"gd\">-from qtutils import UiLoader, inmain_later</span>\n<span class=\"gi\">+from qtutils import UiLoader, inmain_later, inmain</span>\n import qtutils.icons\n from qtutils.qt import QtWidgets, QtGui, QtCore\n import pyqtgraph as pg\n<span class=\"gu\">@@ -71,19 +71,7 @@</span>\n             else:\n                 self.frame_rate = 1 / dt\n         self.last_frame_time = this_frame_time\n<span class=\"gd\">-        # Wait for the previous update to compete so we don&#39;t accumulate a backlog:</span>\n<span class=\"gd\">-        if self.update_event is not None:</span>\n<span class=\"gd\">-            while True:</span>\n<span class=\"gd\">-                # Don&#39;t block, and check for self.stopping regularly in case we are</span>\n<span class=\"gd\">-                # shutting down. Otherwise if shutdown is called from the main thread we</span>\n<span class=\"gd\">-                # would deadlock.</span>\n<span class=\"gd\">-                try:</span>\n<span class=\"gd\">-                    self.update_event.get(timeout=0.1)</span>\n<span class=\"gd\">-                    break</span>\n<span class=\"gd\">-                except Empty:</span>\n<span class=\"gd\">-                    if self.stopping:</span>\n<span class=\"gd\">-                        return</span>\n<span class=\"gd\">-        self.update_event = inmain_later(self.update, image, self.frame_rate)</span>\n<span class=\"gi\">+        inmain(self.update, image, self.frame_rate)</span>\n         return [b&#39;ok&#39;]\n\n     def update(self, image, frame_rate):\n</pre></div>\n\n\n<p>This will wait for the <code>update()</code> function to run in the main thread before continuing. If the issue is downstream in the pyqtgraph method calls, then it might still occur. However, this change may decrease the attainable frame rate since it delays sending 'ok' back to the sender, so it might make the problem go away solely due to the decreased frame rate and not actually fixing any underlying problem.</p>\n<p>Another thing that might hint at where the backlog is is turning on our Python memory profiler, which saves lists of how many of each type of object there is in the interpreter. It can be used as follows:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">labscript_utils.memprof</span> <span class=\"kn\">as</span> <span class=\"nn\">memprof</span>\n<span class=\"c1\"># Do this once to get a baseline of number of objects of each</span>\n<span class=\"c1\"># type - ideally this should be called during normal usage, i.e. not at</span>\n<span class=\"c1\"># BLACS startup, but before memory has ballooned. Maybe have it</span>\n<span class=\"c1\"># called the first time ImageReceiver.handler() runs for example.</span>\n<span class=\"n\">memprof</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">(</span><span class=\"n\">filepath</span><span class=\"o\">=</span><span class=\"s1\">&#39;&lt;some_filepath&gt;&#39;</span><span class=\"p\">)</span>\n<span class=\"c1\"># Arrange to call this when the memory has ballooned,</span>\n<span class=\"c1\"># for example after 1000 images if that is a reliable</span>\n<span class=\"c1\"># number for reproducing the bug:</span>\n<span class=\"n\">memprof</span><span class=\"o\">.</span><span class=\"n\">check</span><span class=\"p\">()</span>\n</pre></div>\n\n\n<p>The result will then be a file at &lt;some_filepath&gt; containing the increase in the number of each type of object in the interpreter between the <code>start()</code> and <code>check()</code> calls.</p>\n<p>There is also the BLACS <code>memory</code> plugin that adds menu entries to BLACS that will call memprof's start and check functions, but since the GUI won't be functioning at that point I think the plugin won't be much use!</p>\n<p>If the objects in memfprof's output file are all qtutils <code>CallEvent</code>s and numpy arrays of image data, that would be evidence that our posting of events to the main thread might be the culprit (though I think the evidence is mostly against that explanation). If the objects are all things from pyqtgraph, then perhaps pyqtgraph is delaying updates of its own and a backlog is accumulating there.</p>\n<p>I think when I tried to reproduce the bug I was not running the latest pyqtgraph from github, whereas I think you were. Maybe something has changed and I should have another go at reproducing the problem.</p>", "type": "rendered"}, "created_on": "2019-09-14T21:04:29.766530+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": null, "type": "issue_comment", "id": 53907296}