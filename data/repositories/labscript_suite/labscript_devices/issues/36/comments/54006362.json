{"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/issues/36/comments/54006362.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/issues/36#comment-54006362"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/issues/36.json"}}, "type": "issue", "id": 36, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "title": "BLACS hang with continuous camera acquisitions"}, "content": {"raw": "Ok, I'm also on a Windows 7 computer with the same versions of everything and not seeing it :/\n\nThen again, this computer is not very fast. I'm struggling to get high frame rates even with fully pre-generated data. Perhaps this bug requires a faster computer to be triggered, maybe something about the screen refresh rate as Phil has mentioned.\n\n\nSo I guess we're still debugging on your setup. Here is attempt at a solution number 1, based on the hypothesis that it's a backlog of paint events that we can prevent by deprioritising our events:\n\nIf you replace `_inmain_later()` in your locally-installed `qtutils/invoke_in_main.py` with the following:\n\n```python\ndef _in_main_later(fn, exceptions_in_main, *args, **kwargs):\n    \"\"\"Asks the mainloop to call a function when it has time. Immediately returns the\n    queue that was sent to the mainloop.  A call to queue.get() will return a list of\n    [result,exception] where exception=[type,value,traceback] of the exception. The\n    keyword argument _priority can be used to pass the event priority to the postEvent()\n    call. Functions of the same priority are guaranteed to be called in the order they\n    were requested.\"\"\"\n    queue = Queue()\n    post_kwargs = {}\n    if '_priority' in kwargs:\n        post_kwargs['priority'] = kwargs.pop('_priority')\n    QCoreApplication.postEvent(\n        caller, CallEvent(queue, exceptions_in_main, fn, *args, **kwargs), **post_kwargs\n    )\n    return queue\n```\n\nAnd change the inmain_later call in blacs_tabs.py to:\n\n```python\n self.update_event = inmain_later(self.update, image, self.frame_rate, _priority=QtCore.Qt.LowEventPriority - 1)\n```\n\ndoes that solve the problem?\n\n\nAttempt at a solution number two. If you append:\n```python\nQtGui.QApplication.instance().sendPostedEvents()\n```\n\nto the end of `ImageReceiver.update()`, does that solve the problem? This is also based on the hypothesis of a backlog of other events, and we're hoping `sendPostedEvents` will process them all immediately. This is pretty hacky but could be informative.\n\n\nAnd, attempt at a solution number three. I'm not super convinced that changing the call to `inmain()` is a satisfactory solution since all that does is `inmain_later()` followed by a `.get()` on the resulting queue, so it is basically the same except that the `.get()` is immediate instead of just before the next call.\n\nWe can't just get rid of waiting on the queue manually since we need to be checking `self.stopping` regularly to avoid the possibility of a deadlock upon tab restart, but we could manually `.get()` from the queue immediately instead of waiting until just before the next event. Leaving it until the last second was just a way of speeding up the max frame rate slightly by allowing the worker to send the next frame prior to the previous one being rendered. \n\nBut it sounds like that will make the problem go away, maybe just for timing reasons, even though I'm not convinced it addresses whatever the root cause is.\n\nSo if nothing else presents itself about solving this issue and if I continue to be unable to reproduce it, maybe the following patch is the pragmatic way forward. It's dissatisfying though, and will probably limit the achievable frame rates of other cameras:\n\n```diff\ndiff -r ce230bf8846b IMAQdxCamera/blacs_tabs.py\n--- a/IMAQdxCamera/blacs_tabs.py        Mon Aug 26 16:13:28 2019 -0400\n+++ b/IMAQdxCamera/blacs_tabs.py        Fri Sep 20 16:30:57 2019 -0400\n@@ -56,7 +56,6 @@\n         self.label_fps = label_fps\n         self.last_frame_time = None\n         self.frame_rate = None\n-        self.update_event = None\n\n     def handler(self, data):\n         md = json.loads(data[0])\n@@ -71,19 +70,18 @@\n             else:\n                 self.frame_rate = 1 / dt\n         self.last_frame_time = this_frame_time\n-        # Wait for the previous update to compete so we don't accumulate a backlog:\n-        if self.update_event is not None:\n-            while True:\n-                # Don't block, and check for self.stopping regularly in case we are\n-                # shutting down. Otherwise if shutdown is called from the main thread we\n-                # would deadlock.\n-                try:\n-                    self.update_event.get(timeout=0.1)\n-                    break\n-                except Empty:\n-                    if self.stopping:\n-                        return\n-        self.update_event = inmain_later(self.update, image, self.frame_rate)\n+        update_event = inmain_later(self.update, image, self.frame_rate)\n+        # Wait for the update to compete so we don't accumulate a backlog:\n+        while True:\n+            # Don't block, and check for self.stopping regularly in case we are\n+            # shutting down. Otherwise if shutdown is called from the main thread we\n+            # would deadlock.\n+            try:\n+                update_event.get(timeout=0.1)\n+                break\n+            except Empty:\n+                if self.stopping:\n+                    return\n         return [b'ok']\n\n     def update(self, image, frame_rate):\n```", "markup": "markdown", "html": "<p>Ok, I'm also on a Windows 7 computer with the same versions of everything and not seeing it :/</p>\n<p>Then again, this computer is not very fast. I'm struggling to get high frame rates even with fully pre-generated data. Perhaps this bug requires a faster computer to be triggered, maybe something about the screen refresh rate as Phil has mentioned.</p>\n<p>So I guess we're still debugging on your setup. Here is attempt at a solution number 1, based on the hypothesis that it's a backlog of paint events that we can prevent by deprioritising our events:</p>\n<p>If you replace <code>_inmain_later()</code> in your locally-installed <code>qtutils/invoke_in_main.py</code> with the following:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">_in_main_later</span><span class=\"p\">(</span><span class=\"n\">fn</span><span class=\"p\">,</span> <span class=\"n\">exceptions_in_main</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Asks the mainloop to call a function when it has time. Immediately returns the</span>\n<span class=\"sd\">    queue that was sent to the mainloop.  A call to queue.get() will return a list of</span>\n<span class=\"sd\">    [result,exception] where exception=[type,value,traceback] of the exception. The</span>\n<span class=\"sd\">    keyword argument _priority can be used to pass the event priority to the postEvent()</span>\n<span class=\"sd\">    call. Functions of the same priority are guaranteed to be called in the order they</span>\n<span class=\"sd\">    were requested.&quot;&quot;&quot;</span>\n    <span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"n\">Queue</span><span class=\"p\">()</span>\n    <span class=\"n\">post_kwargs</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n    <span class=\"k\">if</span> <span class=\"s1\">&#39;_priority&#39;</span> <span class=\"ow\">in</span> <span class=\"n\">kwargs</span><span class=\"p\">:</span>\n        <span class=\"n\">post_kwargs</span><span class=\"p\">[</span><span class=\"s1\">&#39;priority&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">kwargs</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"s1\">&#39;_priority&#39;</span><span class=\"p\">)</span>\n    <span class=\"n\">QCoreApplication</span><span class=\"o\">.</span><span class=\"n\">postEvent</span><span class=\"p\">(</span>\n        <span class=\"n\">caller</span><span class=\"p\">,</span> <span class=\"n\">CallEvent</span><span class=\"p\">(</span><span class=\"n\">queue</span><span class=\"p\">,</span> <span class=\"n\">exceptions_in_main</span><span class=\"p\">,</span> <span class=\"n\">fn</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">),</span> <span class=\"o\">**</span><span class=\"n\">post_kwargs</span>\n    <span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">queue</span>\n</pre></div>\n\n\n<p>And change the inmain_later call in blacs_tabs.py to:</p>\n<div class=\"codehilite language-python\"><pre><span></span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">update_event</span> <span class=\"o\">=</span> <span class=\"n\">inmain_later</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">update</span><span class=\"p\">,</span> <span class=\"n\">image</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">frame_rate</span><span class=\"p\">,</span> <span class=\"n\">_priority</span><span class=\"o\">=</span><span class=\"n\">QtCore</span><span class=\"o\">.</span><span class=\"n\">Qt</span><span class=\"o\">.</span><span class=\"n\">LowEventPriority</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>does that solve the problem?</p>\n<p>Attempt at a solution number two. If you append:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"n\">QtGui</span><span class=\"o\">.</span><span class=\"n\">QApplication</span><span class=\"o\">.</span><span class=\"n\">instance</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">sendPostedEvents</span><span class=\"p\">()</span>\n</pre></div>\n\n\n<p>to the end of <code>ImageReceiver.update()</code>, does that solve the problem? This is also based on the hypothesis of a backlog of other events, and we're hoping <code>sendPostedEvents</code> will process them all immediately. This is pretty hacky but could be informative.</p>\n<p>And, attempt at a solution number three. I'm not super convinced that changing the call to <code>inmain()</code> is a satisfactory solution since all that does is <code>inmain_later()</code> followed by a <code>.get()</code> on the resulting queue, so it is basically the same except that the <code>.get()</code> is immediate instead of just before the next call.</p>\n<p>We can't just get rid of waiting on the queue manually since we need to be checking <code>self.stopping</code> regularly to avoid the possibility of a deadlock upon tab restart, but we could manually <code>.get()</code> from the queue immediately instead of waiting until just before the next event. Leaving it until the last second was just a way of speeding up the max frame rate slightly by allowing the worker to send the next frame prior to the previous one being rendered. </p>\n<p>But it sounds like that will make the problem go away, maybe just for timing reasons, even though I'm not convinced it addresses whatever the root cause is.</p>\n<p>So if nothing else presents itself about solving this issue and if I continue to be unable to reproduce it, maybe the following patch is the pragmatic way forward. It's dissatisfying though, and will probably limit the achievable frame rates of other cameras:</p>\n<div class=\"codehilite language-diff\"><pre><span></span><span class=\"gh\">diff -r ce230bf8846b IMAQdxCamera/blacs_tabs.py</span>\n<span class=\"gd\">--- a/IMAQdxCamera/blacs_tabs.py        Mon Aug 26 16:13:28 2019 -0400</span>\n<span class=\"gi\">+++ b/IMAQdxCamera/blacs_tabs.py        Fri Sep 20 16:30:57 2019 -0400</span>\n<span class=\"gu\">@@ -56,7 +56,6 @@</span>\n         self.label_fps = label_fps\n         self.last_frame_time = None\n         self.frame_rate = None\n<span class=\"gd\">-        self.update_event = None</span>\n\n     def handler(self, data):\n         md = json.loads(data[0])\n<span class=\"gu\">@@ -71,19 +70,18 @@</span>\n             else:\n                 self.frame_rate = 1 / dt\n         self.last_frame_time = this_frame_time\n<span class=\"gd\">-        # Wait for the previous update to compete so we don&#39;t accumulate a backlog:</span>\n<span class=\"gd\">-        if self.update_event is not None:</span>\n<span class=\"gd\">-            while True:</span>\n<span class=\"gd\">-                # Don&#39;t block, and check for self.stopping regularly in case we are</span>\n<span class=\"gd\">-                # shutting down. Otherwise if shutdown is called from the main thread we</span>\n<span class=\"gd\">-                # would deadlock.</span>\n<span class=\"gd\">-                try:</span>\n<span class=\"gd\">-                    self.update_event.get(timeout=0.1)</span>\n<span class=\"gd\">-                    break</span>\n<span class=\"gd\">-                except Empty:</span>\n<span class=\"gd\">-                    if self.stopping:</span>\n<span class=\"gd\">-                        return</span>\n<span class=\"gd\">-        self.update_event = inmain_later(self.update, image, self.frame_rate)</span>\n<span class=\"gi\">+        update_event = inmain_later(self.update, image, self.frame_rate)</span>\n<span class=\"gi\">+        # Wait for the update to compete so we don&#39;t accumulate a backlog:</span>\n<span class=\"gi\">+        while True:</span>\n<span class=\"gi\">+            # Don&#39;t block, and check for self.stopping regularly in case we are</span>\n<span class=\"gi\">+            # shutting down. Otherwise if shutdown is called from the main thread we</span>\n<span class=\"gi\">+            # would deadlock.</span>\n<span class=\"gi\">+            try:</span>\n<span class=\"gi\">+                update_event.get(timeout=0.1)</span>\n<span class=\"gi\">+                break</span>\n<span class=\"gi\">+            except Empty:</span>\n<span class=\"gi\">+                if self.stopping:</span>\n<span class=\"gi\">+                    return</span>\n         return [b&#39;ok&#39;]\n\n     def update(self, image, frame_rate):\n</pre></div>", "type": "rendered"}, "created_on": "2019-09-20T20:36:06.701210+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": null, "type": "issue_comment", "id": 54006362}