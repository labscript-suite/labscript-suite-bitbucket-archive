{"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39279167.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39279167"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "We are very interested in having a unified NI-DAQmx interface to help us maintain code for DAQ devices not in the main labscript repository so I will be happy to do some testing. I have easy access to a USB-6229, USB-6343, PXI-6259 and PXI-6733. As far as testing goes, is the idea to test both NI_DAQmx and the modifications to the original DAQ board classes?\n\nI already have a question about the error handling on line 185 of NI_DAQmx.py that enforces an even number of AO/DO/AI channels: Is that intentional? I thought the even samples limitation only applied to Analog outputs on the 6733 board.\n\nAssuming I am mis-informed, I agree the current counting mechanism allows for odd numbers in channel subsets. Maybe a better option would be to count using the dictionaries populated from the child_devices list on line 112, leaving something like\n\n```\n#!python\n\nif len(analogs) % 2 or len(digitals) % 2 or len(inputs) %2:\n    raise LabscriptError('...')\n```\n", "markup": "markdown", "html": "<p>We are very interested in having a unified NI-DAQmx interface to help us maintain code for DAQ devices not in the main labscript repository so I will be happy to do some testing. I have easy access to a USB-6229, USB-6343, PXI-6259 and PXI-6733. As far as testing goes, is the idea to test both NI_DAQmx and the modifications to the original DAQ board classes?</p>\n<p>I already have a question about the error handling on line 185 of NI_DAQmx.py that enforces an even number of AO/DO/AI channels: Is that intentional? I thought the even samples limitation only applied to Analog outputs on the 6733 board.</p>\n<p>Assuming I am mis-informed, I agree the current counting mechanism allows for odd numbers in channel subsets. Maybe a better option would be to count using the dictionaries populated from the child_devices list on line 112, leaving something like</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">analogs</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"ow\">or</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">digitals</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"ow\">or</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">inputs</span><span class=\"p\">)</span> <span class=\"o\">%</span><span class=\"mi\">2</span><span class=\"p\">:</span>\n    <span class=\"k\">raise</span> <span class=\"n\">LabscriptError</span><span class=\"p\">(</span><span class=\"s1\">&#39;...&#39;</span><span class=\"p\">)</span>\n</pre></div>", "type": "rendered"}, "created_on": "2017-06-21T13:28:56.563659+00:00", "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "updated_on": "2017-06-21T13:28:56.651484+00:00", "type": "pullrequest_comment", "id": 39279167}