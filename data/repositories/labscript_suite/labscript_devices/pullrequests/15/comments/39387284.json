{"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39387284.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39387284"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "It probably was me. I'm also inclined to agree another solution might be nice since this fix would set a lower bound on how short the script can be.\n\nAnyway, my solution was basically to read both the rising and falling edge at once to avoid the buffer size/speed limitation of these older M-series devices. It works well, but is not a general solution since it does not work for X-series devices (it assumes the first rising edge is measured). This is what I have now for my USB-6229 & PXI-6259:\n\n```\n#!python      \n    def read_two_half_period(self, timeout): \n        readarray = numpy.empty(2)\n        try:\n            with self.daqlock:\n                self.acquisition_task.ReadCounterF64(2, timeout, readarray, len(readarray), ctypes.c_long(1), None)\n                self.half_periods.append(readarray)\n            return readarray\n        except Exception:\n            if self.abort:\n                raise\n            # otherwise, it's a timeout:\n            return None\n    \n    def wait_for_edge(self, timeout=None):\n        if timeout is None:\n            while True:\n                half_period = self.read_two_half_period(1)\n                if half_period is not None:\n                    return half_period\n        else:\n            return self.read_two_half_period(timeout)\n                \n    def daqmx_read(self):\n        logger = logging.getLogger('BLACS.%s_%s.read_thread'%(self.device_name, self.worker_name))\n        logger.info('Starting')\n        with self.kill_lock:\n            try:\n                # Wait for the end of the first pulse indicating the start of the experiment:\n                [current_time, pulse_width] = self.wait_for_edge()\n                # alright, we're now a short way into the experiment.\n                for wait in self.wait_table:\n                    # How long until this wait should time out?\n                    timeout = wait['time'] + wait['timeout'] - current_time\n                    timeout = max(timeout, 0) # ensure non-negative\n                    # Wait that long for the next pulse:\n                    [half_period,pulse_width] = self.wait_for_edge(timeout)\n                    # Did the wait finish of its own accord?\n                    if half_period is not None:\n                        # It did, we are now at the end of that wait:\n                        current_time = wait['time']\n                        # Calculate the end of the pulse:\n                        current_time += pulse_width\n                    else:\n                        # It timed out. Better trigger the clock to resume!.\n                        self.send_resume_trigger(pulse_width)\n                        # Wait for it to respond to that:\n                        [half_period,pulse_width] = self.wait_for_edge()\n                        # Alright, *now* we're at the end of the wait.\n                        current_time = wait['time']\n                        # Calculate the end of the pulse:\n                        current_time += pulse_width\n\n                # Inform any interested parties that waits have all finished:\n                self.all_waits_finished.post(self.h5_file)\n            except Exception:\n                if self.abort:\n                    return\n                else:\n                    raise\n\n```\n\nI haven't bothered to generalize for both cases but keeping the workaround flag and modifying the logic for the experiment start pulse could potentially work. Maybe something like:\n\n```\n#!python\n    def read_half_period(self, timeout,num_edges): \n        readarray = numpy.empty(num_edges)\n        try:\n            with self.daqlock:\n                self.acquisition_task.ReadCounterF64(num_edges, timeout, readarray, len(readarray), ctypes.c_long(1), None)\n                if num_edges == 1:\n                    edges = readarray[0]\n                elif num_edges == 2:\n                    edges = readarray\n                self.half_periods.append(edges)\n            return edges\n        except Exception:\n            if self.abort:\n                raise\n            # otherwise, it's a timeout:\n            return None\n\n    def wait_for_edge(self, timeout=None,num_edges=1):\n        if timeout is None:\n            while True:\n                half_period = self.read_half_period(1,num_edges)\n                if half_period is not None:\n                    return half_period\n        else:\n            return self.read_half_period(timeout,num_edges)\n\n    def daqmx_read(self):\n        logger = logging.getLogger('BLACS.%s_%s.read_thread'%(self.device_name, self.worker_name))\n        logger.info('Starting')\n        with self.kill_lock:\n            try:\n                # Wait for the end of the first pulse indicating the start of the experiment:\n                if not self.DAQmx_waits_counter_bug_workaround:\n                    current_time = pulse_width = self.wait_for_edge()\n                elif self.DAQmx_waits_counter_bug_workaround:\n                    [current_time, pulse_width] = self.wait_for_edge(num_edges=2)\n                # alright, we're now a short way into the experiment.\n                for wait in self.wait_table:\n                    # How long until this wait should time out?\n                    timeout = wait['time'] + wait['timeout'] - current_time\n                    timeout = max(timeout, 0) # ensure non-negative\n                    # Wait that long for the next pulse:\n                    [half_period,pulse_width] = self.wait_for_edge(timeout,2)\n                    # Did the wait finish of its own accord?\n                    if half_period is not None:\n                        # It did, we are now at the end of that wait:\n                        current_time = wait['time']\n                        # Calculate the end of the pulse:\n                        current_time += pulse_width\n                    else:\n                        # It timed out. Better trigger the clock to resume!.\n                        self.send_resume_trigger(pulse_width)\n                        # Wait for it to respond to that:\n                        [half_period,pulse_width] = self.wait_for_edge()\n                        # Alright, *now* we're at the end of the wait.\n                        current_time = wait['time']\n                        # Calculate the end of the pulse:\n                        current_time += pulse_width\n                    .......\n```\n", "markup": "markdown", "html": "<p>It probably was me. I'm also inclined to agree another solution might be nice since this fix would set a lower bound on how short the script can be.</p>\n<p>Anyway, my solution was basically to read both the rising and falling edge at once to avoid the buffer size/speed limitation of these older M-series devices. It works well, but is not a general solution since it does not work for X-series devices (it assumes the first rising edge is measured). This is what I have now for my USB-6229 &amp; PXI-6259:</p>\n<div class=\"codehilite language-python\"><pre><span></span>    <span class=\"k\">def</span> <span class=\"nf\">read_two_half_period</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"p\">):</span> \n        <span class=\"n\">readarray</span> <span class=\"o\">=</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">empty</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"k\">with</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">daqlock</span><span class=\"p\">:</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">acquisition_task</span><span class=\"o\">.</span><span class=\"n\">ReadCounterF64</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"p\">,</span> <span class=\"n\">readarray</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">readarray</span><span class=\"p\">),</span> <span class=\"n\">ctypes</span><span class=\"o\">.</span><span class=\"n\">c_long</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"bp\">None</span><span class=\"p\">)</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">half_periods</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">readarray</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">readarray</span>\n        <span class=\"k\">except</span> <span class=\"ne\">Exception</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">abort</span><span class=\"p\">:</span>\n                <span class=\"k\">raise</span>\n            <span class=\"c1\"># otherwise, it&#39;s a timeout:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">None</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">wait_for_edge</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">timeout</span> <span class=\"ow\">is</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n            <span class=\"k\">while</span> <span class=\"bp\">True</span><span class=\"p\">:</span>\n                <span class=\"n\">half_period</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">read_two_half_period</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n                <span class=\"k\">if</span> <span class=\"n\">half_period</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n                    <span class=\"k\">return</span> <span class=\"n\">half_period</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">read_two_half_period</span><span class=\"p\">(</span><span class=\"n\">timeout</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">daqmx_read</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">logger</span> <span class=\"o\">=</span> <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">getLogger</span><span class=\"p\">(</span><span class=\"s1\">&#39;BLACS.</span><span class=\"si\">%s</span><span class=\"s1\">_</span><span class=\"si\">%s</span><span class=\"s1\">.read_thread&#39;</span><span class=\"o\">%</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">device_name</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">worker_name</span><span class=\"p\">))</span>\n        <span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"s1\">&#39;Starting&#39;</span><span class=\"p\">)</span>\n        <span class=\"k\">with</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">kill_lock</span><span class=\"p\">:</span>\n            <span class=\"k\">try</span><span class=\"p\">:</span>\n                <span class=\"c1\"># Wait for the end of the first pulse indicating the start of the experiment:</span>\n                <span class=\"p\">[</span><span class=\"n\">current_time</span><span class=\"p\">,</span> <span class=\"n\">pulse_width</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">wait_for_edge</span><span class=\"p\">()</span>\n                <span class=\"c1\"># alright, we&#39;re now a short way into the experiment.</span>\n                <span class=\"k\">for</span> <span class=\"n\">wait</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">wait_table</span><span class=\"p\">:</span>\n                    <span class=\"c1\"># How long until this wait should time out?</span>\n                    <span class=\"n\">timeout</span> <span class=\"o\">=</span> <span class=\"n\">wait</span><span class=\"p\">[</span><span class=\"s1\">&#39;time&#39;</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">wait</span><span class=\"p\">[</span><span class=\"s1\">&#39;timeout&#39;</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">current_time</span>\n                    <span class=\"n\">timeout</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">timeout</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"c1\"># ensure non-negative</span>\n                    <span class=\"c1\"># Wait that long for the next pulse:</span>\n                    <span class=\"p\">[</span><span class=\"n\">half_period</span><span class=\"p\">,</span><span class=\"n\">pulse_width</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">wait_for_edge</span><span class=\"p\">(</span><span class=\"n\">timeout</span><span class=\"p\">)</span>\n                    <span class=\"c1\"># Did the wait finish of its own accord?</span>\n                    <span class=\"k\">if</span> <span class=\"n\">half_period</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n                        <span class=\"c1\"># It did, we are now at the end of that wait:</span>\n                        <span class=\"n\">current_time</span> <span class=\"o\">=</span> <span class=\"n\">wait</span><span class=\"p\">[</span><span class=\"s1\">&#39;time&#39;</span><span class=\"p\">]</span>\n                        <span class=\"c1\"># Calculate the end of the pulse:</span>\n                        <span class=\"n\">current_time</span> <span class=\"o\">+=</span> <span class=\"n\">pulse_width</span>\n                    <span class=\"k\">else</span><span class=\"p\">:</span>\n                        <span class=\"c1\"># It timed out. Better trigger the clock to resume!.</span>\n                        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">send_resume_trigger</span><span class=\"p\">(</span><span class=\"n\">pulse_width</span><span class=\"p\">)</span>\n                        <span class=\"c1\"># Wait for it to respond to that:</span>\n                        <span class=\"p\">[</span><span class=\"n\">half_period</span><span class=\"p\">,</span><span class=\"n\">pulse_width</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">wait_for_edge</span><span class=\"p\">()</span>\n                        <span class=\"c1\"># Alright, *now* we&#39;re at the end of the wait.</span>\n                        <span class=\"n\">current_time</span> <span class=\"o\">=</span> <span class=\"n\">wait</span><span class=\"p\">[</span><span class=\"s1\">&#39;time&#39;</span><span class=\"p\">]</span>\n                        <span class=\"c1\"># Calculate the end of the pulse:</span>\n                        <span class=\"n\">current_time</span> <span class=\"o\">+=</span> <span class=\"n\">pulse_width</span>\n\n                <span class=\"c1\"># Inform any interested parties that waits have all finished:</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">all_waits_finished</span><span class=\"o\">.</span><span class=\"n\">post</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">h5_file</span><span class=\"p\">)</span>\n            <span class=\"k\">except</span> <span class=\"ne\">Exception</span><span class=\"p\">:</span>\n                <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">abort</span><span class=\"p\">:</span>\n                    <span class=\"k\">return</span>\n                <span class=\"k\">else</span><span class=\"p\">:</span>\n                    <span class=\"k\">raise</span>\n</pre></div>\n\n\n<p>I haven't bothered to generalize for both cases but keeping the workaround flag and modifying the logic for the experiment start pulse could potentially work. Maybe something like:</p>\n<div class=\"codehilite language-python\"><pre><span></span>    <span class=\"k\">def</span> <span class=\"nf\">read_half_period</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"p\">,</span><span class=\"n\">num_edges</span><span class=\"p\">):</span> \n        <span class=\"n\">readarray</span> <span class=\"o\">=</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">empty</span><span class=\"p\">(</span><span class=\"n\">num_edges</span><span class=\"p\">)</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"k\">with</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">daqlock</span><span class=\"p\">:</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">acquisition_task</span><span class=\"o\">.</span><span class=\"n\">ReadCounterF64</span><span class=\"p\">(</span><span class=\"n\">num_edges</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"p\">,</span> <span class=\"n\">readarray</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">readarray</span><span class=\"p\">),</span> <span class=\"n\">ctypes</span><span class=\"o\">.</span><span class=\"n\">c_long</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"bp\">None</span><span class=\"p\">)</span>\n                <span class=\"k\">if</span> <span class=\"n\">num_edges</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n                    <span class=\"n\">edges</span> <span class=\"o\">=</span> <span class=\"n\">readarray</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n                <span class=\"k\">elif</span> <span class=\"n\">num_edges</span> <span class=\"o\">==</span> <span class=\"mi\">2</span><span class=\"p\">:</span>\n                    <span class=\"n\">edges</span> <span class=\"o\">=</span> <span class=\"n\">readarray</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">half_periods</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">edges</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">edges</span>\n        <span class=\"k\">except</span> <span class=\"ne\">Exception</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">abort</span><span class=\"p\">:</span>\n                <span class=\"k\">raise</span>\n            <span class=\"c1\"># otherwise, it&#39;s a timeout:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">None</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">wait_for_edge</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span><span class=\"n\">num_edges</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">timeout</span> <span class=\"ow\">is</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n            <span class=\"k\">while</span> <span class=\"bp\">True</span><span class=\"p\">:</span>\n                <span class=\"n\">half_period</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">read_half_period</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">num_edges</span><span class=\"p\">)</span>\n                <span class=\"k\">if</span> <span class=\"n\">half_period</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n                    <span class=\"k\">return</span> <span class=\"n\">half_period</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">read_half_period</span><span class=\"p\">(</span><span class=\"n\">timeout</span><span class=\"p\">,</span><span class=\"n\">num_edges</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">daqmx_read</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">logger</span> <span class=\"o\">=</span> <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">getLogger</span><span class=\"p\">(</span><span class=\"s1\">&#39;BLACS.</span><span class=\"si\">%s</span><span class=\"s1\">_</span><span class=\"si\">%s</span><span class=\"s1\">.read_thread&#39;</span><span class=\"o\">%</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">device_name</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">worker_name</span><span class=\"p\">))</span>\n        <span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"s1\">&#39;Starting&#39;</span><span class=\"p\">)</span>\n        <span class=\"k\">with</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">kill_lock</span><span class=\"p\">:</span>\n            <span class=\"k\">try</span><span class=\"p\">:</span>\n                <span class=\"c1\"># Wait for the end of the first pulse indicating the start of the experiment:</span>\n                <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">DAQmx_waits_counter_bug_workaround</span><span class=\"p\">:</span>\n                    <span class=\"n\">current_time</span> <span class=\"o\">=</span> <span class=\"n\">pulse_width</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">wait_for_edge</span><span class=\"p\">()</span>\n                <span class=\"k\">elif</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">DAQmx_waits_counter_bug_workaround</span><span class=\"p\">:</span>\n                    <span class=\"p\">[</span><span class=\"n\">current_time</span><span class=\"p\">,</span> <span class=\"n\">pulse_width</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">wait_for_edge</span><span class=\"p\">(</span><span class=\"n\">num_edges</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n                <span class=\"c1\"># alright, we&#39;re now a short way into the experiment.</span>\n                <span class=\"k\">for</span> <span class=\"n\">wait</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">wait_table</span><span class=\"p\">:</span>\n                    <span class=\"c1\"># How long until this wait should time out?</span>\n                    <span class=\"n\">timeout</span> <span class=\"o\">=</span> <span class=\"n\">wait</span><span class=\"p\">[</span><span class=\"s1\">&#39;time&#39;</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">wait</span><span class=\"p\">[</span><span class=\"s1\">&#39;timeout&#39;</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">current_time</span>\n                    <span class=\"n\">timeout</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">timeout</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"c1\"># ensure non-negative</span>\n                    <span class=\"c1\"># Wait that long for the next pulse:</span>\n                    <span class=\"p\">[</span><span class=\"n\">half_period</span><span class=\"p\">,</span><span class=\"n\">pulse_width</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">wait_for_edge</span><span class=\"p\">(</span><span class=\"n\">timeout</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n                    <span class=\"c1\"># Did the wait finish of its own accord?</span>\n                    <span class=\"k\">if</span> <span class=\"n\">half_period</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n                        <span class=\"c1\"># It did, we are now at the end of that wait:</span>\n                        <span class=\"n\">current_time</span> <span class=\"o\">=</span> <span class=\"n\">wait</span><span class=\"p\">[</span><span class=\"s1\">&#39;time&#39;</span><span class=\"p\">]</span>\n                        <span class=\"c1\"># Calculate the end of the pulse:</span>\n                        <span class=\"n\">current_time</span> <span class=\"o\">+=</span> <span class=\"n\">pulse_width</span>\n                    <span class=\"k\">else</span><span class=\"p\">:</span>\n                        <span class=\"c1\"># It timed out. Better trigger the clock to resume!.</span>\n                        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">send_resume_trigger</span><span class=\"p\">(</span><span class=\"n\">pulse_width</span><span class=\"p\">)</span>\n                        <span class=\"c1\"># Wait for it to respond to that:</span>\n                        <span class=\"p\">[</span><span class=\"n\">half_period</span><span class=\"p\">,</span><span class=\"n\">pulse_width</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">wait_for_edge</span><span class=\"p\">()</span>\n                        <span class=\"c1\"># Alright, *now* we&#39;re at the end of the wait.</span>\n                        <span class=\"n\">current_time</span> <span class=\"o\">=</span> <span class=\"n\">wait</span><span class=\"p\">[</span><span class=\"s1\">&#39;time&#39;</span><span class=\"p\">]</span>\n                        <span class=\"c1\"># Calculate the end of the pulse:</span>\n                        <span class=\"n\">current_time</span> <span class=\"o\">+=</span> <span class=\"n\">pulse_width</span>\n                    <span class=\"o\">.......</span>\n</pre></div>", "type": "rendered"}, "created_on": "2017-06-22T16:05:07.675153+00:00", "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "updated_on": "2017-06-22T16:05:08.002896+00:00", "type": "pullrequest_comment", "id": 39387284}