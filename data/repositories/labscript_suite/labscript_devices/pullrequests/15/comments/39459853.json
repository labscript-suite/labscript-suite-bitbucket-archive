{"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39459853.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39459853"}}, "parent": {"id": 39387284, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39387284.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39387284"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "I went ahead and implemented the above idea. It is tested to work on USB 6343 & 6229 without the 0.1s pulses and hopefully does not introduce any subtle bugs. Here is the diff\n\n```\n#!diff\ndiff -r 6305eca7155c NI_DAQmx.py\n--- a/NI_DAQmx.py\tWed Jun 21 11:07:48 2017 -0400\n+++ b/NI_DAQmx.py\tFri Jun 23 10:11:16 2017 -0400\n@@ -923,28 +923,31 @@\n             self.stop_task()    \n     \n     #def read_one_half_period(self, timeout, readarray = numpy.empty(1)):\n-    def read_one_half_period(self, timeout, save=True):\n-        readarray = numpy.empty(1)\n+    def read_half_period(self, timeout, num_edges):\n+        readarray = numpy.empty(num_edges)\n         try:\n             with self.daqlock:\n-                self.acquisition_task.ReadCounterF64(1, timeout, readarray, len(readarray), ctypes.c_long(1), None)\n-                if save:\n-                    self.half_periods.append(readarray[0])\n-            return readarray[0]\n+                self.acquisition_task.ReadCounterF64(num_edges, timeout, readarray, len(readarray), ctypes.c_long(1), None)\n+                if num_edges == 1:\n+                    edges = readarray[0]\n+                else:\n+                    edges = readarray\n+                self.half_periods = numpy.append(self.half_periods,edges)\n+            return edges\n         except Exception:\n             if self.abort:\n                 raise\n             # otherwise, it's a timeout:\n             return None\n     \n-    def wait_for_edge(self, timeout=None, save=True):\n+    def wait_for_edge(self, timeout=None, num_edges=1):\n         if timeout is None:\n             while True:\n-                half_period = self.read_one_half_period(1, save)\n+                half_period = self.read_half_period(1, num_edges)\n                 if half_period is not None:\n                     return half_period\n         else:\n-            return self.read_one_half_period(timeout, save)\n+            return self.read_half_period(timeout, num_edges)\n                 \n     def daqmx_read(self):\n         logger = logging.getLogger('BLACS.%s_%s.read_thread'%(self.device_name, self.worker_name))\n@@ -952,31 +955,38 @@\n         with self.kill_lock:\n             try:\n                 # Wait for the end of the first pulse indicating the start of the experiment:\n-                if self.DAQmx_waits_counter_bug_workaround:\n-                    ignored = self.wait_for_edge(save=False)\n-                current_time = pulse_width = self.wait_for_edge()\n+                if not self.DAQmx_waits_counter_bug_workaround:\n+                    current_time = pulse_width = self.wait_for_edge()\n+                    # Now there was also a rising edge at t=0 that we didn't measure:\n+                    # this edge is accounted for in half_periods array instantiation\n+                elif self.DAQmx_waits_counter_bug_workaround:\n+                    # some devices read the rising edge of first pulse (ie M-Series DAQs)\n+                    # after reading edges, delete first zero from instantiation\n+                    [current_time, pulse_width] = self.wait_for_edge(num_edges=2)\n+                    current_time += pulse_width\n+                    self.half_periods = numpy.delete(self.half_periods,0)\n                 # alright, we're now a short way into the experiment.\n                 for wait in self.wait_table:\n                     # How long until this wait should time out?\n                     timeout = wait['time'] + wait['timeout'] - current_time\n                     timeout = max(timeout, 0) # ensure non-negative\n                     # Wait that long for the next pulse:\n-                    half_period = self.wait_for_edge(timeout)\n+                    [half_period,pulse_width] = self.wait_for_edge(timeout,2)\n                     # Did the wait finish of its own accord?\n                     if half_period is not None:\n                         # It did, we are now at the end of that wait:\n                         current_time = wait['time']\n-                        # Wait for the end of the pulse:\n-                        current_time += self.wait_for_edge()\n+                        # Add pulse width to current_time\n+                        current_time += pulse_width\n                     else:\n                         # It timed out. Better trigger the clock to resume!.\n                         self.send_resume_trigger(pulse_width)\n                         # Wait for it to respond to that:\n-                        self.wait_for_edge()\n+                        [half_period,pulse_width] = self.wait_for_edge(num_edges=2)\n                         # Alright, *now* we're at the end of the wait.\n                         current_time = wait['time']\n-                        # And wait for the end of the pulse:\n-                        current_time += self.wait_for_edge()\n+                        # And pulse_width to current time\n+                        current_time += pulse_width\n \n                 # Inform any interested parties that waits have all finished:\n                 self.all_waits_finished.post(self.h5_file)\n@@ -1049,7 +1059,7 @@\n             self.task_running = True\n                 \n             # An array to store the results of counter acquisition:\n-            self.half_periods = []\n+            self.half_periods = numpy.zeros(1,dtype=numpy.float64)\n             self.read_thread = threading.Thread(target=self.daqmx_read)\n             # Not a daemon thread, as it implements wait timeouts - we need it to stay alive if other things die.\n             self.read_thread.start()\n@@ -1070,8 +1080,6 @@\n                 # Let's work out how long the waits were. The absolute times of each edge on the wait\n                 # monitor were:\n                 edge_times = numpy.cumsum(self.half_periods)\n-                # Now there was also a rising edge at t=0 that we didn't measure:\n-                edge_times = numpy.insert(edge_times,0,0)\n                 # Ok, and the even-indexed ones of these were rising edges.\n                 rising_edge_times = edge_times[::2]\n                 # Now what were the times between rising edges?\n@@ -1080,7 +1088,7 @@\n                 # of the experiment and the first wait, and then between each pair of waits?\n                 # The difference will give us the waits' durations.\n                 resume_times = self.wait_table['time']\n-                # Again, include the start of the experiment, t=0:\n+                # Include the start of the experiment, t=0:\n                 resume_times =  numpy.insert(resume_times,0,0)\n                 run_periods = numpy.diff(resume_times)\n                 wait_durations = periods - run_periods\n\n\n```\n", "markup": "markdown", "html": "<p>I went ahead and implemented the above idea. It is tested to work on USB 6343 &amp; 6229 without the 0.1s pulses and hopefully does not introduce any subtle bugs. Here is the diff</p>\n<div class=\"codehilite language-diff\"><pre><span></span><span class=\"gh\">diff -r 6305eca7155c NI_DAQmx.py</span>\n<span class=\"gd\">--- a/NI_DAQmx.py   Wed Jun 21 11:07:48 2017 -0400</span>\n<span class=\"gi\">+++ b/NI_DAQmx.py   Fri Jun 23 10:11:16 2017 -0400</span>\n<span class=\"gu\">@@ -923,28 +923,31 @@</span>\n             self.stop_task()    \n\n     #def read_one_half_period(self, timeout, readarray = numpy.empty(1)):\n<span class=\"gd\">-    def read_one_half_period(self, timeout, save=True):</span>\n<span class=\"gd\">-        readarray = numpy.empty(1)</span>\n<span class=\"gi\">+    def read_half_period(self, timeout, num_edges):</span>\n<span class=\"gi\">+        readarray = numpy.empty(num_edges)</span>\n         try:\n             with self.daqlock:\n<span class=\"gd\">-                self.acquisition_task.ReadCounterF64(1, timeout, readarray, len(readarray), ctypes.c_long(1), None)</span>\n<span class=\"gd\">-                if save:</span>\n<span class=\"gd\">-                    self.half_periods.append(readarray[0])</span>\n<span class=\"gd\">-            return readarray[0]</span>\n<span class=\"gi\">+                self.acquisition_task.ReadCounterF64(num_edges, timeout, readarray, len(readarray), ctypes.c_long(1), None)</span>\n<span class=\"gi\">+                if num_edges == 1:</span>\n<span class=\"gi\">+                    edges = readarray[0]</span>\n<span class=\"gi\">+                else:</span>\n<span class=\"gi\">+                    edges = readarray</span>\n<span class=\"gi\">+                self.half_periods = numpy.append(self.half_periods,edges)</span>\n<span class=\"gi\">+            return edges</span>\n         except Exception:\n             if self.abort:\n                 raise\n             # otherwise, it&#39;s a timeout:\n             return None\n\n<span class=\"gd\">-    def wait_for_edge(self, timeout=None, save=True):</span>\n<span class=\"gi\">+    def wait_for_edge(self, timeout=None, num_edges=1):</span>\n         if timeout is None:\n             while True:\n<span class=\"gd\">-                half_period = self.read_one_half_period(1, save)</span>\n<span class=\"gi\">+                half_period = self.read_half_period(1, num_edges)</span>\n                 if half_period is not None:\n                     return half_period\n         else:\n<span class=\"gd\">-            return self.read_one_half_period(timeout, save)</span>\n<span class=\"gi\">+            return self.read_half_period(timeout, num_edges)</span>\n\n     def daqmx_read(self):\n         logger = logging.getLogger(&#39;BLACS.%s_%s.read_thread&#39;%(self.device_name, self.worker_name))\n<span class=\"gu\">@@ -952,31 +955,38 @@</span>\n         with self.kill_lock:\n             try:\n                 # Wait for the end of the first pulse indicating the start of the experiment:\n<span class=\"gd\">-                if self.DAQmx_waits_counter_bug_workaround:</span>\n<span class=\"gd\">-                    ignored = self.wait_for_edge(save=False)</span>\n<span class=\"gd\">-                current_time = pulse_width = self.wait_for_edge()</span>\n<span class=\"gi\">+                if not self.DAQmx_waits_counter_bug_workaround:</span>\n<span class=\"gi\">+                    current_time = pulse_width = self.wait_for_edge()</span>\n<span class=\"gi\">+                    # Now there was also a rising edge at t=0 that we didn&#39;t measure:</span>\n<span class=\"gi\">+                    # this edge is accounted for in half_periods array instantiation</span>\n<span class=\"gi\">+                elif self.DAQmx_waits_counter_bug_workaround:</span>\n<span class=\"gi\">+                    # some devices read the rising edge of first pulse (ie M-Series DAQs)</span>\n<span class=\"gi\">+                    # after reading edges, delete first zero from instantiation</span>\n<span class=\"gi\">+                    [current_time, pulse_width] = self.wait_for_edge(num_edges=2)</span>\n<span class=\"gi\">+                    current_time += pulse_width</span>\n<span class=\"gi\">+                    self.half_periods = numpy.delete(self.half_periods,0)</span>\n                 # alright, we&#39;re now a short way into the experiment.\n                 for wait in self.wait_table:\n                     # How long until this wait should time out?\n                     timeout = wait[&#39;time&#39;] + wait[&#39;timeout&#39;] - current_time\n                     timeout = max(timeout, 0) # ensure non-negative\n                     # Wait that long for the next pulse:\n<span class=\"gd\">-                    half_period = self.wait_for_edge(timeout)</span>\n<span class=\"gi\">+                    [half_period,pulse_width] = self.wait_for_edge(timeout,2)</span>\n                     # Did the wait finish of its own accord?\n                     if half_period is not None:\n                         # It did, we are now at the end of that wait:\n                         current_time = wait[&#39;time&#39;]\n<span class=\"gd\">-                        # Wait for the end of the pulse:</span>\n<span class=\"gd\">-                        current_time += self.wait_for_edge()</span>\n<span class=\"gi\">+                        # Add pulse width to current_time</span>\n<span class=\"gi\">+                        current_time += pulse_width</span>\n                     else:\n                         # It timed out. Better trigger the clock to resume!.\n                         self.send_resume_trigger(pulse_width)\n                         # Wait for it to respond to that:\n<span class=\"gd\">-                        self.wait_for_edge()</span>\n<span class=\"gi\">+                        [half_period,pulse_width] = self.wait_for_edge(num_edges=2)</span>\n                         # Alright, *now* we&#39;re at the end of the wait.\n                         current_time = wait[&#39;time&#39;]\n<span class=\"gd\">-                        # And wait for the end of the pulse:</span>\n<span class=\"gd\">-                        current_time += self.wait_for_edge()</span>\n<span class=\"gi\">+                        # And pulse_width to current time</span>\n<span class=\"gi\">+                        current_time += pulse_width</span>\n\n                 # Inform any interested parties that waits have all finished:\n                 self.all_waits_finished.post(self.h5_file)\n<span class=\"gu\">@@ -1049,7 +1059,7 @@</span>\n             self.task_running = True\n\n             # An array to store the results of counter acquisition:\n<span class=\"gd\">-            self.half_periods = []</span>\n<span class=\"gi\">+            self.half_periods = numpy.zeros(1,dtype=numpy.float64)</span>\n             self.read_thread = threading.Thread(target=self.daqmx_read)\n             # Not a daemon thread, as it implements wait timeouts - we need it to stay alive if other things die.\n             self.read_thread.start()\n<span class=\"gu\">@@ -1070,8 +1080,6 @@</span>\n                 # Let&#39;s work out how long the waits were. The absolute times of each edge on the wait\n                 # monitor were:\n                 edge_times = numpy.cumsum(self.half_periods)\n<span class=\"gd\">-                # Now there was also a rising edge at t=0 that we didn&#39;t measure:</span>\n<span class=\"gd\">-                edge_times = numpy.insert(edge_times,0,0)</span>\n                 # Ok, and the even-indexed ones of these were rising edges.\n                 rising_edge_times = edge_times[::2]\n                 # Now what were the times between rising edges?\n<span class=\"gu\">@@ -1080,7 +1088,7 @@</span>\n                 # of the experiment and the first wait, and then between each pair of waits?\n                 # The difference will give us the waits&#39; durations.\n                 resume_times = self.wait_table[&#39;time&#39;]\n<span class=\"gd\">-                # Again, include the start of the experiment, t=0:</span>\n<span class=\"gi\">+                # Include the start of the experiment, t=0:</span>\n                 resume_times =  numpy.insert(resume_times,0,0)\n                 run_periods = numpy.diff(resume_times)\n                 wait_durations = periods - run_periods\n</pre></div>", "type": "rendered"}, "created_on": "2017-06-23T14:11:58.325177+00:00", "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "updated_on": "2017-06-23T14:11:58.696599+00:00", "type": "pullrequest_comment", "id": 39459853}