{"pagelen": 100, "values": [{"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39279167.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39279167"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "We are very interested in having a unified NI-DAQmx interface to help us maintain code for DAQ devices not in the main labscript repository so I will be happy to do some testing. I have easy access to a USB-6229, USB-6343, PXI-6259 and PXI-6733. As far as testing goes, is the idea to test both NI_DAQmx and the modifications to the original DAQ board classes?\n\nI already have a question about the error handling on line 185 of NI_DAQmx.py that enforces an even number of AO/DO/AI channels: Is that intentional? I thought the even samples limitation only applied to Analog outputs on the 6733 board.\n\nAssuming I am mis-informed, I agree the current counting mechanism allows for odd numbers in channel subsets. Maybe a better option would be to count using the dictionaries populated from the child_devices list on line 112, leaving something like\n\n```\n#!python\n\nif len(analogs) % 2 or len(digitals) % 2 or len(inputs) %2:\n    raise LabscriptError('...')\n```\n", "markup": "markdown", "html": "<p>We are very interested in having a unified NI-DAQmx interface to help us maintain code for DAQ devices not in the main labscript repository so I will be happy to do some testing. I have easy access to a USB-6229, USB-6343, PXI-6259 and PXI-6733. As far as testing goes, is the idea to test both NI_DAQmx and the modifications to the original DAQ board classes?</p>\n<p>I already have a question about the error handling on line 185 of NI_DAQmx.py that enforces an even number of AO/DO/AI channels: Is that intentional? I thought the even samples limitation only applied to Analog outputs on the 6733 board.</p>\n<p>Assuming I am mis-informed, I agree the current counting mechanism allows for odd numbers in channel subsets. Maybe a better option would be to count using the dictionaries populated from the child_devices list on line 112, leaving something like</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">analogs</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"ow\">or</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">digitals</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"ow\">or</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">inputs</span><span class=\"p\">)</span> <span class=\"o\">%</span><span class=\"mi\">2</span><span class=\"p\">:</span>\n    <span class=\"k\">raise</span> <span class=\"n\">LabscriptError</span><span class=\"p\">(</span><span class=\"s1\">&#39;...&#39;</span><span class=\"p\">)</span>\n</pre></div>", "type": "rendered"}, "created_on": "2017-06-21T13:28:56.563659+00:00", "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "updated_on": "2017-06-21T13:28:56.651484+00:00", "type": "pullrequest_comment", "id": 39279167}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39289750.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39289750"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "David, it would be _great_ if you were able to test this code on a range of devices.  We have it running at JQI on a couple of PCI cards and on some USB based devices, so it is fairly solid, but may have many edge cases.  One thing I implemented was the zlock lock to prevent simultaneous access to the NI library.  I don't know if this is needed, but it (may have) fixed a hang.  I do notice that it is not uniformly applied, to all calls to the NI library.  A hidden bug or not, I don't know, but certainly not consistent.\n\nRegarding error checking, I believe that your suggestion is great.  I have implemented it in my fork, but with more lines to give better error reporting.", "markup": "markdown", "html": "<p>David, it would be <em>great</em> if you were able to test this code on a range of devices.  We have it running at JQI on a couple of PCI cards and on some USB based devices, so it is fairly solid, but may have many edge cases.  One thing I implemented was the zlock lock to prevent simultaneous access to the NI library.  I don't know if this is needed, but it (may have) fixed a hang.  I do notice that it is not uniformly applied, to all calls to the NI library.  A hidden bug or not, I don't know, but certainly not consistent.</p>\n<p>Regarding error checking, I believe that your suggestion is great.  I have implemented it in my fork, but with more lines to give better error reporting.</p>", "type": "rendered"}, "created_on": "2017-06-21T15:00:00.568334+00:00", "user": {"display_name": "Ian B. Spielman", "uuid": "{bff0d3df-2ed5-4ff6-b13d-ce6cd935edb1}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D"}, "html": {"href": "https://bitbucket.org/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/54beee087619e1a612011791e203f277d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsIS-0.png"}}, "nickname": "Ian Spielman", "type": "user", "account_id": "557058:b0e98d01-12e7-4a9d-a274-a195def255d2"}, "updated_on": "2017-06-21T15:00:13.782170+00:00", "type": "pullrequest_comment", "id": 39289750}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39312530.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39312530"}}, "parent": {"id": 39289750, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39289750.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39289750"}}, "depth": 1}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "We put locks like that in originally, but I think we found they were not necessary. It seemed that different processes calling the API at the same time was fine - they would just get errors if hey tried to access the same hardware, and within a process the API seemed to provide its own lock automatically (though I could be misremembering that). We kept the one for the wait monitor out of an overabundance of caution since it is in charge of timing out waits - and we wanted to minimise the chances of an error on our part causing that part of the code to be locked out of using the API when it needed to.", "markup": "markdown", "html": "<p>We put locks like that in originally, but I think we found they were not necessary. It seemed that different processes calling the API at the same time was fine - they would just get errors if hey tried to access the same hardware, and within a process the API seemed to provide its own lock automatically (though I could be misremembering that). We kept the one for the wait monitor out of an overabundance of caution since it is in charge of timing out waits - and we wanted to minimise the chances of an error on our part causing that part of the code to be locked out of using the API when it needed to.</p>", "type": "rendered"}, "created_on": "2017-06-21T19:50:30.556426+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-06-21T19:54:32.408795+00:00", "type": "pullrequest_comment", "id": 39312530}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39290952.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39290952"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "I am not confident that this solution is 100% correct because see we combine static and dynamic channels into one group of analogs.  Clearly (?) the even/odd sample thing only applies to dynamic channels since each static channel can only have one sample anyway.  It might make sense to break them out further.\n\nRight now we say that each category is all static or all dynamic, so at least there is no mix-match of unlike things.", "markup": "markdown", "html": "<p>I am not confident that this solution is 100% correct because see we combine static and dynamic channels into one group of analogs.  Clearly (?) the even/odd sample thing only applies to dynamic channels since each static channel can only have one sample anyway.  It might make sense to break them out further.</p>\n<p>Right now we say that each category is all static or all dynamic, so at least there is no mix-match of unlike things.</p>", "type": "rendered"}, "created_on": "2017-06-21T15:09:29.438828+00:00", "user": {"display_name": "Ian B. Spielman", "uuid": "{bff0d3df-2ed5-4ff6-b13d-ce6cd935edb1}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D"}, "html": {"href": "https://bitbucket.org/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/54beee087619e1a612011791e203f277d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsIS-0.png"}}, "nickname": "Ian Spielman", "type": "user", "account_id": "557058:b0e98d01-12e7-4a9d-a274-a195def255d2"}, "updated_on": "2017-06-21T15:11:10.603142+00:00", "type": "pullrequest_comment", "id": 39290952}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39308894.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39308894"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "Agreed this isn't 100% (though I don't use any static channels, probably should now that I think about it). I was hoping to avoid more explicit counting but it probably won't happen.\n\nOn closer inspection, this counting method takes a wait monitor child as a single DO task. The result is two digital outputs (the acquisition and timeout tasks) and a digital input (the counter) being reduced to a single digital output. I doubt the digital input matters, but I'm assuming the timeout DO task should also be counted? Maybe not since it isn't part of the main buffered outputs sequence?", "markup": "markdown", "html": "<p>Agreed this isn't 100% (though I don't use any static channels, probably should now that I think about it). I was hoping to avoid more explicit counting but it probably won't happen.</p>\n<p>On closer inspection, this counting method takes a wait monitor child as a single DO task. The result is two digital outputs (the acquisition and timeout tasks) and a digital input (the counter) being reduced to a single digital output. I doubt the digital input matters, but I'm assuming the timeout DO task should also be counted? Maybe not since it isn't part of the main buffered outputs sequence?</p>", "type": "rendered"}, "created_on": "2017-06-21T18:52:38.678406+00:00", "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "updated_on": "2017-06-21T18:52:38.735622+00:00", "type": "pullrequest_comment", "id": 39308894}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39312014.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39312014"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "The limitation under question here is indeed for table mode, so we don't need to count channels that will be setup under a different NI task.", "markup": "markdown", "html": "<p>The limitation under question here is indeed for table mode, so we don't need to count channels that will be setup under a different NI task.</p>", "type": "rendered"}, "created_on": "2017-06-21T19:42:25.773182+00:00", "user": {"display_name": "Ian B. Spielman", "uuid": "{bff0d3df-2ed5-4ff6-b13d-ce6cd935edb1}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D"}, "html": {"href": "https://bitbucket.org/%7Bbff0d3df-2ed5-4ff6-b13d-ce6cd935edb1%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/54beee087619e1a612011791e203f277d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsIS-0.png"}}, "nickname": "Ian Spielman", "type": "user", "account_id": "557058:b0e98d01-12e7-4a9d-a274-a195def255d2"}, "updated_on": "2017-06-21T19:42:25.775661+00:00", "type": "pullrequest_comment", "id": 39312014}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39377095.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39377095"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "Next question: the DAQmx_waits_counter_bug_workaround does not appear to be working for my USB-6229 device. It does work on my PXI-6259 that also suffers from the same bug. My original testing for this bug tracked the difference down to slow bus speeds for USB compared to PXI on top of the bug itself. I ended up using a different workaround to overcome the bus speed and DAQmx bug problems simultaneously by reading two edges at once for each pulse, but it requires a larger alteration to work. \n\nAnyway, closer inspection shows that the wait monitor pulse duration is not being set to 0.1s like the comment on line 95 claims it should. I'm guessing the code that does that is external to this device class? Can you make that available somehow?\n", "markup": "markdown", "html": "<p>Next question: the DAQmx_waits_counter_bug_workaround does not appear to be working for my USB-6229 device. It does work on my PXI-6259 that also suffers from the same bug. My original testing for this bug tracked the difference down to slow bus speeds for USB compared to PXI on top of the bug itself. I ended up using a different workaround to overcome the bus speed and DAQmx bug problems simultaneously by reading two edges at once for each pulse, but it requires a larger alteration to work. </p>\n<p>Anyway, closer inspection shows that the wait monitor pulse duration is not being set to 0.1s like the comment on line 95 claims it should. I'm guessing the code that does that is external to this device class? Can you make that available somehow?</p>", "type": "rendered"}, "created_on": "2017-06-22T14:30:30.775219+00:00", "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "updated_on": "2017-06-22T14:30:30.860828+00:00", "type": "pullrequest_comment", "id": 39377095}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39378672.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39378672"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "Looks like we forgot to commit that file. I don't have access to the computer it's on, but it's a change to labscript.py, something like this:\n\n```\n#!diff\n\ndiff -r 4ba0ef7c8d36 labscript.py\n--- a/labscript.py\tWed Jun 21 03:49:33 2017 +0000\n+++ b/labscript.py\tThu Jun 22 10:43:50 2017 -0400\n@@ -860,16 +860,18 @@\n     def trigger(self, t, duration, wait_delay = 0):\n         \"\"\"Ask the trigger device to produce a digital pulse of a given duration to trigger this pseudoclock\"\"\"\n         if t == 'initial':\n             t = self.initial_trigger_time\n         t = round(t,10)\n         if self.is_master_pseudoclock:\n             if compiler.wait_monitor is not None:\n                 # Make the wait monitor pulse to signify starting or resumption of the experiment:\n+                if getattr(wait_monitor, 'DAQmx_waits_counter_bug_workaround', False):\n+                    duration = 0.1\n                 compiler.wait_monitor.trigger(t, duration)\n             elif t != self.initial_trigger_time:\n                 raise LabscriptError(\"You cannot use waits in unless you have a wait monitor.\" +\n                                      \"Please instantiate a WaitMonitor in your connection table.\")\n             self.trigger_times.append(t)\n         else:\n             self.trigger_device.trigger(t, duration)\n             self.trigger_times.append(round(t + wait_delay,10))\n```\n", "markup": "markdown", "html": "<p>Looks like we forgot to commit that file. I don't have access to the computer it's on, but it's a change to labscript.py, something like this:</p>\n<div class=\"codehilite language-diff\"><pre><span></span><span class=\"gh\">diff -r 4ba0ef7c8d36 labscript.py</span>\n<span class=\"gd\">--- a/labscript.py  Wed Jun 21 03:49:33 2017 +0000</span>\n<span class=\"gi\">+++ b/labscript.py  Thu Jun 22 10:43:50 2017 -0400</span>\n<span class=\"gu\">@@ -860,16 +860,18 @@</span>\n     def trigger(self, t, duration, wait_delay = 0):\n         &quot;&quot;&quot;Ask the trigger device to produce a digital pulse of a given duration to trigger this pseudoclock&quot;&quot;&quot;\n         if t == &#39;initial&#39;:\n             t = self.initial_trigger_time\n         t = round(t,10)\n         if self.is_master_pseudoclock:\n             if compiler.wait_monitor is not None:\n                 # Make the wait monitor pulse to signify starting or resumption of the experiment:\n<span class=\"gi\">+                if getattr(wait_monitor, &#39;DAQmx_waits_counter_bug_workaround&#39;, False):</span>\n<span class=\"gi\">+                    duration = 0.1</span>\n                 compiler.wait_monitor.trigger(t, duration)\n             elif t != self.initial_trigger_time:\n                 raise LabscriptError(&quot;You cannot use waits in unless you have a wait monitor.&quot; +\n                                      &quot;Please instantiate a WaitMonitor in your connection table.&quot;)\n             self.trigger_times.append(t)\n         else:\n             self.trigger_device.trigger(t, duration)\n             self.trigger_times.append(round(t + wait_delay,10))\n</pre></div>", "type": "rendered"}, "created_on": "2017-06-22T14:44:35.492576+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-06-22T14:44:47.106476+00:00", "type": "pullrequest_comment", "id": 39378672}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39379421.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39379421"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "I'd be interested in this larger alteration! My memory fails me, but I seem to recall someone else was having this issue and our workaround did not work for them (maybe I'm just remembering you having mentioned it before). So fixing it some other way might be more reliable, and this fix was always a dirty hack anyway that I'd rather do without if possible.", "markup": "markdown", "html": "<p>I'd be interested in this larger alteration! My memory fails me, but I seem to recall someone else was having this issue and our workaround did not work for them (maybe I'm just remembering you having mentioned it before). So fixing it some other way might be more reliable, and this fix was always a dirty hack anyway that I'd rather do without if possible.</p>", "type": "rendered"}, "created_on": "2017-06-22T14:48:26.660592+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-06-22T14:49:12.274032+00:00", "type": "pullrequest_comment", "id": 39379421}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39387284.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39387284"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "It probably was me. I'm also inclined to agree another solution might be nice since this fix would set a lower bound on how short the script can be.\n\nAnyway, my solution was basically to read both the rising and falling edge at once to avoid the buffer size/speed limitation of these older M-series devices. It works well, but is not a general solution since it does not work for X-series devices (it assumes the first rising edge is measured). This is what I have now for my USB-6229 & PXI-6259:\n\n```\n#!python      \n    def read_two_half_period(self, timeout): \n        readarray = numpy.empty(2)\n        try:\n            with self.daqlock:\n                self.acquisition_task.ReadCounterF64(2, timeout, readarray, len(readarray), ctypes.c_long(1), None)\n                self.half_periods.append(readarray)\n            return readarray\n        except Exception:\n            if self.abort:\n                raise\n            # otherwise, it's a timeout:\n            return None\n    \n    def wait_for_edge(self, timeout=None):\n        if timeout is None:\n            while True:\n                half_period = self.read_two_half_period(1)\n                if half_period is not None:\n                    return half_period\n        else:\n            return self.read_two_half_period(timeout)\n                \n    def daqmx_read(self):\n        logger = logging.getLogger('BLACS.%s_%s.read_thread'%(self.device_name, self.worker_name))\n        logger.info('Starting')\n        with self.kill_lock:\n            try:\n                # Wait for the end of the first pulse indicating the start of the experiment:\n                [current_time, pulse_width] = self.wait_for_edge()\n                # alright, we're now a short way into the experiment.\n                for wait in self.wait_table:\n                    # How long until this wait should time out?\n                    timeout = wait['time'] + wait['timeout'] - current_time\n                    timeout = max(timeout, 0) # ensure non-negative\n                    # Wait that long for the next pulse:\n                    [half_period,pulse_width] = self.wait_for_edge(timeout)\n                    # Did the wait finish of its own accord?\n                    if half_period is not None:\n                        # It did, we are now at the end of that wait:\n                        current_time = wait['time']\n                        # Calculate the end of the pulse:\n                        current_time += pulse_width\n                    else:\n                        # It timed out. Better trigger the clock to resume!.\n                        self.send_resume_trigger(pulse_width)\n                        # Wait for it to respond to that:\n                        [half_period,pulse_width] = self.wait_for_edge()\n                        # Alright, *now* we're at the end of the wait.\n                        current_time = wait['time']\n                        # Calculate the end of the pulse:\n                        current_time += pulse_width\n\n                # Inform any interested parties that waits have all finished:\n                self.all_waits_finished.post(self.h5_file)\n            except Exception:\n                if self.abort:\n                    return\n                else:\n                    raise\n\n```\n\nI haven't bothered to generalize for both cases but keeping the workaround flag and modifying the logic for the experiment start pulse could potentially work. Maybe something like:\n\n```\n#!python\n    def read_half_period(self, timeout,num_edges): \n        readarray = numpy.empty(num_edges)\n        try:\n            with self.daqlock:\n                self.acquisition_task.ReadCounterF64(num_edges, timeout, readarray, len(readarray), ctypes.c_long(1), None)\n                if num_edges == 1:\n                    edges = readarray[0]\n                elif num_edges == 2:\n                    edges = readarray\n                self.half_periods.append(edges)\n            return edges\n        except Exception:\n            if self.abort:\n                raise\n            # otherwise, it's a timeout:\n            return None\n\n    def wait_for_edge(self, timeout=None,num_edges=1):\n        if timeout is None:\n            while True:\n                half_period = self.read_half_period(1,num_edges)\n                if half_period is not None:\n                    return half_period\n        else:\n            return self.read_half_period(timeout,num_edges)\n\n    def daqmx_read(self):\n        logger = logging.getLogger('BLACS.%s_%s.read_thread'%(self.device_name, self.worker_name))\n        logger.info('Starting')\n        with self.kill_lock:\n            try:\n                # Wait for the end of the first pulse indicating the start of the experiment:\n                if not self.DAQmx_waits_counter_bug_workaround:\n                    current_time = pulse_width = self.wait_for_edge()\n                elif self.DAQmx_waits_counter_bug_workaround:\n                    [current_time, pulse_width] = self.wait_for_edge(num_edges=2)\n                # alright, we're now a short way into the experiment.\n                for wait in self.wait_table:\n                    # How long until this wait should time out?\n                    timeout = wait['time'] + wait['timeout'] - current_time\n                    timeout = max(timeout, 0) # ensure non-negative\n                    # Wait that long for the next pulse:\n                    [half_period,pulse_width] = self.wait_for_edge(timeout,2)\n                    # Did the wait finish of its own accord?\n                    if half_period is not None:\n                        # It did, we are now at the end of that wait:\n                        current_time = wait['time']\n                        # Calculate the end of the pulse:\n                        current_time += pulse_width\n                    else:\n                        # It timed out. Better trigger the clock to resume!.\n                        self.send_resume_trigger(pulse_width)\n                        # Wait for it to respond to that:\n                        [half_period,pulse_width] = self.wait_for_edge()\n                        # Alright, *now* we're at the end of the wait.\n                        current_time = wait['time']\n                        # Calculate the end of the pulse:\n                        current_time += pulse_width\n                    .......\n```\n", "markup": "markdown", "html": "<p>It probably was me. I'm also inclined to agree another solution might be nice since this fix would set a lower bound on how short the script can be.</p>\n<p>Anyway, my solution was basically to read both the rising and falling edge at once to avoid the buffer size/speed limitation of these older M-series devices. It works well, but is not a general solution since it does not work for X-series devices (it assumes the first rising edge is measured). This is what I have now for my USB-6229 &amp; PXI-6259:</p>\n<div class=\"codehilite language-python\"><pre><span></span>    <span class=\"k\">def</span> <span class=\"nf\">read_two_half_period</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"p\">):</span> \n        <span class=\"n\">readarray</span> <span class=\"o\">=</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">empty</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"k\">with</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">daqlock</span><span class=\"p\">:</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">acquisition_task</span><span class=\"o\">.</span><span class=\"n\">ReadCounterF64</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"p\">,</span> <span class=\"n\">readarray</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">readarray</span><span class=\"p\">),</span> <span class=\"n\">ctypes</span><span class=\"o\">.</span><span class=\"n\">c_long</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"bp\">None</span><span class=\"p\">)</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">half_periods</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">readarray</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">readarray</span>\n        <span class=\"k\">except</span> <span class=\"ne\">Exception</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">abort</span><span class=\"p\">:</span>\n                <span class=\"k\">raise</span>\n            <span class=\"c1\"># otherwise, it&#39;s a timeout:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">None</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">wait_for_edge</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">timeout</span> <span class=\"ow\">is</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n            <span class=\"k\">while</span> <span class=\"bp\">True</span><span class=\"p\">:</span>\n                <span class=\"n\">half_period</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">read_two_half_period</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n                <span class=\"k\">if</span> <span class=\"n\">half_period</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n                    <span class=\"k\">return</span> <span class=\"n\">half_period</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">read_two_half_period</span><span class=\"p\">(</span><span class=\"n\">timeout</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">daqmx_read</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">logger</span> <span class=\"o\">=</span> <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">getLogger</span><span class=\"p\">(</span><span class=\"s1\">&#39;BLACS.</span><span class=\"si\">%s</span><span class=\"s1\">_</span><span class=\"si\">%s</span><span class=\"s1\">.read_thread&#39;</span><span class=\"o\">%</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">device_name</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">worker_name</span><span class=\"p\">))</span>\n        <span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"s1\">&#39;Starting&#39;</span><span class=\"p\">)</span>\n        <span class=\"k\">with</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">kill_lock</span><span class=\"p\">:</span>\n            <span class=\"k\">try</span><span class=\"p\">:</span>\n                <span class=\"c1\"># Wait for the end of the first pulse indicating the start of the experiment:</span>\n                <span class=\"p\">[</span><span class=\"n\">current_time</span><span class=\"p\">,</span> <span class=\"n\">pulse_width</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">wait_for_edge</span><span class=\"p\">()</span>\n                <span class=\"c1\"># alright, we&#39;re now a short way into the experiment.</span>\n                <span class=\"k\">for</span> <span class=\"n\">wait</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">wait_table</span><span class=\"p\">:</span>\n                    <span class=\"c1\"># How long until this wait should time out?</span>\n                    <span class=\"n\">timeout</span> <span class=\"o\">=</span> <span class=\"n\">wait</span><span class=\"p\">[</span><span class=\"s1\">&#39;time&#39;</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">wait</span><span class=\"p\">[</span><span class=\"s1\">&#39;timeout&#39;</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">current_time</span>\n                    <span class=\"n\">timeout</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">timeout</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"c1\"># ensure non-negative</span>\n                    <span class=\"c1\"># Wait that long for the next pulse:</span>\n                    <span class=\"p\">[</span><span class=\"n\">half_period</span><span class=\"p\">,</span><span class=\"n\">pulse_width</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">wait_for_edge</span><span class=\"p\">(</span><span class=\"n\">timeout</span><span class=\"p\">)</span>\n                    <span class=\"c1\"># Did the wait finish of its own accord?</span>\n                    <span class=\"k\">if</span> <span class=\"n\">half_period</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n                        <span class=\"c1\"># It did, we are now at the end of that wait:</span>\n                        <span class=\"n\">current_time</span> <span class=\"o\">=</span> <span class=\"n\">wait</span><span class=\"p\">[</span><span class=\"s1\">&#39;time&#39;</span><span class=\"p\">]</span>\n                        <span class=\"c1\"># Calculate the end of the pulse:</span>\n                        <span class=\"n\">current_time</span> <span class=\"o\">+=</span> <span class=\"n\">pulse_width</span>\n                    <span class=\"k\">else</span><span class=\"p\">:</span>\n                        <span class=\"c1\"># It timed out. Better trigger the clock to resume!.</span>\n                        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">send_resume_trigger</span><span class=\"p\">(</span><span class=\"n\">pulse_width</span><span class=\"p\">)</span>\n                        <span class=\"c1\"># Wait for it to respond to that:</span>\n                        <span class=\"p\">[</span><span class=\"n\">half_period</span><span class=\"p\">,</span><span class=\"n\">pulse_width</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">wait_for_edge</span><span class=\"p\">()</span>\n                        <span class=\"c1\"># Alright, *now* we&#39;re at the end of the wait.</span>\n                        <span class=\"n\">current_time</span> <span class=\"o\">=</span> <span class=\"n\">wait</span><span class=\"p\">[</span><span class=\"s1\">&#39;time&#39;</span><span class=\"p\">]</span>\n                        <span class=\"c1\"># Calculate the end of the pulse:</span>\n                        <span class=\"n\">current_time</span> <span class=\"o\">+=</span> <span class=\"n\">pulse_width</span>\n\n                <span class=\"c1\"># Inform any interested parties that waits have all finished:</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">all_waits_finished</span><span class=\"o\">.</span><span class=\"n\">post</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">h5_file</span><span class=\"p\">)</span>\n            <span class=\"k\">except</span> <span class=\"ne\">Exception</span><span class=\"p\">:</span>\n                <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">abort</span><span class=\"p\">:</span>\n                    <span class=\"k\">return</span>\n                <span class=\"k\">else</span><span class=\"p\">:</span>\n                    <span class=\"k\">raise</span>\n</pre></div>\n\n\n<p>I haven't bothered to generalize for both cases but keeping the workaround flag and modifying the logic for the experiment start pulse could potentially work. Maybe something like:</p>\n<div class=\"codehilite language-python\"><pre><span></span>    <span class=\"k\">def</span> <span class=\"nf\">read_half_period</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"p\">,</span><span class=\"n\">num_edges</span><span class=\"p\">):</span> \n        <span class=\"n\">readarray</span> <span class=\"o\">=</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">empty</span><span class=\"p\">(</span><span class=\"n\">num_edges</span><span class=\"p\">)</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"k\">with</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">daqlock</span><span class=\"p\">:</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">acquisition_task</span><span class=\"o\">.</span><span class=\"n\">ReadCounterF64</span><span class=\"p\">(</span><span class=\"n\">num_edges</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"p\">,</span> <span class=\"n\">readarray</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">readarray</span><span class=\"p\">),</span> <span class=\"n\">ctypes</span><span class=\"o\">.</span><span class=\"n\">c_long</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"bp\">None</span><span class=\"p\">)</span>\n                <span class=\"k\">if</span> <span class=\"n\">num_edges</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n                    <span class=\"n\">edges</span> <span class=\"o\">=</span> <span class=\"n\">readarray</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n                <span class=\"k\">elif</span> <span class=\"n\">num_edges</span> <span class=\"o\">==</span> <span class=\"mi\">2</span><span class=\"p\">:</span>\n                    <span class=\"n\">edges</span> <span class=\"o\">=</span> <span class=\"n\">readarray</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">half_periods</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">edges</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">edges</span>\n        <span class=\"k\">except</span> <span class=\"ne\">Exception</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">abort</span><span class=\"p\">:</span>\n                <span class=\"k\">raise</span>\n            <span class=\"c1\"># otherwise, it&#39;s a timeout:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">None</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">wait_for_edge</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span><span class=\"n\">num_edges</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">timeout</span> <span class=\"ow\">is</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n            <span class=\"k\">while</span> <span class=\"bp\">True</span><span class=\"p\">:</span>\n                <span class=\"n\">half_period</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">read_half_period</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">num_edges</span><span class=\"p\">)</span>\n                <span class=\"k\">if</span> <span class=\"n\">half_period</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n                    <span class=\"k\">return</span> <span class=\"n\">half_period</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">read_half_period</span><span class=\"p\">(</span><span class=\"n\">timeout</span><span class=\"p\">,</span><span class=\"n\">num_edges</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">daqmx_read</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">logger</span> <span class=\"o\">=</span> <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">getLogger</span><span class=\"p\">(</span><span class=\"s1\">&#39;BLACS.</span><span class=\"si\">%s</span><span class=\"s1\">_</span><span class=\"si\">%s</span><span class=\"s1\">.read_thread&#39;</span><span class=\"o\">%</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">device_name</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">worker_name</span><span class=\"p\">))</span>\n        <span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"s1\">&#39;Starting&#39;</span><span class=\"p\">)</span>\n        <span class=\"k\">with</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">kill_lock</span><span class=\"p\">:</span>\n            <span class=\"k\">try</span><span class=\"p\">:</span>\n                <span class=\"c1\"># Wait for the end of the first pulse indicating the start of the experiment:</span>\n                <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">DAQmx_waits_counter_bug_workaround</span><span class=\"p\">:</span>\n                    <span class=\"n\">current_time</span> <span class=\"o\">=</span> <span class=\"n\">pulse_width</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">wait_for_edge</span><span class=\"p\">()</span>\n                <span class=\"k\">elif</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">DAQmx_waits_counter_bug_workaround</span><span class=\"p\">:</span>\n                    <span class=\"p\">[</span><span class=\"n\">current_time</span><span class=\"p\">,</span> <span class=\"n\">pulse_width</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">wait_for_edge</span><span class=\"p\">(</span><span class=\"n\">num_edges</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n                <span class=\"c1\"># alright, we&#39;re now a short way into the experiment.</span>\n                <span class=\"k\">for</span> <span class=\"n\">wait</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">wait_table</span><span class=\"p\">:</span>\n                    <span class=\"c1\"># How long until this wait should time out?</span>\n                    <span class=\"n\">timeout</span> <span class=\"o\">=</span> <span class=\"n\">wait</span><span class=\"p\">[</span><span class=\"s1\">&#39;time&#39;</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">wait</span><span class=\"p\">[</span><span class=\"s1\">&#39;timeout&#39;</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">current_time</span>\n                    <span class=\"n\">timeout</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">timeout</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"c1\"># ensure non-negative</span>\n                    <span class=\"c1\"># Wait that long for the next pulse:</span>\n                    <span class=\"p\">[</span><span class=\"n\">half_period</span><span class=\"p\">,</span><span class=\"n\">pulse_width</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">wait_for_edge</span><span class=\"p\">(</span><span class=\"n\">timeout</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n                    <span class=\"c1\"># Did the wait finish of its own accord?</span>\n                    <span class=\"k\">if</span> <span class=\"n\">half_period</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n                        <span class=\"c1\"># It did, we are now at the end of that wait:</span>\n                        <span class=\"n\">current_time</span> <span class=\"o\">=</span> <span class=\"n\">wait</span><span class=\"p\">[</span><span class=\"s1\">&#39;time&#39;</span><span class=\"p\">]</span>\n                        <span class=\"c1\"># Calculate the end of the pulse:</span>\n                        <span class=\"n\">current_time</span> <span class=\"o\">+=</span> <span class=\"n\">pulse_width</span>\n                    <span class=\"k\">else</span><span class=\"p\">:</span>\n                        <span class=\"c1\"># It timed out. Better trigger the clock to resume!.</span>\n                        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">send_resume_trigger</span><span class=\"p\">(</span><span class=\"n\">pulse_width</span><span class=\"p\">)</span>\n                        <span class=\"c1\"># Wait for it to respond to that:</span>\n                        <span class=\"p\">[</span><span class=\"n\">half_period</span><span class=\"p\">,</span><span class=\"n\">pulse_width</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">wait_for_edge</span><span class=\"p\">()</span>\n                        <span class=\"c1\"># Alright, *now* we&#39;re at the end of the wait.</span>\n                        <span class=\"n\">current_time</span> <span class=\"o\">=</span> <span class=\"n\">wait</span><span class=\"p\">[</span><span class=\"s1\">&#39;time&#39;</span><span class=\"p\">]</span>\n                        <span class=\"c1\"># Calculate the end of the pulse:</span>\n                        <span class=\"n\">current_time</span> <span class=\"o\">+=</span> <span class=\"n\">pulse_width</span>\n                    <span class=\"o\">.......</span>\n</pre></div>", "type": "rendered"}, "created_on": "2017-06-22T16:05:07.675153+00:00", "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "updated_on": "2017-06-22T16:05:08.002896+00:00", "type": "pullrequest_comment", "id": 39387284}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39459853.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39459853"}}, "parent": {"id": 39387284, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39387284.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39387284"}}, "depth": 1}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "I went ahead and implemented the above idea. It is tested to work on USB 6343 & 6229 without the 0.1s pulses and hopefully does not introduce any subtle bugs. Here is the diff\n\n```\n#!diff\ndiff -r 6305eca7155c NI_DAQmx.py\n--- a/NI_DAQmx.py\tWed Jun 21 11:07:48 2017 -0400\n+++ b/NI_DAQmx.py\tFri Jun 23 10:11:16 2017 -0400\n@@ -923,28 +923,31 @@\n             self.stop_task()    \n     \n     #def read_one_half_period(self, timeout, readarray = numpy.empty(1)):\n-    def read_one_half_period(self, timeout, save=True):\n-        readarray = numpy.empty(1)\n+    def read_half_period(self, timeout, num_edges):\n+        readarray = numpy.empty(num_edges)\n         try:\n             with self.daqlock:\n-                self.acquisition_task.ReadCounterF64(1, timeout, readarray, len(readarray), ctypes.c_long(1), None)\n-                if save:\n-                    self.half_periods.append(readarray[0])\n-            return readarray[0]\n+                self.acquisition_task.ReadCounterF64(num_edges, timeout, readarray, len(readarray), ctypes.c_long(1), None)\n+                if num_edges == 1:\n+                    edges = readarray[0]\n+                else:\n+                    edges = readarray\n+                self.half_periods = numpy.append(self.half_periods,edges)\n+            return edges\n         except Exception:\n             if self.abort:\n                 raise\n             # otherwise, it's a timeout:\n             return None\n     \n-    def wait_for_edge(self, timeout=None, save=True):\n+    def wait_for_edge(self, timeout=None, num_edges=1):\n         if timeout is None:\n             while True:\n-                half_period = self.read_one_half_period(1, save)\n+                half_period = self.read_half_period(1, num_edges)\n                 if half_period is not None:\n                     return half_period\n         else:\n-            return self.read_one_half_period(timeout, save)\n+            return self.read_half_period(timeout, num_edges)\n                 \n     def daqmx_read(self):\n         logger = logging.getLogger('BLACS.%s_%s.read_thread'%(self.device_name, self.worker_name))\n@@ -952,31 +955,38 @@\n         with self.kill_lock:\n             try:\n                 # Wait for the end of the first pulse indicating the start of the experiment:\n-                if self.DAQmx_waits_counter_bug_workaround:\n-                    ignored = self.wait_for_edge(save=False)\n-                current_time = pulse_width = self.wait_for_edge()\n+                if not self.DAQmx_waits_counter_bug_workaround:\n+                    current_time = pulse_width = self.wait_for_edge()\n+                    # Now there was also a rising edge at t=0 that we didn't measure:\n+                    # this edge is accounted for in half_periods array instantiation\n+                elif self.DAQmx_waits_counter_bug_workaround:\n+                    # some devices read the rising edge of first pulse (ie M-Series DAQs)\n+                    # after reading edges, delete first zero from instantiation\n+                    [current_time, pulse_width] = self.wait_for_edge(num_edges=2)\n+                    current_time += pulse_width\n+                    self.half_periods = numpy.delete(self.half_periods,0)\n                 # alright, we're now a short way into the experiment.\n                 for wait in self.wait_table:\n                     # How long until this wait should time out?\n                     timeout = wait['time'] + wait['timeout'] - current_time\n                     timeout = max(timeout, 0) # ensure non-negative\n                     # Wait that long for the next pulse:\n-                    half_period = self.wait_for_edge(timeout)\n+                    [half_period,pulse_width] = self.wait_for_edge(timeout,2)\n                     # Did the wait finish of its own accord?\n                     if half_period is not None:\n                         # It did, we are now at the end of that wait:\n                         current_time = wait['time']\n-                        # Wait for the end of the pulse:\n-                        current_time += self.wait_for_edge()\n+                        # Add pulse width to current_time\n+                        current_time += pulse_width\n                     else:\n                         # It timed out. Better trigger the clock to resume!.\n                         self.send_resume_trigger(pulse_width)\n                         # Wait for it to respond to that:\n-                        self.wait_for_edge()\n+                        [half_period,pulse_width] = self.wait_for_edge(num_edges=2)\n                         # Alright, *now* we're at the end of the wait.\n                         current_time = wait['time']\n-                        # And wait for the end of the pulse:\n-                        current_time += self.wait_for_edge()\n+                        # And pulse_width to current time\n+                        current_time += pulse_width\n \n                 # Inform any interested parties that waits have all finished:\n                 self.all_waits_finished.post(self.h5_file)\n@@ -1049,7 +1059,7 @@\n             self.task_running = True\n                 \n             # An array to store the results of counter acquisition:\n-            self.half_periods = []\n+            self.half_periods = numpy.zeros(1,dtype=numpy.float64)\n             self.read_thread = threading.Thread(target=self.daqmx_read)\n             # Not a daemon thread, as it implements wait timeouts - we need it to stay alive if other things die.\n             self.read_thread.start()\n@@ -1070,8 +1080,6 @@\n                 # Let's work out how long the waits were. The absolute times of each edge on the wait\n                 # monitor were:\n                 edge_times = numpy.cumsum(self.half_periods)\n-                # Now there was also a rising edge at t=0 that we didn't measure:\n-                edge_times = numpy.insert(edge_times,0,0)\n                 # Ok, and the even-indexed ones of these were rising edges.\n                 rising_edge_times = edge_times[::2]\n                 # Now what were the times between rising edges?\n@@ -1080,7 +1088,7 @@\n                 # of the experiment and the first wait, and then between each pair of waits?\n                 # The difference will give us the waits' durations.\n                 resume_times = self.wait_table['time']\n-                # Again, include the start of the experiment, t=0:\n+                # Include the start of the experiment, t=0:\n                 resume_times =  numpy.insert(resume_times,0,0)\n                 run_periods = numpy.diff(resume_times)\n                 wait_durations = periods - run_periods\n\n\n```\n", "markup": "markdown", "html": "<p>I went ahead and implemented the above idea. It is tested to work on USB 6343 &amp; 6229 without the 0.1s pulses and hopefully does not introduce any subtle bugs. Here is the diff</p>\n<div class=\"codehilite language-diff\"><pre><span></span><span class=\"gh\">diff -r 6305eca7155c NI_DAQmx.py</span>\n<span class=\"gd\">--- a/NI_DAQmx.py   Wed Jun 21 11:07:48 2017 -0400</span>\n<span class=\"gi\">+++ b/NI_DAQmx.py   Fri Jun 23 10:11:16 2017 -0400</span>\n<span class=\"gu\">@@ -923,28 +923,31 @@</span>\n             self.stop_task()    \n\n     #def read_one_half_period(self, timeout, readarray = numpy.empty(1)):\n<span class=\"gd\">-    def read_one_half_period(self, timeout, save=True):</span>\n<span class=\"gd\">-        readarray = numpy.empty(1)</span>\n<span class=\"gi\">+    def read_half_period(self, timeout, num_edges):</span>\n<span class=\"gi\">+        readarray = numpy.empty(num_edges)</span>\n         try:\n             with self.daqlock:\n<span class=\"gd\">-                self.acquisition_task.ReadCounterF64(1, timeout, readarray, len(readarray), ctypes.c_long(1), None)</span>\n<span class=\"gd\">-                if save:</span>\n<span class=\"gd\">-                    self.half_periods.append(readarray[0])</span>\n<span class=\"gd\">-            return readarray[0]</span>\n<span class=\"gi\">+                self.acquisition_task.ReadCounterF64(num_edges, timeout, readarray, len(readarray), ctypes.c_long(1), None)</span>\n<span class=\"gi\">+                if num_edges == 1:</span>\n<span class=\"gi\">+                    edges = readarray[0]</span>\n<span class=\"gi\">+                else:</span>\n<span class=\"gi\">+                    edges = readarray</span>\n<span class=\"gi\">+                self.half_periods = numpy.append(self.half_periods,edges)</span>\n<span class=\"gi\">+            return edges</span>\n         except Exception:\n             if self.abort:\n                 raise\n             # otherwise, it&#39;s a timeout:\n             return None\n\n<span class=\"gd\">-    def wait_for_edge(self, timeout=None, save=True):</span>\n<span class=\"gi\">+    def wait_for_edge(self, timeout=None, num_edges=1):</span>\n         if timeout is None:\n             while True:\n<span class=\"gd\">-                half_period = self.read_one_half_period(1, save)</span>\n<span class=\"gi\">+                half_period = self.read_half_period(1, num_edges)</span>\n                 if half_period is not None:\n                     return half_period\n         else:\n<span class=\"gd\">-            return self.read_one_half_period(timeout, save)</span>\n<span class=\"gi\">+            return self.read_half_period(timeout, num_edges)</span>\n\n     def daqmx_read(self):\n         logger = logging.getLogger(&#39;BLACS.%s_%s.read_thread&#39;%(self.device_name, self.worker_name))\n<span class=\"gu\">@@ -952,31 +955,38 @@</span>\n         with self.kill_lock:\n             try:\n                 # Wait for the end of the first pulse indicating the start of the experiment:\n<span class=\"gd\">-                if self.DAQmx_waits_counter_bug_workaround:</span>\n<span class=\"gd\">-                    ignored = self.wait_for_edge(save=False)</span>\n<span class=\"gd\">-                current_time = pulse_width = self.wait_for_edge()</span>\n<span class=\"gi\">+                if not self.DAQmx_waits_counter_bug_workaround:</span>\n<span class=\"gi\">+                    current_time = pulse_width = self.wait_for_edge()</span>\n<span class=\"gi\">+                    # Now there was also a rising edge at t=0 that we didn&#39;t measure:</span>\n<span class=\"gi\">+                    # this edge is accounted for in half_periods array instantiation</span>\n<span class=\"gi\">+                elif self.DAQmx_waits_counter_bug_workaround:</span>\n<span class=\"gi\">+                    # some devices read the rising edge of first pulse (ie M-Series DAQs)</span>\n<span class=\"gi\">+                    # after reading edges, delete first zero from instantiation</span>\n<span class=\"gi\">+                    [current_time, pulse_width] = self.wait_for_edge(num_edges=2)</span>\n<span class=\"gi\">+                    current_time += pulse_width</span>\n<span class=\"gi\">+                    self.half_periods = numpy.delete(self.half_periods,0)</span>\n                 # alright, we&#39;re now a short way into the experiment.\n                 for wait in self.wait_table:\n                     # How long until this wait should time out?\n                     timeout = wait[&#39;time&#39;] + wait[&#39;timeout&#39;] - current_time\n                     timeout = max(timeout, 0) # ensure non-negative\n                     # Wait that long for the next pulse:\n<span class=\"gd\">-                    half_period = self.wait_for_edge(timeout)</span>\n<span class=\"gi\">+                    [half_period,pulse_width] = self.wait_for_edge(timeout,2)</span>\n                     # Did the wait finish of its own accord?\n                     if half_period is not None:\n                         # It did, we are now at the end of that wait:\n                         current_time = wait[&#39;time&#39;]\n<span class=\"gd\">-                        # Wait for the end of the pulse:</span>\n<span class=\"gd\">-                        current_time += self.wait_for_edge()</span>\n<span class=\"gi\">+                        # Add pulse width to current_time</span>\n<span class=\"gi\">+                        current_time += pulse_width</span>\n                     else:\n                         # It timed out. Better trigger the clock to resume!.\n                         self.send_resume_trigger(pulse_width)\n                         # Wait for it to respond to that:\n<span class=\"gd\">-                        self.wait_for_edge()</span>\n<span class=\"gi\">+                        [half_period,pulse_width] = self.wait_for_edge(num_edges=2)</span>\n                         # Alright, *now* we&#39;re at the end of the wait.\n                         current_time = wait[&#39;time&#39;]\n<span class=\"gd\">-                        # And wait for the end of the pulse:</span>\n<span class=\"gd\">-                        current_time += self.wait_for_edge()</span>\n<span class=\"gi\">+                        # And pulse_width to current time</span>\n<span class=\"gi\">+                        current_time += pulse_width</span>\n\n                 # Inform any interested parties that waits have all finished:\n                 self.all_waits_finished.post(self.h5_file)\n<span class=\"gu\">@@ -1049,7 +1059,7 @@</span>\n             self.task_running = True\n\n             # An array to store the results of counter acquisition:\n<span class=\"gd\">-            self.half_periods = []</span>\n<span class=\"gi\">+            self.half_periods = numpy.zeros(1,dtype=numpy.float64)</span>\n             self.read_thread = threading.Thread(target=self.daqmx_read)\n             # Not a daemon thread, as it implements wait timeouts - we need it to stay alive if other things die.\n             self.read_thread.start()\n<span class=\"gu\">@@ -1070,8 +1080,6 @@</span>\n                 # Let&#39;s work out how long the waits were. The absolute times of each edge on the wait\n                 # monitor were:\n                 edge_times = numpy.cumsum(self.half_periods)\n<span class=\"gd\">-                # Now there was also a rising edge at t=0 that we didn&#39;t measure:</span>\n<span class=\"gd\">-                edge_times = numpy.insert(edge_times,0,0)</span>\n                 # Ok, and the even-indexed ones of these were rising edges.\n                 rising_edge_times = edge_times[::2]\n                 # Now what were the times between rising edges?\n<span class=\"gu\">@@ -1080,7 +1088,7 @@</span>\n                 # of the experiment and the first wait, and then between each pair of waits?\n                 # The difference will give us the waits&#39; durations.\n                 resume_times = self.wait_table[&#39;time&#39;]\n<span class=\"gd\">-                # Again, include the start of the experiment, t=0:</span>\n<span class=\"gi\">+                # Include the start of the experiment, t=0:</span>\n                 resume_times =  numpy.insert(resume_times,0,0)\n                 run_periods = numpy.diff(resume_times)\n                 wait_durations = periods - run_periods\n</pre></div>", "type": "rendered"}, "created_on": "2017-06-23T14:11:58.325177+00:00", "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "updated_on": "2017-06-23T14:11:58.696599+00:00", "type": "pullrequest_comment", "id": 39459853}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39467940.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39467940"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "Next Question: I am not familiar with the independent clocking of the Analog inputs. In the above instantiation example, what are RTSI0 & PFI0 connected to? I'm assuming clocklines from the PB. Is RTSI0 the master pseudoclock and PFI0 a secondary clockline? Or is PFI0 configured to be one of the internal clocks on the DAQ?", "markup": "markdown", "html": "<p>Next Question: I am not familiar with the independent clocking of the Analog inputs. In the above instantiation example, what are RTSI0 &amp; PFI0 connected to? I'm assuming clocklines from the PB. Is RTSI0 the master pseudoclock and PFI0 a secondary clockline? Or is PFI0 configured to be one of the internal clocks on the DAQ?</p>", "type": "rendered"}, "created_on": "2017-06-23T15:46:13.538004+00:00", "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "updated_on": "2017-06-23T15:46:15.121504+00:00", "type": "pullrequest_comment", "id": 39467940}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39468874.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39468874"}}, "parent": {"id": 39467940, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39467940.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39467940"}}, "depth": 1}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "If I'm understanding correctly, RTSI0 is indeed the pseudoclock clocking the NI DAQmx device to produce output, as normal. PFI0 on the other hand is an example of how you would specify which terminal to use to clock analog input - presently NI DAQmx acquisition in labscript works by acquiring data at all times, self-clocked by the NI device's internal timing, but it would be nice to be able to acquire only at specific times based on clock ticks. This functionality isn't implemented yet, but the idea would be to set it with the `mode_AI` keyword argument - with 'labscript' being the current way things work, and 'gated' and 'triggered' using PFI0 either as a gate or as a clock for acquisition. So it should probably be a `ValueError`error to set `clock_terminal_AI` to anything when `mode_AI` is `'labscript'`, and it should probably be a `NotImplementedError` to have `mode_AI` be anything other than `'labscript'` until an implementation exists.", "markup": "markdown", "html": "<p>If I'm understanding correctly, RTSI0 is indeed the pseudoclock clocking the NI DAQmx device to produce output, as normal. PFI0 on the other hand is an example of how you would specify which terminal to use to clock analog input - presently NI DAQmx acquisition in labscript works by acquiring data at all times, self-clocked by the NI device's internal timing, but it would be nice to be able to acquire only at specific times based on clock ticks. This functionality isn't implemented yet, but the idea would be to set it with the <code>mode_AI</code> keyword argument - with 'labscript' being the current way things work, and 'gated' and 'triggered' using PFI0 either as a gate or as a clock for acquisition. So it should probably be a <code>ValueError</code>error to set <code>clock_terminal_AI</code> to anything when <code>mode_AI</code> is <code>'labscript'</code>, and it should probably be a <code>NotImplementedError</code> to have <code>mode_AI</code> be anything other than <code>'labscript'</code> until an implementation exists.</p>", "type": "rendered"}, "created_on": "2017-06-23T15:58:51.959597+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-06-23T16:00:02.563619+00:00", "type": "pullrequest_comment", "id": 39468874}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39475635.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39475635"}}, "parent": {"id": 39468874, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39468874.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39468874"}}, "depth": 2}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "That is what I suspected, but setting the AI clock terminal to None and the mode to 'labscript' I get the following traceback when trying to use analog inputs. Am I missing something else?\n\nException in worker - Fri Jun 23, 13:50:02 :\nTraceback (most recent call last):\n  File \"C:\\labscript_suite\\labscript_devices\\NI_DAQmx.py\", line 788, in transition_to_buffered\n    self.setup_task()\n  File \"C:\\labscript_suite\\labscript_devices\\NI_DAQmx.py\", line 723, in setup_task\n    self.task.StartTask()\n  File \"<string>\", line 3, in StartTask\n  File \"<string>\", line 2, in function\n  File \"C:\\Anaconda2\\envs\\labscript\\lib\\site-packages\\PyDAQmx\\DAQmxFunctions.py\", line 29, in mafunction\n    raise DAQError(error,errBuff.value.decode(\"utf-8\"), f.__name__)\nDAQError: An empty string was specified as a terminal name which is not supported.\n\nSpecify a valid terminal name.\nProperty: DAQmx_DigEdge_StartTrig_Src\n\nTask Name: _unnamedTask<0>\n\nStatus Code: -200797\n in function DAQmxStartTask", "markup": "markdown", "html": "<p>That is what I suspected, but setting the AI clock terminal to None and the mode to 'labscript' I get the following traceback when trying to use analog inputs. Am I missing something else?</p>\n<p>Exception in worker - Fri Jun 23, 13:50:02 :\nTraceback (most recent call last):\n  File \"C:\\labscript_suite\\labscript_devices\\NI_DAQmx.py\", line 788, in transition_to_buffered\n    self.setup_task()\n  File \"C:\\labscript_suite\\labscript_devices\\NI_DAQmx.py\", line 723, in setup_task\n    self.task.StartTask()\n  File \"&lt;string&gt;\", line 3, in StartTask\n  File \"&lt;string&gt;\", line 2, in function\n  File \"C:\\Anaconda2\\envs\\labscript\\lib\\site-packages\\PyDAQmx\\DAQmxFunctions.py\", line 29, in mafunction\n    raise DAQError(error,errBuff.value.decode(\"utf-8\"), f.<strong>name</strong>)\nDAQError: An empty string was specified as a terminal name which is not supported.</p>\n<p>Specify a valid terminal name.\nProperty: DAQmx_DigEdge_StartTrig_Src</p>\n<p>Task Name: _unnamedTask&lt;0&gt;</p>\n<p>Status Code: -200797\n in function DAQmxStartTask</p>", "type": "rendered"}, "created_on": "2017-06-23T17:57:38.322212+00:00", "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "updated_on": "2017-06-23T17:57:38.428433+00:00", "type": "pullrequest_comment", "id": 39475635}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39476175.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39476175"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "Ah, looks like I misunderstood, and that actually in the case of 'labscript' analog input mode, the AI clock termainal ought to be the same as the master pseudoclock, so it can use it for initial triggering (even thoughthe subsequent clock ticks don't affect acquisition).\n\nI suppose that although it needs to be the master pseudoclock triggering 'labscript mode' AI, the output of the card might be clocked by a non-master pseudoclock, so that's interesting - perhaps they don't need to be the same. But for an experiment with only one pseudoclock they ought to be.", "markup": "markdown", "html": "<p>Ah, looks like I misunderstood, and that actually in the case of 'labscript' analog input mode, the AI clock termainal ought to be the same as the master pseudoclock, so it can use it for initial triggering (even thoughthe subsequent clock ticks don't affect acquisition).</p>\n<p>I suppose that although it needs to be the master pseudoclock triggering 'labscript mode' AI, the output of the card might be clocked by a non-master pseudoclock, so that's interesting - perhaps they don't need to be the same. But for an experiment with only one pseudoclock they ought to be.</p>", "type": "rendered"}, "created_on": "2017-06-23T18:06:22.286071+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-06-23T18:06:22.288488+00:00", "type": "pullrequest_comment", "id": 39476175}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39480363.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39480363"}}, "parent": {"id": 39476175, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39476175.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39476175"}}, "depth": 1}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "I see. That does it then. On a related note, the sample_rate_AI & MAX_name in the example call above is not listed in the labscript device __init__ call but one level up in NIBoard.py. Maybe that is intentional, but the result is that I can alter those two parameters without runmanager throwing the usual error that my connection table is not a subset of the BLACS connection table.\n\nI've also found a numpy deprecation warning for line NI_DAQmx.py:882\n\n```\n#!python\n\nVisibleDeprecationWarning: using a non-integer number instead of an integer will result in an error in the future\n    values = self.buffered_data[connection][start_index:end_index+1]\n```\n", "markup": "markdown", "html": "<p>I see. That does it then. On a related note, the sample_rate_AI &amp; MAX_name in the example call above is not listed in the labscript device <strong>init</strong> call but one level up in NIBoard.py. Maybe that is intentional, but the result is that I can alter those two parameters without runmanager throwing the usual error that my connection table is not a subset of the BLACS connection table.</p>\n<p>I've also found a numpy deprecation warning for line NI_DAQmx.py:882</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"n\">VisibleDeprecationWarning</span><span class=\"p\">:</span> <span class=\"n\">using</span> <span class=\"n\">a</span> <span class=\"n\">non</span><span class=\"o\">-</span><span class=\"n\">integer</span> <span class=\"n\">number</span> <span class=\"n\">instead</span> <span class=\"n\">of</span> <span class=\"n\">an</span> <span class=\"n\">integer</span> <span class=\"n\">will</span> <span class=\"n\">result</span> <span class=\"ow\">in</span> <span class=\"n\">an</span> <span class=\"n\">error</span> <span class=\"ow\">in</span> <span class=\"n\">the</span> <span class=\"n\">future</span>\n    <span class=\"n\">values</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buffered_data</span><span class=\"p\">[</span><span class=\"n\">connection</span><span class=\"p\">][</span><span class=\"n\">start_index</span><span class=\"p\">:</span><span class=\"n\">end_index</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n</pre></div>", "type": "rendered"}, "created_on": "2017-06-23T19:23:47.481799+00:00", "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "updated_on": "2017-06-23T19:23:47.567271+00:00", "type": "pullrequest_comment", "id": 39480363}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/48877006.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-48877006"}}, "parent": {"id": 39480363, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/39480363.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-39480363"}}, "depth": 2}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "I just ran into this and it is now a TypeError. Should be fixed before this is merged.", "markup": "markdown", "html": "<p>I just ran into this and it is now a TypeError. Should be fixed before this is merged.</p>", "type": "rendered"}, "created_on": "2017-11-06T19:12:36.296694+00:00", "user": {"display_name": "Daniel Barker", "uuid": "{6f3f4446-92ab-4af6-83ed-bb2906b3a304}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6f3f4446-92ab-4af6-83ed-bb2906b3a304%7D"}, "html": {"href": "https://bitbucket.org/%7B6f3f4446-92ab-4af6-83ed-bb2906b3a304%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/fbcf4c479308ad530548be5884a7c70fd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDB-4.png"}}, "nickname": "dsbarker", "type": "user", "account_id": "557058:02be919f-267c-4793-9e86-ef07d163b58b"}, "updated_on": "2017-11-06T19:12:36.346457+00:00", "type": "pullrequest_comment", "id": 48877006}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/48969811.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-48969811"}}, "parent": {"id": 48877006, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/48877006.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-48877006"}}, "depth": 3}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "For the benefit of whoever ends up making the pull request to do this, the fix looks like a simple wrap of numpy.int over the calls of numpy.floor and numpy.ceil on lines 865 & 867 should do the trick.", "markup": "markdown", "html": "<p>For the benefit of whoever ends up making the pull request to do this, the fix looks like a simple wrap of numpy.int over the calls of numpy.floor and numpy.ceil on lines 865 &amp; 867 should do the trick.</p>", "type": "rendered"}, "created_on": "2017-11-07T15:50:50.887907+00:00", "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "updated_on": "2017-11-07T15:50:50.935982+00:00", "type": "pullrequest_comment", "id": 48969811}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/49424736.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-49424736"}}, "parent": {"id": 48969811, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/48969811.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-48969811"}}, "depth": 4}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "I prefer to put the int() wrapper on line 882 where it's necessary. There's a bug that collapses all data to a single time point for short acquisitions that is fixed by a __future__ import, so I decided to keep it as a float until the division is done (although this is probably unnecessary).\n\n\n```\n#!diff\n@@ -11,6 +11,7 @@\n \n+from __future__ import division\n from labscript import LabscriptError, set_passed_properties, config\n from labscript import IntermediateDevice, AnalogOut, StaticAnalogOut, DigitalOut, StaticDigitalOut, AnalogIn\n from labscript_devices import labscript_device, BLACS_tab, BLACS_worker, runviewer_parser\n@@ -336,7 +337,7 @@\n         # TODO: Currently labscript only supports one DO port, easy to add more\n         # by passing a suitable structure of DO ports\n         # I verified above that num['num_DO'] is a factor of 8\n-        for i in range(self.num['num_DO']/8):\n+        for i in range(int(self.num['num_DO']/8)):\n             self.do_task.CreateDOChan(self.MAX_name+\"/port0/line%d:%d\"%(8*i,8*i+7),\"\", DAQmx_Val_ChanForAllLines)\n         \n         # currently do not allow direct access to PFI ports.  In the future can refer to NU_USB6346 code for an example\n@@ -878,7 +879,7 @@\n                 times = numpy.linspace(acquisition_start_time, acquisition_end_time, \n                                        end_index-start_index+1,\n                                        endpoint=True)\n-                values = self.buffered_data[connection][start_index:end_index+1]\n+                values = self.buffered_data[connection][int(start_index):int(end_index+1)]\n                 dtypes = [('t', numpy.float64),('values', numpy.float32)]\n                 data = numpy.empty(len(values),dtype=dtypes)\n                 data['t'] = times\n\n```\n", "markup": "markdown", "html": "<p>I prefer to put the int() wrapper on line 882 where it's necessary. There's a bug that collapses all data to a single time point for short acquisitions that is fixed by a <strong>future</strong> import, so I decided to keep it as a float until the division is done (although this is probably unnecessary).</p>\n<div class=\"codehilite language-diff\"><pre><span></span><span class=\"gu\">@@ -11,6 +11,7 @@</span>\n\n<span class=\"gi\">+from __future__ import division</span>\n from labscript import LabscriptError, set_passed_properties, config\n from labscript import IntermediateDevice, AnalogOut, StaticAnalogOut, DigitalOut, StaticDigitalOut, AnalogIn\n from labscript_devices import labscript_device, BLACS_tab, BLACS_worker, runviewer_parser\n<span class=\"gu\">@@ -336,7 +337,7 @@</span>\n         # TODO: Currently labscript only supports one DO port, easy to add more\n         # by passing a suitable structure of DO ports\n         # I verified above that num[&#39;num_DO&#39;] is a factor of 8\n<span class=\"gd\">-        for i in range(self.num[&#39;num_DO&#39;]/8):</span>\n<span class=\"gi\">+        for i in range(int(self.num[&#39;num_DO&#39;]/8)):</span>\n             self.do_task.CreateDOChan(self.MAX_name+&quot;/port0/line%d:%d&quot;%(8*i,8*i+7),&quot;&quot;, DAQmx_Val_ChanForAllLines)\n\n         # currently do not allow direct access to PFI ports.  In the future can refer to NU_USB6346 code for an example\n<span class=\"gu\">@@ -878,7 +879,7 @@</span>\n                 times = numpy.linspace(acquisition_start_time, acquisition_end_time, \n                                        end_index-start_index+1,\n                                        endpoint=True)\n<span class=\"gd\">-                values = self.buffered_data[connection][start_index:end_index+1]</span>\n<span class=\"gi\">+                values = self.buffered_data[connection][int(start_index):int(end_index+1)]</span>\n                 dtypes = [(&#39;t&#39;, numpy.float64),(&#39;values&#39;, numpy.float32)]\n                 data = numpy.empty(len(values),dtype=dtypes)\n                 data[&#39;t&#39;] = times\n</pre></div>", "type": "rendered"}, "created_on": "2017-11-13T14:49:06.460395+00:00", "user": {"display_name": "Daniel Barker", "uuid": "{6f3f4446-92ab-4af6-83ed-bb2906b3a304}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6f3f4446-92ab-4af6-83ed-bb2906b3a304%7D"}, "html": {"href": "https://bitbucket.org/%7B6f3f4446-92ab-4af6-83ed-bb2906b3a304%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/fbcf4c479308ad530548be5884a7c70fd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDB-4.png"}}, "nickname": "dsbarker", "type": "user", "account_id": "557058:02be919f-267c-4793-9e86-ef07d163b58b"}, "updated_on": "2017-11-13T14:49:06.604048+00:00", "type": "pullrequest_comment", "id": 49424736}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/40919218.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-40919218"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "Just leaving a reference to this very interesting information @dihm has found regarding the differences between different DAQ counters. Perhaps we now have enough information to make a general solution for the wait monitor acquisition worker.\n\nSee: https://groups.google.com/d/msg/labscriptsuite/6Pax8bkoXfg/gKuVDyo6BgAJ", "markup": "markdown", "html": "<p>Just leaving a reference to this very interesting information @dihm has found regarding the differences between different DAQ counters. Perhaps we now have enough information to make a general solution for the wait monitor acquisition worker.</p>\n<p>See: <a href=\"https://groups.google.com/d/msg/labscriptsuite/6Pax8bkoXfg/gKuVDyo6BgAJ\" rel=\"nofollow\" class=\"ap-connect-link\">https://groups.google.com/d/msg/labscriptsuite/6Pax8bkoXfg/gKuVDyo6BgAJ</a></p>", "type": "rendered"}, "created_on": "2017-07-18T00:34:53.271926+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}, "updated_on": "2017-07-18T00:34:53.280662+00:00", "type": "pullrequest_comment", "id": 40919218}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/45731946.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-45731946"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "Some NI cards don't have Analog outputs. If you set `num_AO` to be 0 the BLACS worker crashes saying it can't start the ao task with no outputs. This can be caught with some simple ifs. I'm not sure if there are cards that don't have digital outs but we might want to add some if clauses there as well just in case", "markup": "markdown", "html": "<p>Some NI cards don't have Analog outputs. If you set <code>num_AO</code> to be 0 the BLACS worker crashes saying it can't start the ao task with no outputs. This can be caught with some simple ifs. I'm not sure if there are cards that don't have digital outs but we might want to add some if clauses there as well just in case</p>", "type": "rendered"}, "created_on": "2017-09-25T15:29:34.157948+00:00", "user": {"display_name": "Jan Werkmann", "uuid": "{44c4905c-2b90-4045-a5f1-652b8e228626}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D"}, "html": {"href": "https://bitbucket.org/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5/07e5095a-4741-4dc0-a462-9c7d455f961d/128"}}, "nickname": "PhyNerd", "type": "user", "account_id": "557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5"}, "updated_on": "2017-09-25T15:29:34.211256+00:00", "type": "pullrequest_comment", "id": 45731946}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/49199765.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-49199765"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "There is also a bug when using static digital Ouputs on line 184. A dict doesn't have the property `static_value`. This should be `digital_out_table = self.convert_bools_to_bytes(digitals.values())` but that causes a bug with labscript which I will make a pull request about over at the labscript repo.", "markup": "markdown", "html": "<p>There is also a bug when using static digital Ouputs on line 184. A dict doesn't have the property <code>static_value</code>. This should be <code>digital_out_table = self.convert_bools_to_bytes(digitals.values())</code> but that causes a bug with labscript which I will make a pull request about over at the labscript repo.</p>", "type": "rendered"}, "created_on": "2017-11-09T14:52:58.044750+00:00", "user": {"display_name": "Jan Werkmann", "uuid": "{44c4905c-2b90-4045-a5f1-652b8e228626}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D"}, "html": {"href": "https://bitbucket.org/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5/07e5095a-4741-4dc0-a462-9c7d455f961d/128"}}, "nickname": "PhyNerd", "type": "user", "account_id": "557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5"}, "updated_on": "2017-11-10T08:58:11.524598+00:00", "type": "pullrequest_comment", "id": 49199765}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/49272979.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-49272979"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "For this to work it should be:\n\n`digital_out_table = self.convert_bools_to_bytes(digitals.values())`\n\nSo you could in theory remove the whole if statement.", "markup": "markdown", "html": "<p>For this to work it should be:</p>\n<p><code>digital_out_table = self.convert_bools_to_bytes(digitals.values())</code></p>\n<p>So you could in theory remove the whole if statement.</p>", "type": "rendered"}, "created_on": "2017-11-10T08:58:58.018972+00:00", "user": {"display_name": "Jan Werkmann", "uuid": "{44c4905c-2b90-4045-a5f1-652b8e228626}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D"}, "html": {"href": "https://bitbucket.org/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5/07e5095a-4741-4dc0-a462-9c7d455f961d/128"}}, "nickname": "PhyNerd", "type": "user", "account_id": "557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5"}, "inline": {"to": 184, "from": null, "path": "NI_DAQmx.py"}, "updated_on": "2017-11-10T09:03:58.969414+00:00", "type": "pullrequest_comment", "id": 49272979}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/49273369.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-49273369"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "This line hinders you from using different amounts of channels in buffered and manual mode and limits your samplerate.  \n I think it can be removed.", "markup": "markdown", "html": "<p>This line hinders you from using different amounts of channels in buffered and manual mode and limits your samplerate.<br />\n I think it can be removed.</p>", "type": "rendered"}, "created_on": "2017-11-10T09:02:38.908479+00:00", "user": {"display_name": "Jan Werkmann", "uuid": "{44c4905c-2b90-4045-a5f1-652b8e228626}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D"}, "html": {"href": "https://bitbucket.org/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5/07e5095a-4741-4dc0-a462-9c7d455f961d/128"}}, "nickname": "PhyNerd", "type": "user", "account_id": "557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5"}, "inline": {"to": 772, "from": null, "path": "NI_DAQmx.py"}, "updated_on": "2017-11-10T09:02:58.386300+00:00", "type": "pullrequest_comment", "id": 49273369}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15/comments/81996528.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15/_/diff#comment-81996528"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 15, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/15.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/15"}}, "title": "JQI generic NI board class"}, "content": {"raw": "This is now superseded by pull request #56", "markup": "markdown", "html": "<p>This is now superseded by <a href=\"#!/labscript_suite/labscript_devices/pull-requests/56/universal-ni-daqmx-support\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #56</a></p>", "type": "rendered"}, "created_on": "2018-11-10T18:01:07.476437+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-11-10T18:01:07.483771+00:00", "type": "pullrequest_comment", "id": 81996528}], "page": 1, "size": 25}