{"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/43/comments/95963895.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/43/_/diff#comment-95963895"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 43, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/43.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/43"}}, "title": "LightCrafter"}, "content": {"raw": "Hi Shaun,\n\nI\u2019ve pushed a few changes to your fork, I hope you don\u2019t mind. They fix an issue we saw in the RbK lab here at NIST, and some other things.\n\nThey:\n\n* add a \\`set\\_array\\` function that lets you set a numpy array instead of a BMP image\n* generate the blank\\_bmp programatically instead of hard-coding a raw BMP in the source code\n* When programming the DMD, always sending a number of images that is a multiple of four - even if there are not going to be enough triggers for all of them. This is done just by sending the final image repeatedly until the total number of images sent is a multiple of four.\n* Fixing an incorrect command constant - though we\u2019re not using it we noticed it was not as in the documentation.\n* Setting the exposure time to zero in line with Ian\u2019s above comment\n\nSending a multiple of four images seemed to fix the issues Amilson was having - remains to be seen if Ian\u2019s speculation about the us of Display Pattern is causing further issues.\n\nBecause Bitbucket won\u2019t not rendering the diff due to the large file size, here it is with the BMP replaced by placeholder text:\n\n\u200c\n\n```diff\ndiff -r 4a504301a4b0 -r 7fb00e82aea5 LightCrafterDMD.py\n--- a/LightCrafterDMD.py    Tue Jul 31 17:24:12 2018 +1000\n+++ b/LightCrafterDMD.py    Thu Mar 21 17:58:32 2019 -0400\n@@ -1,6 +1,6 @@\n #####################################################################\n #                                                                   #\n-# /LightCrafterDMD.py                                                  #\n+# /LightCrafterDMD.py                                               #\n #                                                                   #\n # Copyright 2017, Monash University                                 #\n #                                                                   #\n@@ -15,7 +15,6 @@\n if PY2:\n     str = unicode\n\n-\n # COMMON IMPORTS\n import base64\n import os\n@@ -29,6 +28,12 @@\n # LABSCRIPT IMPORTS\n from labscript import Device, IntermediateDevice, LabscriptError, Output, config\n import numpy as np\n+import PIL\n+if PY2:\n+    from StringIO import StringIO as BytesIO\n+else:\n+    from io import BytesIO\n+\n\n # BLACS IMPORTS\n from blacs.tab_base_classes import Worker, define_state\n@@ -41,27 +46,38 @@\n from qtutils.qt.QtCore import pyqtSignal as Signal\n\n\n-blank_bmp = b'<BMP_RAW_DATA_WAS_HERE>'\n-            \n+def arr_to_bmp(arr):\n+    \"\"\"Convert array to 1 bit BMP, white wherever the array is nonzero, and return a\n+    bytestring of the BMP data\"\"\"\n+    binary_arr = 255 * (arr != 0).astype(np.uint8)\n+    im = PIL.Image.fromarray(binary_arr, mode='L').convert('1')\n+    with BytesIO() as f:\n+        im.save(f, \"BMP\")\n+        return f.getvalue()\n+\n+\n+WIDTH = 608\n+HEIGHT = 684\n+BLANK_BMP = arr_to_bmp(np.zeros((HEIGHT, WIDTH)))\n+\n+\n class ImageSet(Output):\n     description = 'A set of images to be displayed on an SLM or DMD'\n-    width = 608\n-    height = 684\n-    \n+    width = WIDTH\n+    height = HEIGHT\n     # Set default value to be a black image. Here's a raw BMP!\n-    default_value = blank_bmp\n-    \n-    \n+    default_value = BLANK_BMP\n\n     def __init__(self, name, parent_device, connection = 'Mirror'):\n         Output.__init__(self, name, parent_device, connection)\n\n-        \n+    def set_array(self, t, arr):\n+        self.set_image(t, raw=arr_to_bmp(arr))\n\n-    def set_image(self, t, path = None, raw = None):\n-        \n-        \n-        if raw:\n+    def set_image(self, t, path=None, raw=None):\n+        \"\"\"set an image at the given time, either by a filepath to a bmp file,\n+        or by a bytestring of bmp data\"\"\"\n+        if raw is not None:\n             raw_data = raw\n         else:\n             if not os.path.exists(path):\n@@ -69,7 +85,6 @@\n             # First rough check that the path leads to a .bmp file\n             if len(path) < 5 or path[-4:] != '.bmp':\n                 raise LabscriptError('Error loading image for DMD output %s: The image does not appear to be in bmp format(path: %s) Length: %s, end: %s'%(self.name, path, len(path),path[-4:] ))\n-            raw_data = ''        \n             with open(path, 'rb') as f:\n                 raw_data = f.read()\n         # Check that the image is a BMP, first two bytes should be \"BM\"\n@@ -110,8 +125,8 @@\n     # I'm assuming that we'll only be using the device for black & white images with bitdepth of 1.\n     max_instructions = 96\n     clock_limit = 4000\n-    width = 608\n-    height = 684\n+    width = WIDTH\n+    height = HEIGHT\n\n     def __init__(self, name, parent_device, server = '192.168.1.100', port=21845):\n         IntermediateDevice.__init__(self, name, parent_device)\n@@ -193,7 +208,7 @@\n                 'pattern_definition':   b'\\x04\\x01',\n                 'start_pattern_sequence': b'\\x04\\x02',\n                 'display_pattern' :     b'\\x04\\x05',\n-                'advance_pattern_sequence' : b'\\x04\\x02',\n+                'advance_pattern_sequence' : b'\\x04\\x03',\n                 }\n     send_packet_type = {   'read': b'\\x04',\n                             'write': b'\\x02',\n@@ -300,7 +315,7 @@\n             data = base64.b64decode(data)\n         # Replace empty data with the black picture\n         if not data:\n-            data = blank_bmp\n+            data = BLANK_BMP\n         ## Check to see if it's a BMP\n\n\n@@ -322,13 +337,20 @@\n             oldtable = self.smart_cache['IMAGE_TABLE']\n             self.send(self.send_packet_type['write'], self.command['display_mode'], self.display_mode['pattern'])\n             num_of_patterns = len(table_data)\n+            # We will pad the images we send up to a multiple of four:\n+            padded_num_of_patterns = num_of_patterns + (-num_of_patterns % 4)\n\n             # bit depth, number of patterns, invert patterns?, trigger type, trigger delay (4 bytes), trigger period (4 bytes), exposure time (4 bytes), led select\n-            self.send(self.send_packet_type['write'], self.command['sequence_setting'],  struct.pack('<BBBBiiiB',1,num_of_patterns,0,2,0,0,250,0))\n+            self.send(self.send_packet_type['write'], self.command['sequence_setting'],  struct.pack('<BBBBiiiB',1,padded_num_of_patterns,0,2,0,0,0,0))\n             if fresh or len(oldtable)!=len(table_data) or (oldtable != table_data).any():\n-                for i, im in enumerate(table_data):\n+                for i in range(padded_num_of_patterns):\n+                    if i < num_of_patterns:\n+                        im = table_data[i]\n+                    else:\n+                        # Padding uses the final image:\n+                        im = table_data[-1]\n                     self.send(self.send_packet_type['write'], self.command['pattern_definition'], struct.pack('<B',i) + im.tostring())\n-            \n+                \n             self.send(self.send_packet_type['write'], self.command['display_pattern'], struct.pack('<H',0))\n             self.send(self.send_packet_type['write'], self.command['start_pattern_sequence'], struct.pack('<B',1))\n             self.smart_cache['IMAGE_TABLE'] = table_data\n@@ -361,4 +383,4 @@\n         return self.abort()\n\n     def shutdown(self):\n-        self.sock.close()\n\\ No newline at end of file\n+        self.sock.close()\n```\n\n\u200c", "markup": "markdown", "html": "<p>Hi Shaun,</p>\n<p>I\u2019ve pushed a few changes to your fork, I hope you don\u2019t mind. They fix an issue we saw in the RbK lab here at NIST, and some other things.</p>\n<p>They:</p>\n<ul>\n<li>add a `set_array` function that lets you set a numpy array instead of a BMP image</li>\n<li>generate the blank_bmp programatically instead of hard-coding a raw BMP in the source code</li>\n<li>When programming the DMD, always sending a number of images that is a multiple of four - even if there are not going to be enough triggers for all of them. This is done just by sending the final image repeatedly until the total number of images sent is a multiple of four.</li>\n<li>Fixing an incorrect command constant - though we\u2019re not using it we noticed it was not as in the documentation.</li>\n<li>Setting the exposure time to zero in line with Ian\u2019s above comment</li>\n</ul>\n<p>Sending a multiple of four images seemed to fix the issues Amilson was having - remains to be seen if Ian\u2019s speculation about the us of Display Pattern is causing further issues.</p>\n<p>Because Bitbucket won\u2019t not rendering the diff due to the large file size, here it is with the BMP replaced by placeholder text:</p>\n<p>\u200c</p>\n<div class=\"codehilite language-diff\"><pre><span></span><span class=\"gh\">diff -r 4a504301a4b0 -r 7fb00e82aea5 LightCrafterDMD.py</span>\n<span class=\"gd\">--- a/LightCrafterDMD.py    Tue Jul 31 17:24:12 2018 +1000</span>\n<span class=\"gi\">+++ b/LightCrafterDMD.py    Thu Mar 21 17:58:32 2019 -0400</span>\n<span class=\"gu\">@@ -1,6 +1,6 @@</span>\n #####################################################################\n #                                                                   #\n<span class=\"gd\">-# /LightCrafterDMD.py                                                  #</span>\n<span class=\"gi\">+# /LightCrafterDMD.py                                               #</span>\n #                                                                   #\n # Copyright 2017, Monash University                                 #\n #                                                                   #\n<span class=\"gu\">@@ -15,7 +15,6 @@</span>\n if PY2:\n     str = unicode\n\n<span class=\"gd\">-</span>\n # COMMON IMPORTS\n import base64\n import os\n<span class=\"gu\">@@ -29,6 +28,12 @@</span>\n # LABSCRIPT IMPORTS\n from labscript import Device, IntermediateDevice, LabscriptError, Output, config\n import numpy as np\n<span class=\"gi\">+import PIL</span>\n<span class=\"gi\">+if PY2:</span>\n<span class=\"gi\">+    from StringIO import StringIO as BytesIO</span>\n<span class=\"gi\">+else:</span>\n<span class=\"gi\">+    from io import BytesIO</span>\n<span class=\"gi\">+</span>\n\n # BLACS IMPORTS\n from blacs.tab_base_classes import Worker, define_state\n<span class=\"gu\">@@ -41,27 +46,38 @@</span>\n from qtutils.qt.QtCore import pyqtSignal as Signal\n\n\n<span class=\"gd\">-blank_bmp = b&#39;&lt;BMP_RAW_DATA_WAS_HERE&gt;&#39;</span>\n<span class=\"gd\">-            </span>\n<span class=\"gi\">+def arr_to_bmp(arr):</span>\n<span class=\"gi\">+    &quot;&quot;&quot;Convert array to 1 bit BMP, white wherever the array is nonzero, and return a</span>\n<span class=\"gi\">+    bytestring of the BMP data&quot;&quot;&quot;</span>\n<span class=\"gi\">+    binary_arr = 255 * (arr != 0).astype(np.uint8)</span>\n<span class=\"gi\">+    im = PIL.Image.fromarray(binary_arr, mode=&#39;L&#39;).convert(&#39;1&#39;)</span>\n<span class=\"gi\">+    with BytesIO() as f:</span>\n<span class=\"gi\">+        im.save(f, &quot;BMP&quot;)</span>\n<span class=\"gi\">+        return f.getvalue()</span>\n<span class=\"gi\">+</span>\n<span class=\"gi\">+</span>\n<span class=\"gi\">+WIDTH = 608</span>\n<span class=\"gi\">+HEIGHT = 684</span>\n<span class=\"gi\">+BLANK_BMP = arr_to_bmp(np.zeros((HEIGHT, WIDTH)))</span>\n<span class=\"gi\">+</span>\n<span class=\"gi\">+</span>\n class ImageSet(Output):\n     description = &#39;A set of images to be displayed on an SLM or DMD&#39;\n<span class=\"gd\">-    width = 608</span>\n<span class=\"gd\">-    height = 684</span>\n<span class=\"gd\">-    </span>\n<span class=\"gi\">+    width = WIDTH</span>\n<span class=\"gi\">+    height = HEIGHT</span>\n     # Set default value to be a black image. Here&#39;s a raw BMP!\n<span class=\"gd\">-    default_value = blank_bmp</span>\n<span class=\"gd\">-    </span>\n<span class=\"gd\">-    </span>\n<span class=\"gi\">+    default_value = BLANK_BMP</span>\n\n     def __init__(self, name, parent_device, connection = &#39;Mirror&#39;):\n         Output.__init__(self, name, parent_device, connection)\n\n<span class=\"gd\">-        </span>\n<span class=\"gi\">+    def set_array(self, t, arr):</span>\n<span class=\"gi\">+        self.set_image(t, raw=arr_to_bmp(arr))</span>\n\n<span class=\"gd\">-    def set_image(self, t, path = None, raw = None):</span>\n<span class=\"gd\">-        </span>\n<span class=\"gd\">-        </span>\n<span class=\"gd\">-        if raw:</span>\n<span class=\"gi\">+    def set_image(self, t, path=None, raw=None):</span>\n<span class=\"gi\">+        &quot;&quot;&quot;set an image at the given time, either by a filepath to a bmp file,</span>\n<span class=\"gi\">+        or by a bytestring of bmp data&quot;&quot;&quot;</span>\n<span class=\"gi\">+        if raw is not None:</span>\n             raw_data = raw\n         else:\n             if not os.path.exists(path):\n<span class=\"gu\">@@ -69,7 +85,6 @@</span>\n             # First rough check that the path leads to a .bmp file\n             if len(path) &lt; 5 or path[-4:] != &#39;.bmp&#39;:\n                 raise LabscriptError(&#39;Error loading image for DMD output %s: The image does not appear to be in bmp format(path: %s) Length: %s, end: %s&#39;%(self.name, path, len(path),path[-4:] ))\n<span class=\"gd\">-            raw_data = &#39;&#39;        </span>\n             with open(path, &#39;rb&#39;) as f:\n                 raw_data = f.read()\n         # Check that the image is a BMP, first two bytes should be &quot;BM&quot;\n<span class=\"gu\">@@ -110,8 +125,8 @@</span>\n     # I&#39;m assuming that we&#39;ll only be using the device for black &amp; white images with bitdepth of 1.\n     max_instructions = 96\n     clock_limit = 4000\n<span class=\"gd\">-    width = 608</span>\n<span class=\"gd\">-    height = 684</span>\n<span class=\"gi\">+    width = WIDTH</span>\n<span class=\"gi\">+    height = HEIGHT</span>\n\n     def __init__(self, name, parent_device, server = &#39;192.168.1.100&#39;, port=21845):\n         IntermediateDevice.__init__(self, name, parent_device)\n<span class=\"gu\">@@ -193,7 +208,7 @@</span>\n                 &#39;pattern_definition&#39;:   b&#39;\\x04\\x01&#39;,\n                 &#39;start_pattern_sequence&#39;: b&#39;\\x04\\x02&#39;,\n                 &#39;display_pattern&#39; :     b&#39;\\x04\\x05&#39;,\n<span class=\"gd\">-                &#39;advance_pattern_sequence&#39; : b&#39;\\x04\\x02&#39;,</span>\n<span class=\"gi\">+                &#39;advance_pattern_sequence&#39; : b&#39;\\x04\\x03&#39;,</span>\n                 }\n     send_packet_type = {   &#39;read&#39;: b&#39;\\x04&#39;,\n                             &#39;write&#39;: b&#39;\\x02&#39;,\n<span class=\"gu\">@@ -300,7 +315,7 @@</span>\n             data = base64.b64decode(data)\n         # Replace empty data with the black picture\n         if not data:\n<span class=\"gd\">-            data = blank_bmp</span>\n<span class=\"gi\">+            data = BLANK_BMP</span>\n         ## Check to see if it&#39;s a BMP\n\n\n<span class=\"gu\">@@ -322,13 +337,20 @@</span>\n             oldtable = self.smart_cache[&#39;IMAGE_TABLE&#39;]\n             self.send(self.send_packet_type[&#39;write&#39;], self.command[&#39;display_mode&#39;], self.display_mode[&#39;pattern&#39;])\n             num_of_patterns = len(table_data)\n<span class=\"gi\">+            # We will pad the images we send up to a multiple of four:</span>\n<span class=\"gi\">+            padded_num_of_patterns = num_of_patterns + (-num_of_patterns % 4)</span>\n\n             # bit depth, number of patterns, invert patterns?, trigger type, trigger delay (4 bytes), trigger period (4 bytes), exposure time (4 bytes), led select\n<span class=\"gd\">-            self.send(self.send_packet_type[&#39;write&#39;], self.command[&#39;sequence_setting&#39;],  struct.pack(&#39;&lt;BBBBiiiB&#39;,1,num_of_patterns,0,2,0,0,250,0))</span>\n<span class=\"gi\">+            self.send(self.send_packet_type[&#39;write&#39;], self.command[&#39;sequence_setting&#39;],  struct.pack(&#39;&lt;BBBBiiiB&#39;,1,padded_num_of_patterns,0,2,0,0,0,0))</span>\n             if fresh or len(oldtable)!=len(table_data) or (oldtable != table_data).any():\n<span class=\"gd\">-                for i, im in enumerate(table_data):</span>\n<span class=\"gi\">+                for i in range(padded_num_of_patterns):</span>\n<span class=\"gi\">+                    if i &lt; num_of_patterns:</span>\n<span class=\"gi\">+                        im = table_data[i]</span>\n<span class=\"gi\">+                    else:</span>\n<span class=\"gi\">+                        # Padding uses the final image:</span>\n<span class=\"gi\">+                        im = table_data[-1]</span>\n                     self.send(self.send_packet_type[&#39;write&#39;], self.command[&#39;pattern_definition&#39;], struct.pack(&#39;&lt;B&#39;,i) + im.tostring())\n<span class=\"gd\">-            </span>\n<span class=\"gi\">+                </span>\n             self.send(self.send_packet_type[&#39;write&#39;], self.command[&#39;display_pattern&#39;], struct.pack(&#39;&lt;H&#39;,0))\n             self.send(self.send_packet_type[&#39;write&#39;], self.command[&#39;start_pattern_sequence&#39;], struct.pack(&#39;&lt;B&#39;,1))\n             self.smart_cache[&#39;IMAGE_TABLE&#39;] = table_data\n<span class=\"gu\">@@ -361,4 +383,4 @@</span>\n         return self.abort()\n\n     def shutdown(self):\n<span class=\"gd\">-        self.sock.close()</span>\n\\ No newline at end of file\n<span class=\"gi\">+        self.sock.close()</span>\n</pre></div>\n\n\n<p>\u200c</p>", "type": "rendered"}, "created_on": "2019-03-21T22:15:50.680779+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-03-21T22:17:54.025738+00:00", "type": "pullrequest_comment", "id": 95963895}