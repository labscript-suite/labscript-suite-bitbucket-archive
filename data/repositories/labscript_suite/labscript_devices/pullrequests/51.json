{"rendered": {"description": {"raw": "Added mechanism to allow arbitrary code organisation within the labscript_devices folder.\r\n\r\nConverted dummy pseudoclock to use this new mechanism as an example.\r\n\r\nRemoved unnecessary @labscript_device and @BLACS_worker decorators throughout.\r\n\r\nDepend on BLACS 2.4.0, as the dummy pseudoclock now stores its worker class in a separate file and references it by name as per [BLACS pull request #54](#!/labscript_suite/blacs/pull-requests/54/defer-worker-imports)\r\n\r\nBelow is a copy and paste of the comment I've put at the top of `__init__.py` that explains the new mechanism. In order to have arbitrary freedom on code organisation, there must be extra files that declare what the BLACS tab and runviewer parsers are for each labscript device. After some thought this seems to me like a good way to do things - to abandon all naming conventions for looking up classes in certain files, so that classes may be arbitrarily organised in whatever files make sense for the task at hand. The only remaining naming convention is that `labscript_devices` will look for files called \"register_classes.py\" located within any subfolders, and run them. These files contain explicit information saying what the BLACS tab and runviewer parsers are. See the dummy pseudoclock code in the diff for an example.\r\n\r\nIf this mechanism is agreeable, after merging this I'll port the other devices one-by-one to subfolders when the time is right for each of them (i.e. when they have no pending pull requests this would break).\r\n\r\n```\r\nThis file contains the machinery for registering and looking up what BLACS tab and\r\nrunviewer parser classes belong to a particular labscript device. \"labscript_device\"\r\nhere means a device that BLACS needs to communicate with. These devices have\r\ninstructions saved within the 'devices' group of the HDF5 file, and have a tab\r\ncorresponding to them in the BLACS interface. These device classes must have unique\r\nnames, such as \"PineBlaster\" or \"PulseBlaster\" etc.\r\n\r\nThere are two methods we use to find out which BLACS tab and runviewer parser correspond\r\nto a device class: the \"old\" method, and the \"new\" method. The old method requires that\r\nthe the BLACS tab and runviewer parser be in a file called <DeviceName>.py at the top\r\nlevel of labscript_devices folder, and that they have class decorators @BLACS_tab or\r\n@runviewer_parser to identify them. This method precludes putting code in subfolders or\r\nsplitting it across multiple files.\r\n\r\nThe \"new\" method is more flexible. It allows BLACS tabs and runviewer parsers to be\r\ndefined in any importable file within a subfolder of labscript_devices. Classes using\r\nthis method can be in files with any name, and do not need class decorators. Instead,\r\nthe classes should be registered by creating a file called 'register_classes.py', which\r\nwhen imported, makes calls to labscript_devices.register_classes() to tell register\r\nwhich BLACS tab and runviewer parser class belong to each device. Tab and parser classes\r\nmust be passed to register_classes() as fully qualified names, i.e.\r\n\"labscript_devices.submodule.ClassName\", not by passing in the classes themselves. This\r\nensures imports can be deferred until the classes are actually needed. When BLACS and\r\nrunviewer look up classes with get_BLACS_tab() and get_runviewer_parser(),\r\npopulate_registry() will be called in order to find all files called\r\n'register_classes.py' within subfolders (at any depth) of labscript_devices, and they\r\nwill be imported to run their code and hence register their classes.\r\n\r\nThe \"new\" method does not impose any restrictions on code organisation within subfolders\r\nof labscript_devices, and so is preferable as it allows auxiliary utilities or resource\r\nfiles to live in subfolders alongside the device code to which they are relevant, the\r\nuse of subrepositories, the grouping of similar devices within subfolders, and other\r\nnice things to have.\r\n\r\nThe old method may be deprecated in the future.\r\n```", "markup": "markdown", "html": "<p>Added mechanism to allow arbitrary code organisation within the labscript_devices folder.</p>\n<p>Converted dummy pseudoclock to use this new mechanism as an example.</p>\n<p>Removed unnecessary @labscript_device and @BLACS_worker decorators throughout.</p>\n<p>Depend on BLACS 2.4.0, as the dummy pseudoclock now stores its worker class in a separate file and references it by name as per <a data-is-external-link=\"true\" href=\"#!/labscript_suite/blacs/pull-requests/54/defer-worker-imports\" rel=\"nofollow\">BLACS pull request #54</a></p>\n<p>Below is a copy and paste of the comment I've put at the top of <code>__init__.py</code> that explains the new mechanism. In order to have arbitrary freedom on code organisation, there must be extra files that declare what the BLACS tab and runviewer parsers are for each labscript device. After some thought this seems to me like a good way to do things - to abandon all naming conventions for looking up classes in certain files, so that classes may be arbitrarily organised in whatever files make sense for the task at hand. The only remaining naming convention is that <code>labscript_devices</code> will look for files called \"register_classes.py\" located within any subfolders, and run them. These files contain explicit information saying what the BLACS tab and runviewer parsers are. See the dummy pseudoclock code in the diff for an example.</p>\n<p>If this mechanism is agreeable, after merging this I'll port the other devices one-by-one to subfolders when the time is right for each of them (i.e. when they have no pending pull requests this would break).</p>\n<div class=\"codehilite\"><pre><span></span>This file contains the machinery for registering and looking up what BLACS tab and\nrunviewer parser classes belong to a particular labscript device. &quot;labscript_device&quot;\nhere means a device that BLACS needs to communicate with. These devices have\ninstructions saved within the &#39;devices&#39; group of the HDF5 file, and have a tab\ncorresponding to them in the BLACS interface. These device classes must have unique\nnames, such as &quot;PineBlaster&quot; or &quot;PulseBlaster&quot; etc.\n\nThere are two methods we use to find out which BLACS tab and runviewer parser correspond\nto a device class: the &quot;old&quot; method, and the &quot;new&quot; method. The old method requires that\nthe the BLACS tab and runviewer parser be in a file called &lt;DeviceName&gt;.py at the top\nlevel of labscript_devices folder, and that they have class decorators @BLACS_tab or\n@runviewer_parser to identify them. This method precludes putting code in subfolders or\nsplitting it across multiple files.\n\nThe &quot;new&quot; method is more flexible. It allows BLACS tabs and runviewer parsers to be\ndefined in any importable file within a subfolder of labscript_devices. Classes using\nthis method can be in files with any name, and do not need class decorators. Instead,\nthe classes should be registered by creating a file called &#39;register_classes.py&#39;, which\nwhen imported, makes calls to labscript_devices.register_classes() to tell register\nwhich BLACS tab and runviewer parser class belong to each device. Tab and parser classes\nmust be passed to register_classes() as fully qualified names, i.e.\n&quot;labscript_devices.submodule.ClassName&quot;, not by passing in the classes themselves. This\nensures imports can be deferred until the classes are actually needed. When BLACS and\nrunviewer look up classes with get_BLACS_tab() and get_runviewer_parser(),\npopulate_registry() will be called in order to find all files called\n&#39;register_classes.py&#39; within subfolders (at any depth) of labscript_devices, and they\nwill be imported to run their code and hence register their classes.\n\nThe &quot;new&quot; method does not impose any restrictions on code organisation within subfolders\nof labscript_devices, and so is preferable as it allows auxiliary utilities or resource\nfiles to live in subfolders alongside the device code to which they are relevant, the\nuse of subrepositories, the grouping of similar devices within subfolders, and other\nnice things to have.\n\nThe old method may be deprecated in the future.\n</pre></div>", "type": "rendered"}, "title": {"raw": "Arbitrary subfolders for device code within labscript_devices", "markup": "markdown", "html": "<p>Arbitrary subfolders for device code within labscript_devices</p>", "type": "rendered"}}, "type": "pullrequest", "description": "Added mechanism to allow arbitrary code organisation within the labscript_devices folder.\r\n\r\nConverted dummy pseudoclock to use this new mechanism as an example.\r\n\r\nRemoved unnecessary @labscript_device and @BLACS_worker decorators throughout.\r\n\r\nDepend on BLACS 2.4.0, as the dummy pseudoclock now stores its worker class in a separate file and references it by name as per [BLACS pull request #54](#!/labscript_suite/blacs/pull-requests/54/defer-worker-imports)\r\n\r\nBelow is a copy and paste of the comment I've put at the top of `__init__.py` that explains the new mechanism. In order to have arbitrary freedom on code organisation, there must be extra files that declare what the BLACS tab and runviewer parsers are for each labscript device. After some thought this seems to me like a good way to do things - to abandon all naming conventions for looking up classes in certain files, so that classes may be arbitrarily organised in whatever files make sense for the task at hand. The only remaining naming convention is that `labscript_devices` will look for files called \"register_classes.py\" located within any subfolders, and run them. These files contain explicit information saying what the BLACS tab and runviewer parsers are. See the dummy pseudoclock code in the diff for an example.\r\n\r\nIf this mechanism is agreeable, after merging this I'll port the other devices one-by-one to subfolders when the time is right for each of them (i.e. when they have no pending pull requests this would break).\r\n\r\n```\r\nThis file contains the machinery for registering and looking up what BLACS tab and\r\nrunviewer parser classes belong to a particular labscript device. \"labscript_device\"\r\nhere means a device that BLACS needs to communicate with. These devices have\r\ninstructions saved within the 'devices' group of the HDF5 file, and have a tab\r\ncorresponding to them in the BLACS interface. These device classes must have unique\r\nnames, such as \"PineBlaster\" or \"PulseBlaster\" etc.\r\n\r\nThere are two methods we use to find out which BLACS tab and runviewer parser correspond\r\nto a device class: the \"old\" method, and the \"new\" method. The old method requires that\r\nthe the BLACS tab and runviewer parser be in a file called <DeviceName>.py at the top\r\nlevel of labscript_devices folder, and that they have class decorators @BLACS_tab or\r\n@runviewer_parser to identify them. This method precludes putting code in subfolders or\r\nsplitting it across multiple files.\r\n\r\nThe \"new\" method is more flexible. It allows BLACS tabs and runviewer parsers to be\r\ndefined in any importable file within a subfolder of labscript_devices. Classes using\r\nthis method can be in files with any name, and do not need class decorators. Instead,\r\nthe classes should be registered by creating a file called 'register_classes.py', which\r\nwhen imported, makes calls to labscript_devices.register_classes() to tell register\r\nwhich BLACS tab and runviewer parser class belong to each device. Tab and parser classes\r\nmust be passed to register_classes() as fully qualified names, i.e.\r\n\"labscript_devices.submodule.ClassName\", not by passing in the classes themselves. This\r\nensures imports can be deferred until the classes are actually needed. When BLACS and\r\nrunviewer look up classes with get_BLACS_tab() and get_runviewer_parser(),\r\npopulate_registry() will be called in order to find all files called\r\n'register_classes.py' within subfolders (at any depth) of labscript_devices, and they\r\nwill be imported to run their code and hence register their classes.\r\n\r\nThe \"new\" method does not impose any restrictions on code organisation within subfolders\r\nof labscript_devices, and so is preferable as it allows auxiliary utilities or resource\r\nfiles to live in subfolders alongside the device code to which they are relevant, the\r\nuse of subrepositories, the grouping of similar devices within subfolders, and other\r\nnice things to have.\r\n\r\nThe old method may be deprecated in the future.\r\n```", "links": {"decline": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/pullrequests/51/decline"}, "diffstat": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/diffstat/labscript_suite/labscript_devices:2f2fd7b5772c%0D970f46e8bd30?from_pullrequest_id=51"}, "commits": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/commits.json"}, "self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51.json"}, "comments": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/comments_page=1.json"}, "merge": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/pullrequests/51/merge"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51"}, "activity": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/activity.json"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/diff/labscript_suite/labscript_devices:2f2fd7b5772c%0D970f46e8bd30?from_pullrequest_id=51"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/pullrequests/51/approve"}, "statuses": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/statuses_page=1.json"}}, "title": "Arbitrary subfolders for device code within labscript_devices", "close_source_branch": true, "reviewers": [{"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}], "id": 51, "destination": {"commit": {"hash": "970f46e8bd30", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/970f46e8bd30.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/970f46e8bd30"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "created_on": "2018-09-27T16:55:05.113718+00:00", "summary": {"raw": "Added mechanism to allow arbitrary code organisation within the labscript_devices folder.\r\n\r\nConverted dummy pseudoclock to use this new mechanism as an example.\r\n\r\nRemoved unnecessary @labscript_device and @BLACS_worker decorators throughout.\r\n\r\nDepend on BLACS 2.4.0, as the dummy pseudoclock now stores its worker class in a separate file and references it by name as per [BLACS pull request #54](#!/labscript_suite/blacs/pull-requests/54/defer-worker-imports)\r\n\r\nBelow is a copy and paste of the comment I've put at the top of `__init__.py` that explains the new mechanism. In order to have arbitrary freedom on code organisation, there must be extra files that declare what the BLACS tab and runviewer parsers are for each labscript device. After some thought this seems to me like a good way to do things - to abandon all naming conventions for looking up classes in certain files, so that classes may be arbitrarily organised in whatever files make sense for the task at hand. The only remaining naming convention is that `labscript_devices` will look for files called \"register_classes.py\" located within any subfolders, and run them. These files contain explicit information saying what the BLACS tab and runviewer parsers are. See the dummy pseudoclock code in the diff for an example.\r\n\r\nIf this mechanism is agreeable, after merging this I'll port the other devices one-by-one to subfolders when the time is right for each of them (i.e. when they have no pending pull requests this would break).\r\n\r\n```\r\nThis file contains the machinery for registering and looking up what BLACS tab and\r\nrunviewer parser classes belong to a particular labscript device. \"labscript_device\"\r\nhere means a device that BLACS needs to communicate with. These devices have\r\ninstructions saved within the 'devices' group of the HDF5 file, and have a tab\r\ncorresponding to them in the BLACS interface. These device classes must have unique\r\nnames, such as \"PineBlaster\" or \"PulseBlaster\" etc.\r\n\r\nThere are two methods we use to find out which BLACS tab and runviewer parser correspond\r\nto a device class: the \"old\" method, and the \"new\" method. The old method requires that\r\nthe the BLACS tab and runviewer parser be in a file called <DeviceName>.py at the top\r\nlevel of labscript_devices folder, and that they have class decorators @BLACS_tab or\r\n@runviewer_parser to identify them. This method precludes putting code in subfolders or\r\nsplitting it across multiple files.\r\n\r\nThe \"new\" method is more flexible. It allows BLACS tabs and runviewer parsers to be\r\ndefined in any importable file within a subfolder of labscript_devices. Classes using\r\nthis method can be in files with any name, and do not need class decorators. Instead,\r\nthe classes should be registered by creating a file called 'register_classes.py', which\r\nwhen imported, makes calls to labscript_devices.register_classes() to tell register\r\nwhich BLACS tab and runviewer parser class belong to each device. Tab and parser classes\r\nmust be passed to register_classes() as fully qualified names, i.e.\r\n\"labscript_devices.submodule.ClassName\", not by passing in the classes themselves. This\r\nensures imports can be deferred until the classes are actually needed. When BLACS and\r\nrunviewer look up classes with get_BLACS_tab() and get_runviewer_parser(),\r\npopulate_registry() will be called in order to find all files called\r\n'register_classes.py' within subfolders (at any depth) of labscript_devices, and they\r\nwill be imported to run their code and hence register their classes.\r\n\r\nThe \"new\" method does not impose any restrictions on code organisation within subfolders\r\nof labscript_devices, and so is preferable as it allows auxiliary utilities or resource\r\nfiles to live in subfolders alongside the device code to which they are relevant, the\r\nuse of subrepositories, the grouping of similar devices within subfolders, and other\r\nnice things to have.\r\n\r\nThe old method may be deprecated in the future.\r\n```", "markup": "markdown", "html": "<p>Added mechanism to allow arbitrary code organisation within the labscript_devices folder.</p>\n<p>Converted dummy pseudoclock to use this new mechanism as an example.</p>\n<p>Removed unnecessary @labscript_device and @BLACS_worker decorators throughout.</p>\n<p>Depend on BLACS 2.4.0, as the dummy pseudoclock now stores its worker class in a separate file and references it by name as per <a data-is-external-link=\"true\" href=\"#!/labscript_suite/blacs/pull-requests/54/defer-worker-imports\" rel=\"nofollow\">BLACS pull request #54</a></p>\n<p>Below is a copy and paste of the comment I've put at the top of <code>__init__.py</code> that explains the new mechanism. In order to have arbitrary freedom on code organisation, there must be extra files that declare what the BLACS tab and runviewer parsers are for each labscript device. After some thought this seems to me like a good way to do things - to abandon all naming conventions for looking up classes in certain files, so that classes may be arbitrarily organised in whatever files make sense for the task at hand. The only remaining naming convention is that <code>labscript_devices</code> will look for files called \"register_classes.py\" located within any subfolders, and run them. These files contain explicit information saying what the BLACS tab and runviewer parsers are. See the dummy pseudoclock code in the diff for an example.</p>\n<p>If this mechanism is agreeable, after merging this I'll port the other devices one-by-one to subfolders when the time is right for each of them (i.e. when they have no pending pull requests this would break).</p>\n<div class=\"codehilite\"><pre><span></span>This file contains the machinery for registering and looking up what BLACS tab and\nrunviewer parser classes belong to a particular labscript device. &quot;labscript_device&quot;\nhere means a device that BLACS needs to communicate with. These devices have\ninstructions saved within the &#39;devices&#39; group of the HDF5 file, and have a tab\ncorresponding to them in the BLACS interface. These device classes must have unique\nnames, such as &quot;PineBlaster&quot; or &quot;PulseBlaster&quot; etc.\n\nThere are two methods we use to find out which BLACS tab and runviewer parser correspond\nto a device class: the &quot;old&quot; method, and the &quot;new&quot; method. The old method requires that\nthe the BLACS tab and runviewer parser be in a file called &lt;DeviceName&gt;.py at the top\nlevel of labscript_devices folder, and that they have class decorators @BLACS_tab or\n@runviewer_parser to identify them. This method precludes putting code in subfolders or\nsplitting it across multiple files.\n\nThe &quot;new&quot; method is more flexible. It allows BLACS tabs and runviewer parsers to be\ndefined in any importable file within a subfolder of labscript_devices. Classes using\nthis method can be in files with any name, and do not need class decorators. Instead,\nthe classes should be registered by creating a file called &#39;register_classes.py&#39;, which\nwhen imported, makes calls to labscript_devices.register_classes() to tell register\nwhich BLACS tab and runviewer parser class belong to each device. Tab and parser classes\nmust be passed to register_classes() as fully qualified names, i.e.\n&quot;labscript_devices.submodule.ClassName&quot;, not by passing in the classes themselves. This\nensures imports can be deferred until the classes are actually needed. When BLACS and\nrunviewer look up classes with get_BLACS_tab() and get_runviewer_parser(),\npopulate_registry() will be called in order to find all files called\n&#39;register_classes.py&#39; within subfolders (at any depth) of labscript_devices, and they\nwill be imported to run their code and hence register their classes.\n\nThe &quot;new&quot; method does not impose any restrictions on code organisation within subfolders\nof labscript_devices, and so is preferable as it allows auxiliary utilities or resource\nfiles to live in subfolders alongside the device code to which they are relevant, the\nuse of subrepositories, the grouping of similar devices within subfolders, and other\nnice things to have.\n\nThe old method may be deprecated in the future.\n</pre></div>", "type": "rendered"}, "source": {"commit": {"hash": "b093484bf12e", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/b093484bf12e"}, "html": {"href": "#!/cbillington/labscript_devices/commits/b093484bf12e"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "arbitrary_subfolders"}}, "comment_count": 11, "state": "MERGED", "task_count": 0, "participants": [{"role": "PARTICIPANT", "participated_on": "2018-10-02T18:19:03.794184+00:00", "type": "participant", "approved": false, "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}}, {"role": "REVIEWER", "participated_on": "2018-10-03T00:13:21.429331+00:00", "type": "participant", "approved": false, "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}}], "reason": "", "updated_on": "2018-10-03T14:51:20.557745+00:00", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "merge_commit": {"hash": "2f2fd7b5772c", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/2f2fd7b5772c.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/2f2fd7b5772c"}}}, "closed_by": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}}