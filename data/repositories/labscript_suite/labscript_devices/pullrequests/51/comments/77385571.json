{"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/comments/77385571.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51/_/diff#comment-77385571"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 51, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51"}}, "title": "Arbitrary subfolders for device code within labscript_devices"}, "content": {"raw": "To show that I put some thought into this and it isn't just the first method that popped into my head, here are some ideas I rejected.\n\nFor example, I first thought there could be a global registry of what BLACS tab and runviewer parser classes belong to each device, say as a `.json` file at the top level of `labscript_devices`. Then I realised a single file for this would make it tricky to use something like subrepositories. It is nice having the information local to each subfolder of `labscript_devices`, since we might imagine swapping out whole folders, or groups adding their own devices as a subrepository. Merging of branches containing different folders will also have no merge conflicts compared to having to always merge this one file. So I figured the data describing what classes belong to each other should be in however many files you want: `labscript_devices` can just look through the whole folder hierarchy for them.\n\nI also decided against the mapping of device to tab/parser classes being just a data format like a `.json` file. For example, I'm working on a generic NI_DAQmx device class, which may have many subclasses for different models. All the subclasses will have the same BLACS tab, so using a `.py` file to register the classes is better since it can just have a for loop, instead of having a lot of repetition in a `.json` file. The NI_DAQmx subclasses might even be generated completely programmatically (even if they are not in this case, it would be good to not rule this out for other code).\n\nFinally, I thought that perhaps the information should be so local that it is defined in the labscript device class itself, as an instance attribute or an argument to a class decorator or whatnot. That way every labscript device class would know what its runviewer parser and BLACS tab are, and can save them to the HDF5 file. However, this makes it difficult to refactor labscript_devices in the future, if the HDF5 files contain a fully qualified name of a BLACS tab class such as 'labscript_devices.PulseBlaster.tab.PulseBlasterTab'. It would be better if the HDF5 file just had the name of the device 'PulseBlaster', and if BLACS could look up the classes at run time. That way if the classes move due to refactoring, so long as the corresponding `register_classes.py` file is updated at the same time, BLACS will always be able to find the tab, whether the shot file was compiled before the refactoring, or if the computer doing the compilation has a previous version of `labscript_devices`. Basically, we want to leave the door open to refactoring without breaking backward compatibility, and looking up where the classes are last-minute is conducive to this.\n\nSo the mechanism I've made here is compatible with arbitrary deletion and addition of subfolders/subrepositories as a way of adding/removing device support, is compatible with programatically generating device classes and using for loops instead of repeating oneself a whole lot to declare what the tab and parser classes are for a bunch of devices if they have a lot in common, and is compatible with being able to move the classes around without breaking backward compatibility with running old shots or ones compiled on a computer with an older version of `labscript_devices`. It is also compatible with storing BLACS tabs and runviewer parsers in separate files, such that BLACS machinery doesn't need to be imported to import labscript classes.\n\nAlso, moving existing classes to subfolders can be done in a way fully backward compatible with existing labscript code, since a subfolder called `PulseBlaster` with code in an `__init__.py` will be imported the same as if the code were in a file called `PulseBlaster.py` at the top level. So we can move existing files to subfolders without breaking import lines in existing experiments.", "markup": "markdown", "html": "<p>To show that I put some thought into this and it isn't just the first method that popped into my head, here are some ideas I rejected.</p>\n<p>For example, I first thought there could be a global registry of what BLACS tab and runviewer parser classes belong to each device, say as a <code>.json</code> file at the top level of <code>labscript_devices</code>. Then I realised a single file for this would make it tricky to use something like subrepositories. It is nice having the information local to each subfolder of <code>labscript_devices</code>, since we might imagine swapping out whole folders, or groups adding their own devices as a subrepository. Merging of branches containing different folders will also have no merge conflicts compared to having to always merge this one file. So I figured the data describing what classes belong to each other should be in however many files you want: <code>labscript_devices</code> can just look through the whole folder hierarchy for them.</p>\n<p>I also decided against the mapping of device to tab/parser classes being just a data format like a <code>.json</code> file. For example, I'm working on a generic NI_DAQmx device class, which may have many subclasses for different models. All the subclasses will have the same BLACS tab, so using a <code>.py</code> file to register the classes is better since it can just have a for loop, instead of having a lot of repetition in a <code>.json</code> file. The NI_DAQmx subclasses might even be generated completely programmatically (even if they are not in this case, it would be good to not rule this out for other code).</p>\n<p>Finally, I thought that perhaps the information should be so local that it is defined in the labscript device class itself, as an instance attribute or an argument to a class decorator or whatnot. That way every labscript device class would know what its runviewer parser and BLACS tab are, and can save them to the HDF5 file. However, this makes it difficult to refactor labscript_devices in the future, if the HDF5 files contain a fully qualified name of a BLACS tab class such as 'labscript_devices.PulseBlaster.tab.PulseBlasterTab'. It would be better if the HDF5 file just had the name of the device 'PulseBlaster', and if BLACS could look up the classes at run time. That way if the classes move due to refactoring, so long as the corresponding <code>register_classes.py</code> file is updated at the same time, BLACS will always be able to find the tab, whether the shot file was compiled before the refactoring, or if the computer doing the compilation has a previous version of <code>labscript_devices</code>. Basically, we want to leave the door open to refactoring without breaking backward compatibility, and looking up where the classes are last-minute is conducive to this.</p>\n<p>So the mechanism I've made here is compatible with arbitrary deletion and addition of subfolders/subrepositories as a way of adding/removing device support, is compatible with programatically generating device classes and using for loops instead of repeating oneself a whole lot to declare what the tab and parser classes are for a bunch of devices if they have a lot in common, and is compatible with being able to move the classes around without breaking backward compatibility with running old shots or ones compiled on a computer with an older version of <code>labscript_devices</code>. It is also compatible with storing BLACS tabs and runviewer parsers in separate files, such that BLACS machinery doesn't need to be imported to import labscript classes.</p>\n<p>Also, moving existing classes to subfolders can be done in a way fully backward compatible with existing labscript code, since a subfolder called <code>PulseBlaster</code> with code in an <code>__init__.py</code> will be imported the same as if the code were in a file called <code>PulseBlaster.py</code> at the top level. So we can move existing files to subfolders without breaking import lines in existing experiments.</p>", "type": "rendered"}, "created_on": "2018-09-27T18:22:32.943111+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-09-27T18:27:31.701548+00:00", "type": "pullrequest_comment", "id": 77385571}