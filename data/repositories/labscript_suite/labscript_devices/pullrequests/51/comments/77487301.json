{"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/comments/77487301.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51/_/diff#comment-77487301"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 51, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51"}}, "title": "Arbitrary subfolders for device code within labscript_devices"}, "content": {"raw": "Thanks for your thoughts!\n\n* That's right, there's no enforcement of filenames or folder names having to match the device name. `object.__class__.__name__` will be some string, and yes, it has to match a call to `register_classes()` in `register_classes.py`. If BLACS or runviewer can't find the classes since one wasn't registered, I should modify the error message to say that it couldn't find the classes via either the old or new mechanisms, as it stands you only get an error about the old mechanism since it falls back to that if the classes were not found via the new mechanism.  So if you've named the class differently from the name passed to `regsiter_classes()`, this is where you would find out about it - I could have the error message mention that (\"No classes registered for the name blah, make sure the class name matches what's passed to register_classes!\"). I don't want any enforcement of file or folder names though, as it prevents you from choosing whether to put multiple devices in one file/folder or not. For example, if there are many stub-like subclasses of a device, like with the NI_DAQmx class I'm working on (actually these are so stub-like that I might generate them programatically rather than actually writing the classes), they can all go in one file, and certainly they can go in one folder. We may wish to group PulseBlasters in one folder as well (I'd like to have a PulseBlaster class unification effort after the current NI_DAQmx one is done). So then there'd be a folder called \"pulseblasters\" or something, and the folder name would not correspond to any one device. You might even imaging grouping devices by manufacturer if labscript_devices grows in the future, and then you'd have folders called things like \"spincore\". So enforcing that the file must match or the folder must match doesn't make much sense if we want to be that flexible (which I think is desirable), though it does have to match the line in `register_classes.py`.\n* Sounds good, I'll add a check to error if there are conflicting names.\n* `__init__.py` from the subfolder is imported, yes. But, if you don't want that, you don't need to put the labscript class in (or import it from) `__init__.py`. However, putting the labscript class in `__init__.py` preserves backward compatibility with current experiment scripts. Also, importing labscript classes is less side-effecty than importing BLACS ones, so I'm not too concerned. But if it is side-effecty or otherwise undesirable, the solution is to not put things in `__init__.py`. I would be hesitant to modify how the import works since it would be deviating from what a standard import in python is like - people who understand how imports work will be surprised if `__init__.py` does not run, and any code that does a relative import like `from .something import something` will break saying \"not in a package\" or whatever. You're right that `__init__.py` is being skipped for importing `register_classes.py`, but I think this is a more special case. I was going to just `exec()` that file, and it was cleaner to do it as an import. Relative imports are not possible from within `register_classes.py`, but I think it's ok - maybe I should adjust the documentation-comment to say it's imported as a top-level module, not as a submodule (for the sake of those who know the difference).\n* I wouldn't want to run every `__init__.py` within labscript_devices anyway. Even if we by convention used them only for registering classes, opening up `labscript_devices` to arbitrary code organisation allows one to bundle other libraries in sub-sub-subfolders, which will have their own `__init__.py`s that we wouldn't want to run. Also, moving device code into subfolders allows you to actually write them like packages and use `__init__.py` for common functionality used by labscript classes, BLACS tabs and runviewer parsers (which you wouldn't want to import all the time since it might be slow have unmet dependencies). So I'd rather be able to use `__init__.py` for what it's usually used for  in Python.\n* I agree, despite the push for flexibility, maintaining naming conventions for subfolders that really are a single device make sense. Perhaps `device_name.py`, `blacs_tab.py`,  `runviewer_parser.py` and `blacs_worker.py`, with `__init__.py` containing `from .device_name import DeviceName`. But devices that don't fit the mould, or the case of multiple devices in the same subfolder should not hesitate to break from convention, though how much they deviate from it is a matter of style we can argue about when merging pull requests etc, and I'm sure we'll develop conventions for the different cases that crop up.\n\nFair enough to go slow porting things. We need to anyway to not break unmerged pull requests.", "markup": "markdown", "html": "<p>Thanks for your thoughts!</p>\n<ul>\n<li>That's right, there's no enforcement of filenames or folder names having to match the device name. <code>object.__class__.__name__</code> will be some string, and yes, it has to match a call to <code>register_classes()</code> in <code>register_classes.py</code>. If BLACS or runviewer can't find the classes since one wasn't registered, I should modify the error message to say that it couldn't find the classes via either the old or new mechanisms, as it stands you only get an error about the old mechanism since it falls back to that if the classes were not found via the new mechanism.  So if you've named the class differently from the name passed to <code>regsiter_classes()</code>, this is where you would find out about it - I could have the error message mention that (\"No classes registered for the name blah, make sure the class name matches what's passed to register_classes!\"). I don't want any enforcement of file or folder names though, as it prevents you from choosing whether to put multiple devices in one file/folder or not. For example, if there are many stub-like subclasses of a device, like with the NI_DAQmx class I'm working on (actually these are so stub-like that I might generate them programatically rather than actually writing the classes), they can all go in one file, and certainly they can go in one folder. We may wish to group PulseBlasters in one folder as well (I'd like to have a PulseBlaster class unification effort after the current NI_DAQmx one is done). So then there'd be a folder called \"pulseblasters\" or something, and the folder name would not correspond to any one device. You might even imaging grouping devices by manufacturer if labscript_devices grows in the future, and then you'd have folders called things like \"spincore\". So enforcing that the file must match or the folder must match doesn't make much sense if we want to be that flexible (which I think is desirable), though it does have to match the line in <code>register_classes.py</code>.</li>\n<li>Sounds good, I'll add a check to error if there are conflicting names.</li>\n<li><code>__init__.py</code> from the subfolder is imported, yes. But, if you don't want that, you don't need to put the labscript class in (or import it from) <code>__init__.py</code>. However, putting the labscript class in <code>__init__.py</code> preserves backward compatibility with current experiment scripts. Also, importing labscript classes is less side-effecty than importing BLACS ones, so I'm not too concerned. But if it is side-effecty or otherwise undesirable, the solution is to not put things in <code>__init__.py</code>. I would be hesitant to modify how the import works since it would be deviating from what a standard import in python is like - people who understand how imports work will be surprised if <code>__init__.py</code> does not run, and any code that does a relative import like <code>from .something import something</code> will break saying \"not in a package\" or whatever. You're right that <code>__init__.py</code> is being skipped for importing <code>register_classes.py</code>, but I think this is a more special case. I was going to just <code>exec()</code> that file, and it was cleaner to do it as an import. Relative imports are not possible from within <code>register_classes.py</code>, but I think it's ok - maybe I should adjust the documentation-comment to say it's imported as a top-level module, not as a submodule (for the sake of those who know the difference).</li>\n<li>I wouldn't want to run every <code>__init__.py</code> within labscript_devices anyway. Even if we by convention used them only for registering classes, opening up <code>labscript_devices</code> to arbitrary code organisation allows one to bundle other libraries in sub-sub-subfolders, which will have their own <code>__init__.py</code>s that we wouldn't want to run. Also, moving device code into subfolders allows you to actually write them like packages and use <code>__init__.py</code> for common functionality used by labscript classes, BLACS tabs and runviewer parsers (which you wouldn't want to import all the time since it might be slow have unmet dependencies). So I'd rather be able to use <code>__init__.py</code> for what it's usually used for  in Python.</li>\n<li>I agree, despite the push for flexibility, maintaining naming conventions for subfolders that really are a single device make sense. Perhaps <code>device_name.py</code>, <code>blacs_tab.py</code>,  <code>runviewer_parser.py</code> and <code>blacs_worker.py</code>, with <code>__init__.py</code> containing <code>from .device_name import DeviceName</code>. But devices that don't fit the mould, or the case of multiple devices in the same subfolder should not hesitate to break from convention, though how much they deviate from it is a matter of style we can argue about when merging pull requests etc, and I'm sure we'll develop conventions for the different cases that crop up.</li>\n</ul>\n<p>Fair enough to go slow porting things. We need to anyway to not break unmerged pull requests.</p>", "type": "rendered"}, "created_on": "2018-09-28T14:39:58.433129+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-09-28T14:48:06.132798+00:00", "type": "pullrequest_comment", "id": 77487301}