{"pagelen": 100, "values": [{"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/comments/77377500.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51/_/diff#comment-77377500"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 51, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51"}}, "title": "Arbitrary subfolders for device code within labscript_devices"}, "content": {"raw": "Note to self, add version tag in mainline after merging.", "markup": "markdown", "html": "<p>Note to self, add version tag in mainline after merging.</p>", "type": "rendered"}, "created_on": "2018-09-27T16:55:26.478296+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-09-27T16:55:26.487754+00:00", "type": "pullrequest_comment", "id": 77377500}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/comments/77385571.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51/_/diff#comment-77385571"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 51, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51"}}, "title": "Arbitrary subfolders for device code within labscript_devices"}, "content": {"raw": "To show that I put some thought into this and it isn't just the first method that popped into my head, here are some ideas I rejected.\n\nFor example, I first thought there could be a global registry of what BLACS tab and runviewer parser classes belong to each device, say as a `.json` file at the top level of `labscript_devices`. Then I realised a single file for this would make it tricky to use something like subrepositories. It is nice having the information local to each subfolder of `labscript_devices`, since we might imagine swapping out whole folders, or groups adding their own devices as a subrepository. Merging of branches containing different folders will also have no merge conflicts compared to having to always merge this one file. So I figured the data describing what classes belong to each other should be in however many files you want: `labscript_devices` can just look through the whole folder hierarchy for them.\n\nI also decided against the mapping of device to tab/parser classes being just a data format like a `.json` file. For example, I'm working on a generic NI_DAQmx device class, which may have many subclasses for different models. All the subclasses will have the same BLACS tab, so using a `.py` file to register the classes is better since it can just have a for loop, instead of having a lot of repetition in a `.json` file. The NI_DAQmx subclasses might even be generated completely programmatically (even if they are not in this case, it would be good to not rule this out for other code).\n\nFinally, I thought that perhaps the information should be so local that it is defined in the labscript device class itself, as an instance attribute or an argument to a class decorator or whatnot. That way every labscript device class would know what its runviewer parser and BLACS tab are, and can save them to the HDF5 file. However, this makes it difficult to refactor labscript_devices in the future, if the HDF5 files contain a fully qualified name of a BLACS tab class such as 'labscript_devices.PulseBlaster.tab.PulseBlasterTab'. It would be better if the HDF5 file just had the name of the device 'PulseBlaster', and if BLACS could look up the classes at run time. That way if the classes move due to refactoring, so long as the corresponding `register_classes.py` file is updated at the same time, BLACS will always be able to find the tab, whether the shot file was compiled before the refactoring, or if the computer doing the compilation has a previous version of `labscript_devices`. Basically, we want to leave the door open to refactoring without breaking backward compatibility, and looking up where the classes are last-minute is conducive to this.\n\nSo the mechanism I've made here is compatible with arbitrary deletion and addition of subfolders/subrepositories as a way of adding/removing device support, is compatible with programatically generating device classes and using for loops instead of repeating oneself a whole lot to declare what the tab and parser classes are for a bunch of devices if they have a lot in common, and is compatible with being able to move the classes around without breaking backward compatibility with running old shots or ones compiled on a computer with an older version of `labscript_devices`. It is also compatible with storing BLACS tabs and runviewer parsers in separate files, such that BLACS machinery doesn't need to be imported to import labscript classes.\n\nAlso, moving existing classes to subfolders can be done in a way fully backward compatible with existing labscript code, since a subfolder called `PulseBlaster` with code in an `__init__.py` will be imported the same as if the code were in a file called `PulseBlaster.py` at the top level. So we can move existing files to subfolders without breaking import lines in existing experiments.", "markup": "markdown", "html": "<p>To show that I put some thought into this and it isn't just the first method that popped into my head, here are some ideas I rejected.</p>\n<p>For example, I first thought there could be a global registry of what BLACS tab and runviewer parser classes belong to each device, say as a <code>.json</code> file at the top level of <code>labscript_devices</code>. Then I realised a single file for this would make it tricky to use something like subrepositories. It is nice having the information local to each subfolder of <code>labscript_devices</code>, since we might imagine swapping out whole folders, or groups adding their own devices as a subrepository. Merging of branches containing different folders will also have no merge conflicts compared to having to always merge this one file. So I figured the data describing what classes belong to each other should be in however many files you want: <code>labscript_devices</code> can just look through the whole folder hierarchy for them.</p>\n<p>I also decided against the mapping of device to tab/parser classes being just a data format like a <code>.json</code> file. For example, I'm working on a generic NI_DAQmx device class, which may have many subclasses for different models. All the subclasses will have the same BLACS tab, so using a <code>.py</code> file to register the classes is better since it can just have a for loop, instead of having a lot of repetition in a <code>.json</code> file. The NI_DAQmx subclasses might even be generated completely programmatically (even if they are not in this case, it would be good to not rule this out for other code).</p>\n<p>Finally, I thought that perhaps the information should be so local that it is defined in the labscript device class itself, as an instance attribute or an argument to a class decorator or whatnot. That way every labscript device class would know what its runviewer parser and BLACS tab are, and can save them to the HDF5 file. However, this makes it difficult to refactor labscript_devices in the future, if the HDF5 files contain a fully qualified name of a BLACS tab class such as 'labscript_devices.PulseBlaster.tab.PulseBlasterTab'. It would be better if the HDF5 file just had the name of the device 'PulseBlaster', and if BLACS could look up the classes at run time. That way if the classes move due to refactoring, so long as the corresponding <code>register_classes.py</code> file is updated at the same time, BLACS will always be able to find the tab, whether the shot file was compiled before the refactoring, or if the computer doing the compilation has a previous version of <code>labscript_devices</code>. Basically, we want to leave the door open to refactoring without breaking backward compatibility, and looking up where the classes are last-minute is conducive to this.</p>\n<p>So the mechanism I've made here is compatible with arbitrary deletion and addition of subfolders/subrepositories as a way of adding/removing device support, is compatible with programatically generating device classes and using for loops instead of repeating oneself a whole lot to declare what the tab and parser classes are for a bunch of devices if they have a lot in common, and is compatible with being able to move the classes around without breaking backward compatibility with running old shots or ones compiled on a computer with an older version of <code>labscript_devices</code>. It is also compatible with storing BLACS tabs and runviewer parsers in separate files, such that BLACS machinery doesn't need to be imported to import labscript classes.</p>\n<p>Also, moving existing classes to subfolders can be done in a way fully backward compatible with existing labscript code, since a subfolder called <code>PulseBlaster</code> with code in an <code>__init__.py</code> will be imported the same as if the code were in a file called <code>PulseBlaster.py</code> at the top level. So we can move existing files to subfolders without breaking import lines in existing experiments.</p>", "type": "rendered"}, "created_on": "2018-09-27T18:22:32.943111+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-09-27T18:27:31.701548+00:00", "type": "pullrequest_comment", "id": 77385571}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/comments/77421467.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51/_/diff#comment-77421467"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 51, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51"}}, "title": "Arbitrary subfolders for device code within labscript_devices"}, "content": {"raw": "Thoughts:  \n\n* The removal of the `@labscript_device` decorator means that you are no longer checking that the labscript class name matches the file \\(or in this case folder\\) name. Doesn't this have implications for what gets saved in the connection table since we currently save `object.__class__.__name__` and this needs to match the name specified as the first argument to `register_classes()` in order to look up the BLACS/runviewer classes?   \n* If we aren't enforcing folder name = labscript device name anymore \\(so that each folder can hold multiple devices\\) then `register_classes` needs a check to ensure that we don\u2019t have conflicting device names across multiple folders \\(aka, don\u2019t overwrite existing dictionary entries if something with that device name has already been registered!\\)  \n* The current way you import the BLACS and runviewer classes I think results in the labscript class also being imported \\(thus making BLACS, remote worker processes, and runviewer depend on labscript\\), which we probably don\u2019t want. Possibly `_import_class_by_fullname` should be updated to import in the same way as `register_classes` so that it doesn't run `__init__.py`?  \n* It's a shame that the call to `register_classes` can't be in `__init__.py` but I guess that is the price we pay for keeping backwards compatibility with the historical device imports in experiment logic files.  \n* I think it would be good to come up with some conventions regarding filenames. For instance, filenames that indicate which program the contents are for would be helpful \\(so that you don't have to look it up in `register_classes`\\). So say, \u201cBLACSTab.py\u201d or \u201clabscript\\_class.py\u201d or something like that. Will just make it faster to figure out where relevant code is stored, and will help new people understand the code structure a bit better \\(because this proposal technically means you can do whatever you like, for example have 7 unrelated devices contained within a single folder with filenames that come from a random password generator! So conventions will help ensure we don\u2019t get a giant mess of contributed device code in the future\\).\n\n\u200c\n\nI also think it would be prudent to go slow on the porting of other devices to the new structure so that we can tweak the implementation as we go if things crop up for particular device implementations \\(DummyPseudoclock is not exactly the most complex of devices!\\)", "markup": "markdown", "html": "<p>Thoughts:  </p>\n<ul>\n<li>The removal of the <code>@labscript_device</code> decorator means that you are no longer checking that the labscript class name matches the file (or in this case folder) name. Doesn't this have implications for what gets saved in the connection table since we currently save <code>object.__class__.__name__</code> and this needs to match the name specified as the first argument to <code>register_classes()</code> in order to look up the BLACS/runviewer classes?   </li>\n<li>If we aren't enforcing folder name = labscript device name anymore (so that each folder can hold multiple devices) then <code>register_classes</code> needs a check to ensure that we don\u2019t have conflicting device names across multiple folders (aka, don\u2019t overwrite existing dictionary entries if something with that device name has already been registered!)  </li>\n<li>The current way you import the BLACS and runviewer classes I think results in the labscript class also being imported (thus making BLACS, remote worker processes, and runviewer depend on labscript), which we probably don\u2019t want. Possibly <code>_import_class_by_fullname</code> should be updated to import in the same way as <code>register_classes</code> so that it doesn't run <code>__init__.py</code>?  </li>\n<li>It's a shame that the call to <code>register_classes</code> can't be in <code>__init__.py</code> but I guess that is the price we pay for keeping backwards compatibility with the historical device imports in experiment logic files.  </li>\n<li>I think it would be good to come up with some conventions regarding filenames. For instance, filenames that indicate which program the contents are for would be helpful (so that you don't have to look it up in <code>register_classes</code>). So say, \u201cBLACSTab.py\u201d or \u201clabscript_class.py\u201d or something like that. Will just make it faster to figure out where relevant code is stored, and will help new people understand the code structure a bit better (because this proposal technically means you can do whatever you like, for example have 7 unrelated devices contained within a single folder with filenames that come from a random password generator! So conventions will help ensure we don\u2019t get a giant mess of contributed device code in the future).</li>\n</ul>\n<p>\u200c</p>\n<p>I also think it would be prudent to go slow on the porting of other devices to the new structure so that we can tweak the implementation as we go if things crop up for particular device implementations (DummyPseudoclock is not exactly the most complex of devices!)</p>", "type": "rendered"}, "created_on": "2018-09-28T05:30:02.291614+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}, "updated_on": "2018-09-28T05:30:02.306116+00:00", "type": "pullrequest_comment", "id": 77421467}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/comments/77487301.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51/_/diff#comment-77487301"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 51, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51"}}, "title": "Arbitrary subfolders for device code within labscript_devices"}, "content": {"raw": "Thanks for your thoughts!\n\n* That's right, there's no enforcement of filenames or folder names having to match the device name. `object.__class__.__name__` will be some string, and yes, it has to match a call to `register_classes()` in `register_classes.py`. If BLACS or runviewer can't find the classes since one wasn't registered, I should modify the error message to say that it couldn't find the classes via either the old or new mechanisms, as it stands you only get an error about the old mechanism since it falls back to that if the classes were not found via the new mechanism.  So if you've named the class differently from the name passed to `regsiter_classes()`, this is where you would find out about it - I could have the error message mention that (\"No classes registered for the name blah, make sure the class name matches what's passed to register_classes!\"). I don't want any enforcement of file or folder names though, as it prevents you from choosing whether to put multiple devices in one file/folder or not. For example, if there are many stub-like subclasses of a device, like with the NI_DAQmx class I'm working on (actually these are so stub-like that I might generate them programatically rather than actually writing the classes), they can all go in one file, and certainly they can go in one folder. We may wish to group PulseBlasters in one folder as well (I'd like to have a PulseBlaster class unification effort after the current NI_DAQmx one is done). So then there'd be a folder called \"pulseblasters\" or something, and the folder name would not correspond to any one device. You might even imaging grouping devices by manufacturer if labscript_devices grows in the future, and then you'd have folders called things like \"spincore\". So enforcing that the file must match or the folder must match doesn't make much sense if we want to be that flexible (which I think is desirable), though it does have to match the line in `register_classes.py`.\n* Sounds good, I'll add a check to error if there are conflicting names.\n* `__init__.py` from the subfolder is imported, yes. But, if you don't want that, you don't need to put the labscript class in (or import it from) `__init__.py`. However, putting the labscript class in `__init__.py` preserves backward compatibility with current experiment scripts. Also, importing labscript classes is less side-effecty than importing BLACS ones, so I'm not too concerned. But if it is side-effecty or otherwise undesirable, the solution is to not put things in `__init__.py`. I would be hesitant to modify how the import works since it would be deviating from what a standard import in python is like - people who understand how imports work will be surprised if `__init__.py` does not run, and any code that does a relative import like `from .something import something` will break saying \"not in a package\" or whatever. You're right that `__init__.py` is being skipped for importing `register_classes.py`, but I think this is a more special case. I was going to just `exec()` that file, and it was cleaner to do it as an import. Relative imports are not possible from within `register_classes.py`, but I think it's ok - maybe I should adjust the documentation-comment to say it's imported as a top-level module, not as a submodule (for the sake of those who know the difference).\n* I wouldn't want to run every `__init__.py` within labscript_devices anyway. Even if we by convention used them only for registering classes, opening up `labscript_devices` to arbitrary code organisation allows one to bundle other libraries in sub-sub-subfolders, which will have their own `__init__.py`s that we wouldn't want to run. Also, moving device code into subfolders allows you to actually write them like packages and use `__init__.py` for common functionality used by labscript classes, BLACS tabs and runviewer parsers (which you wouldn't want to import all the time since it might be slow have unmet dependencies). So I'd rather be able to use `__init__.py` for what it's usually used for  in Python.\n* I agree, despite the push for flexibility, maintaining naming conventions for subfolders that really are a single device make sense. Perhaps `device_name.py`, `blacs_tab.py`,  `runviewer_parser.py` and `blacs_worker.py`, with `__init__.py` containing `from .device_name import DeviceName`. But devices that don't fit the mould, or the case of multiple devices in the same subfolder should not hesitate to break from convention, though how much they deviate from it is a matter of style we can argue about when merging pull requests etc, and I'm sure we'll develop conventions for the different cases that crop up.\n\nFair enough to go slow porting things. We need to anyway to not break unmerged pull requests.", "markup": "markdown", "html": "<p>Thanks for your thoughts!</p>\n<ul>\n<li>That's right, there's no enforcement of filenames or folder names having to match the device name. <code>object.__class__.__name__</code> will be some string, and yes, it has to match a call to <code>register_classes()</code> in <code>register_classes.py</code>. If BLACS or runviewer can't find the classes since one wasn't registered, I should modify the error message to say that it couldn't find the classes via either the old or new mechanisms, as it stands you only get an error about the old mechanism since it falls back to that if the classes were not found via the new mechanism.  So if you've named the class differently from the name passed to <code>regsiter_classes()</code>, this is where you would find out about it - I could have the error message mention that (\"No classes registered for the name blah, make sure the class name matches what's passed to register_classes!\"). I don't want any enforcement of file or folder names though, as it prevents you from choosing whether to put multiple devices in one file/folder or not. For example, if there are many stub-like subclasses of a device, like with the NI_DAQmx class I'm working on (actually these are so stub-like that I might generate them programatically rather than actually writing the classes), they can all go in one file, and certainly they can go in one folder. We may wish to group PulseBlasters in one folder as well (I'd like to have a PulseBlaster class unification effort after the current NI_DAQmx one is done). So then there'd be a folder called \"pulseblasters\" or something, and the folder name would not correspond to any one device. You might even imaging grouping devices by manufacturer if labscript_devices grows in the future, and then you'd have folders called things like \"spincore\". So enforcing that the file must match or the folder must match doesn't make much sense if we want to be that flexible (which I think is desirable), though it does have to match the line in <code>register_classes.py</code>.</li>\n<li>Sounds good, I'll add a check to error if there are conflicting names.</li>\n<li><code>__init__.py</code> from the subfolder is imported, yes. But, if you don't want that, you don't need to put the labscript class in (or import it from) <code>__init__.py</code>. However, putting the labscript class in <code>__init__.py</code> preserves backward compatibility with current experiment scripts. Also, importing labscript classes is less side-effecty than importing BLACS ones, so I'm not too concerned. But if it is side-effecty or otherwise undesirable, the solution is to not put things in <code>__init__.py</code>. I would be hesitant to modify how the import works since it would be deviating from what a standard import in python is like - people who understand how imports work will be surprised if <code>__init__.py</code> does not run, and any code that does a relative import like <code>from .something import something</code> will break saying \"not in a package\" or whatever. You're right that <code>__init__.py</code> is being skipped for importing <code>register_classes.py</code>, but I think this is a more special case. I was going to just <code>exec()</code> that file, and it was cleaner to do it as an import. Relative imports are not possible from within <code>register_classes.py</code>, but I think it's ok - maybe I should adjust the documentation-comment to say it's imported as a top-level module, not as a submodule (for the sake of those who know the difference).</li>\n<li>I wouldn't want to run every <code>__init__.py</code> within labscript_devices anyway. Even if we by convention used them only for registering classes, opening up <code>labscript_devices</code> to arbitrary code organisation allows one to bundle other libraries in sub-sub-subfolders, which will have their own <code>__init__.py</code>s that we wouldn't want to run. Also, moving device code into subfolders allows you to actually write them like packages and use <code>__init__.py</code> for common functionality used by labscript classes, BLACS tabs and runviewer parsers (which you wouldn't want to import all the time since it might be slow have unmet dependencies). So I'd rather be able to use <code>__init__.py</code> for what it's usually used for  in Python.</li>\n<li>I agree, despite the push for flexibility, maintaining naming conventions for subfolders that really are a single device make sense. Perhaps <code>device_name.py</code>, <code>blacs_tab.py</code>,  <code>runviewer_parser.py</code> and <code>blacs_worker.py</code>, with <code>__init__.py</code> containing <code>from .device_name import DeviceName</code>. But devices that don't fit the mould, or the case of multiple devices in the same subfolder should not hesitate to break from convention, though how much they deviate from it is a matter of style we can argue about when merging pull requests etc, and I'm sure we'll develop conventions for the different cases that crop up.</li>\n</ul>\n<p>Fair enough to go slow porting things. We need to anyway to not break unmerged pull requests.</p>", "type": "rendered"}, "created_on": "2018-09-28T14:39:58.433129+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-09-28T14:48:06.132798+00:00", "type": "pullrequest_comment", "id": 77487301}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/comments/77492805.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51/_/diff#comment-77492805"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 51, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51"}}, "title": "Arbitrary subfolders for device code within labscript_devices"}, "content": {"raw": "Which single-device convention do you prefer?\n\n```\nDummyPseudoclock/\n    __init__.py\n        from .labscript_device import DummyPseudoclock\n    labscript_device.py\n    blacs_tab.py\n    blacs_worker.py\n    runviewer_parser.py\n    register_classes.py\n```\n\nor\n```\nDummyPseudoclock/\n    __init__.py\n        from .dummy_pseudoclock import DummyPseudoclock\n    dummy_pseudoclock.py\n    blacs_tab.py\n    blacs_worker.py\n    runviewer_parser.py\n    register_classes.py\n```\n    \n(or something else)\n\nI'm leaning toward the former.", "markup": "markdown", "html": "<p>Which single-device convention do you prefer?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">DummyPseudoclock</span><span class=\"o\">/</span>\n    <span class=\"fm\">__init__</span><span class=\"o\">.</span><span class=\"n\">py</span>\n        <span class=\"kn\">from</span> <span class=\"nn\">.labscript_device</span> <span class=\"kn\">import</span> <span class=\"n\">DummyPseudoclock</span>\n    <span class=\"n\">labscript_device</span><span class=\"o\">.</span><span class=\"n\">py</span>\n    <span class=\"n\">blacs_tab</span><span class=\"o\">.</span><span class=\"n\">py</span>\n    <span class=\"n\">blacs_worker</span><span class=\"o\">.</span><span class=\"n\">py</span>\n    <span class=\"n\">runviewer_parser</span><span class=\"o\">.</span><span class=\"n\">py</span>\n    <span class=\"n\">register_classes</span><span class=\"o\">.</span><span class=\"n\">py</span>\n</pre></div>\n\n\n<p>or</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">DummyPseudoclock</span><span class=\"o\">/</span>\n    <span class=\"fm\">__init__</span><span class=\"o\">.</span><span class=\"n\">py</span>\n        <span class=\"kn\">from</span> <span class=\"nn\">.dummy_pseudoclock</span> <span class=\"kn\">import</span> <span class=\"n\">DummyPseudoclock</span>\n    <span class=\"n\">dummy_pseudoclock</span><span class=\"o\">.</span><span class=\"n\">py</span>\n    <span class=\"n\">blacs_tab</span><span class=\"o\">.</span><span class=\"n\">py</span>\n    <span class=\"n\">blacs_worker</span><span class=\"o\">.</span><span class=\"n\">py</span>\n    <span class=\"n\">runviewer_parser</span><span class=\"o\">.</span><span class=\"n\">py</span>\n    <span class=\"n\">register_classes</span><span class=\"o\">.</span><span class=\"n\">py</span>\n</pre></div>\n\n\n<p>(or something else)</p>\n<p>I'm leaning toward the former.</p>", "type": "rendered"}, "created_on": "2018-09-28T15:19:09.179852+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-09-28T15:19:09.200773+00:00", "type": "pullrequest_comment", "id": 77492805}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/comments/77496207.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51/_/diff#comment-77496207"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 51, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51"}}, "title": "Arbitrary subfolders for device code within labscript_devices"}, "content": {"raw": "One can think of examples where you don't want to import the labscript device just because you are importing a BLACS tab. For example, the RFBlaster has compile-time dependencies, one of them even needs a Cython extension compiled, this is a pain in the neck to have on computers when you don't actually need to use it.\n\nThe following three options that have different downsides:\n\n1. Don't import labscript classes into `__init__.py`. Downside: breaks backward compatibility with existing scripts. Also, import lines are getting pretty long in experiment scripts: `from labscript_devices.DummyPseudoclock.labscript_device import Dummy_pseudoclock`.\n2. Do import labscript classes into `__init__.py`. Downside: import-time dependencies must be met on BLACS computer even if they are not needed by BLACS. Imports may need to be hidden in functions instead of at the global scope, which is ugly.\n3. Use some kind of lazy importer that doesn't actually do the import until one of the imported things is accessed. Downside: magic and unexpected.  Surprises experienced Python users and misleads less experienced ones.\n\nActually i suppose there's another option, to do 1, but with some magic that lets you import anything from the `labscript_device` submodule  anyway if you import it as if it was in `__init__.py`, but coughs a deprecation warning telling you the new import line you should use. Downside: this sort of magic can be bug-prone.", "markup": "markdown", "html": "<p>One can think of examples where you don't want to import the labscript device just because you are importing a BLACS tab. For example, the RFBlaster has compile-time dependencies, one of them even needs a Cython extension compiled, this is a pain in the neck to have on computers when you don't actually need to use it.</p>\n<p>The following three options that have different downsides:</p>\n<ol>\n<li>Don't import labscript classes into <code>__init__.py</code>. Downside: breaks backward compatibility with existing scripts. Also, import lines are getting pretty long in experiment scripts: <code>from labscript_devices.DummyPseudoclock.labscript_device import Dummy_pseudoclock</code>.</li>\n<li>Do import labscript classes into <code>__init__.py</code>. Downside: import-time dependencies must be met on BLACS computer even if they are not needed by BLACS. Imports may need to be hidden in functions instead of at the global scope, which is ugly.</li>\n<li>Use some kind of lazy importer that doesn't actually do the import until one of the imported things is accessed. Downside: magic and unexpected.  Surprises experienced Python users and misleads less experienced ones.</li>\n</ol>\n<p>Actually i suppose there's another option, to do 1, but with some magic that lets you import anything from the <code>labscript_device</code> submodule  anyway if you import it as if it was in <code>__init__.py</code>, but coughs a deprecation warning telling you the new import line you should use. Downside: this sort of magic can be bug-prone.</p>", "type": "rendered"}, "created_on": "2018-09-28T15:47:06.884174+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-09-28T15:50:23.832421+00:00", "type": "pullrequest_comment", "id": 77496207}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/comments/77665502.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51/_/diff#comment-77665502"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 51, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51"}}, "title": "Arbitrary subfolders for device code within labscript_devices"}, "content": {"raw": "OK, I've updated this to have a better error in the case that a module can't be found, and to make the dummy pseudoclock laid out like:\n```\nDummyPseudoclock/\n    __init__.py\n        from .labscript_device import DummyPseudoclock\n    labscript_device.py\n    blacs_tab.py\n    blacs_worker.py\n    runviewer_parser.py\n    register_classes.py\n```\n\nMaybe we can think about breaking backward compatibility or how to avoid import-time dependencies for labscript devices later. It's not relevant for a whole lot of them.", "markup": "markdown", "html": "<p>OK, I've updated this to have a better error in the case that a module can't be found, and to make the dummy pseudoclock laid out like:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">DummyPseudoclock</span><span class=\"o\">/</span>\n    <span class=\"fm\">__init__</span><span class=\"o\">.</span><span class=\"n\">py</span>\n        <span class=\"kn\">from</span> <span class=\"nn\">.labscript_device</span> <span class=\"kn\">import</span> <span class=\"n\">DummyPseudoclock</span>\n    <span class=\"n\">labscript_device</span><span class=\"o\">.</span><span class=\"n\">py</span>\n    <span class=\"n\">blacs_tab</span><span class=\"o\">.</span><span class=\"n\">py</span>\n    <span class=\"n\">blacs_worker</span><span class=\"o\">.</span><span class=\"n\">py</span>\n    <span class=\"n\">runviewer_parser</span><span class=\"o\">.</span><span class=\"n\">py</span>\n    <span class=\"n\">register_classes</span><span class=\"o\">.</span><span class=\"n\">py</span>\n</pre></div>\n\n\n<p>Maybe we can think about breaking backward compatibility or how to avoid import-time dependencies for labscript devices later. It's not relevant for a whole lot of them.</p>", "type": "rendered"}, "created_on": "2018-10-01T20:01:00.659598+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-10-01T20:01:00.667368+00:00", "type": "pullrequest_comment", "id": 77665502}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/comments/77684121.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51/_/diff#comment-77684121"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 51, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51"}}, "title": "Arbitrary subfolders for device code within labscript_devices"}, "content": {"raw": "Oops, Only saw the first of the 3 messages in my emails \\(did the stupid thing where I don\u2019t scroll down to the bottom to check if there was more than one new email in the thread\u2026anyway\u2026\\)\n\nNew filename guidelines looks good.\n\nDot point answers look good.\n\nRegarding backwards compatibility, how about this. In each `__init__.py` file we add something like this:\n\n    class DummyPseudoclockObject(object):\r\n        def __call__(self, *args, **kwargs):\n            cls = labscript_devices.get_labscript_class('DummyPseudoclock')\r\n            return cls(*args, **kwargs)\r\n    \r\n    \r\n    DummyPseudoclock = DummyPseudoclockObject()\n\nWe then add a `get_labscript_class()` method to `labscript_devices.__init__` that is similar to the others for runviewer/BLACS.\n\nThis does delay the import of the labscript class until it is first used, which is a little bit magical, but maybe not the end of the world? It at least maintains backwards compatibility with current import statements. \n\nWe could also use this to deprecate the current import style \\(by printing a warning\\), however I'm not certain whether it's not best to stick to the standard way of importing rather than making people use the `get_labscript_class()` function directly or a much longer import statement.\n\nNot sure\u2026maybe it\u2019s not the best approach.", "markup": "markdown", "html": "<p>Oops, Only saw the first of the 3 messages in my emails (did the stupid thing where I don\u2019t scroll down to the bottom to check if there was more than one new email in the thread\u2026anyway\u2026)</p>\n<p>New filename guidelines looks good.</p>\n<p>Dot point answers look good.</p>\n<p>Regarding backwards compatibility, how about this. In each <code>__init__.py</code> file we add something like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kr\">class</span> <span class=\"nx\">DummyPseudoclockObject</span><span class=\"p\">(</span><span class=\"nx\">object</span><span class=\"p\">)</span><span class=\"o\">:</span>\n    <span class=\"nx\">def</span> <span class=\"nx\">__call__</span><span class=\"p\">(</span><span class=\"nx\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"nx\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"nx\">kwargs</span><span class=\"p\">)</span><span class=\"o\">:</span>\n        <span class=\"nx\">cls</span> <span class=\"o\">=</span> <span class=\"nx\">labscript_devices</span><span class=\"p\">.</span><span class=\"nx\">get_labscript_class</span><span class=\"p\">(</span><span class=\"s1\">&#39;DummyPseudoclock&#39;</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"nx\">cls</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"nx\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"nx\">kwargs</span><span class=\"p\">)</span>\n\n\n<span class=\"nx\">DummyPseudoclock</span> <span class=\"o\">=</span> <span class=\"nx\">DummyPseudoclockObject</span><span class=\"p\">()</span>\n</pre></div>\n\n\n<p>We then add a <code>get_labscript_class()</code> method to <code>labscript_devices.__init__</code> that is similar to the others for runviewer/BLACS.</p>\n<p>This does delay the import of the labscript class until it is first used, which is a little bit magical, but maybe not the end of the world? It at least maintains backwards compatibility with current import statements. </p>\n<p>We could also use this to deprecate the current import style (by printing a warning), however I'm not certain whether it's not best to stick to the standard way of importing rather than making people use the <code>get_labscript_class()</code> function directly or a much longer import statement.</p>\n<p>Not sure\u2026maybe it\u2019s not the best approach.</p>", "type": "rendered"}, "created_on": "2018-10-02T00:57:57.306436+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}, "updated_on": "2018-10-02T00:57:57.314397+00:00", "type": "pullrequest_comment", "id": 77684121}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/comments/77780230.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51/_/diff#comment-77780230"}}, "parent": {"id": 77684121, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/comments/77684121.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51/_/diff#comment-77684121"}}, "depth": 1}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 51, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51"}}, "title": "Arbitrary subfolders for device code within labscript_devices"}, "content": {"raw": "Yeah, the magic is a little incomplete, in that if you import a device this way and then subclass it instead of instantiate it, you'll get nonsense.\n\nIn Python 3.7 you can define `__getattr__` at the module level and dynamically import something when the name is accessed, rather than when it is instantiated. This would be ok, but is unappealing if you have more than one class defined in `labscript_device`, or other functions and things that you might want to import too - you would have to maintain a potentially growing list of which imports to pull into `__init__.py` as deferred imports vs normal ones. So either kind of magic is unappealing.\n\nI'm leaning towards yes, include magic for backward compatibility. But, since the magic is incomplete and not a nice prospect for long-term maintainability, that it be only for backward compatibility and not a long-term endorsed way of importing things.  So it should have a deprecation warning so that it is not used long-term, and so that the reason for breakage if people are subclassing these things (or whatever else) is more apparent since they may have a deprecation warning in addition to whatever breakage they encounter.\n\nWe don't need to register the labscript class names in advance, we can do something like:\n\n```python\nimport warnings\n\ndef DummyPseudoclock(*args, **kwargs):\n    fullname = 'labscript_devices.DummyPseudoclock.labscript_device.DummyPseudoclock'\n    warnings.warn(\"This is deprecation warning, please use blah blah import line instead, things may break unexpectedly if you don't\")\n    return labscript_devices.import_class_by_fullname(fullname)(*args, **kwargs)\n```\n\nI can wrap this into a generic function in `labscript_devices` so that you can just do:\n\n```python\nDummyPseudoclock = labscript_devices.deprecated_import_alias('labscript_devices.DummyPseudoclock.labscript_device.DummyPseudoclock')\n```\n\ninstead in each `__init__.py`\n\nSound ok?", "markup": "markdown", "html": "<p>Yeah, the magic is a little incomplete, in that if you import a device this way and then subclass it instead of instantiate it, you'll get nonsense.</p>\n<p>In Python 3.7 you can define <code>__getattr__</code> at the module level and dynamically import something when the name is accessed, rather than when it is instantiated. This would be ok, but is unappealing if you have more than one class defined in <code>labscript_device</code>, or other functions and things that you might want to import too - you would have to maintain a potentially growing list of which imports to pull into <code>__init__.py</code> as deferred imports vs normal ones. So either kind of magic is unappealing.</p>\n<p>I'm leaning towards yes, include magic for backward compatibility. But, since the magic is incomplete and not a nice prospect for long-term maintainability, that it be only for backward compatibility and not a long-term endorsed way of importing things.  So it should have a deprecation warning so that it is not used long-term, and so that the reason for breakage if people are subclassing these things (or whatever else) is more apparent since they may have a deprecation warning in addition to whatever breakage they encounter.</p>\n<p>We don't need to register the labscript class names in advance, we can do something like:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">warnings</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">DummyPseudoclock</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"n\">fullname</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;labscript_devices.DummyPseudoclock.labscript_device.DummyPseudoclock&#39;</span>\n    <span class=\"n\">warnings</span><span class=\"o\">.</span><span class=\"n\">warn</span><span class=\"p\">(</span><span class=\"s2\">&quot;This is deprecation warning, please use blah blah import line instead, things may break unexpectedly if you don&#39;t&quot;</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">labscript_devices</span><span class=\"o\">.</span><span class=\"n\">import_class_by_fullname</span><span class=\"p\">(</span><span class=\"n\">fullname</span><span class=\"p\">)(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>I can wrap this into a generic function in <code>labscript_devices</code> so that you can just do:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"n\">DummyPseudoclock</span> <span class=\"o\">=</span> <span class=\"n\">labscript_devices</span><span class=\"o\">.</span><span class=\"n\">deprecated_import_alias</span><span class=\"p\">(</span><span class=\"s1\">&#39;labscript_devices.DummyPseudoclock.labscript_device.DummyPseudoclock&#39;</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>instead in each <code>__init__.py</code></p>\n<p>Sound ok?</p>", "type": "rendered"}, "created_on": "2018-10-02T16:11:24.226610+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-10-02T17:55:46.769491+00:00", "type": "pullrequest_comment", "id": 77780230}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/comments/77792305.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51/_/diff#comment-77792305"}}, "parent": {"id": 77780230, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/comments/77780230.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51/_/diff#comment-77780230"}}, "depth": 2}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 51, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51"}}, "title": "Arbitrary subfolders for device code within labscript_devices"}, "content": {"raw": "Ok, I've gone ahead and implemented this. `DummyPseudoclock/__init__.py` now has:\n\n```python\nfrom labscript_devices import deprecated_import_alias\n\n# For backwards compatibility with old experiment scripts:\nDummyPseudoclock = deprecated_import_alias(\n    \"labscript_devices.DummyPseudoclock.labscript_device.DummyPseudoclock\"\n)\n```\n\nwhere `deprecated_import_alias()` is defined in `labscript_devices/__init__.py` as:\n\n```python\ndef deprecated_import_alias(fullname):\n    \"\"\"A way of allowing a class to be imported from an old location whilst a) not\n    actually importing it until it is instantiated and b) emitting a warning pointing to\n    the new import location. fullname must be a fully qualified class name with an\n    absolute import path. Use by calling in the module where the class used to be:\n    ClassName = deprecated_import_alias(\"new.path.to.ClassName\")\"\"\"\n    calling_module_name = inspect.getmodule(inspect.stack()[1][0]).__name__\n    cls = []\n    def wrapper(*args, **kwargs):\n        if not cls:\n            cls.append(_import_class_by_fullname(fullname))\n            shortname = fullname.split('.')[-1]\n            newmodule = '.'.join(fullname.split('.')[:-1])\n            msg = \"\"\"Importing %s from %s is deprecated, please instead import it from\n               %s. Importing anyway for backward compatibility, but this may cause some\n               unexpected behaviour.\"\"\"\n            msg = dedent(msg) % (shortname, calling_module_name, newmodule)\n            warnings.warn(msg, stacklevel=2)\n        return cls[0](*args, **kwargs)\n    return wrapper\n```\n\nWith this, the following code:\n```python\nfrom labscript_devices.DummyPseudoclock import DummyPseudoclock\nDummyPseudoclock()\n```\nresults in:\n```\ntest.py:2: UserWarning: Importing DummyPseudoclock from labscript_devices.DummyPseudoclock is deprecated, please instead import it from labscript_devices.DummyPseudoclock.labscript_device. Importing anyway for backward compatibility, but this may cause some unexpected behaviour.\n  DummyPseudoclock()\n```\n\nThe warning is only printed once if you instantiate the class multiple times.\n\nI've also implemented the error if you call `register_classes` twice with the same labscript device name, so as long as you agree with the aliasing/deprecation stuff, I think that's all on the todo list for this pull request.", "markup": "markdown", "html": "<p>Ok, I've gone ahead and implemented this. <code>DummyPseudoclock/__init__.py</code> now has:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">labscript_devices</span> <span class=\"kn\">import</span> <span class=\"n\">deprecated_import_alias</span>\n\n<span class=\"c1\"># For backwards compatibility with old experiment scripts:</span>\n<span class=\"n\">DummyPseudoclock</span> <span class=\"o\">=</span> <span class=\"n\">deprecated_import_alias</span><span class=\"p\">(</span>\n    <span class=\"s2\">&quot;labscript_devices.DummyPseudoclock.labscript_device.DummyPseudoclock&quot;</span>\n<span class=\"p\">)</span>\n</pre></div>\n\n\n<p>where <code>deprecated_import_alias()</code> is defined in <code>labscript_devices/__init__.py</code> as:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">deprecated_import_alias</span><span class=\"p\">(</span><span class=\"n\">fullname</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;A way of allowing a class to be imported from an old location whilst a) not</span>\n<span class=\"sd\">    actually importing it until it is instantiated and b) emitting a warning pointing to</span>\n<span class=\"sd\">    the new import location. fullname must be a fully qualified class name with an</span>\n<span class=\"sd\">    absolute import path. Use by calling in the module where the class used to be:</span>\n<span class=\"sd\">    ClassName = deprecated_import_alias(&quot;new.path.to.ClassName&quot;)&quot;&quot;&quot;</span>\n    <span class=\"n\">calling_module_name</span> <span class=\"o\">=</span> <span class=\"n\">inspect</span><span class=\"o\">.</span><span class=\"n\">getmodule</span><span class=\"p\">(</span><span class=\"n\">inspect</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"p\">()[</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">])</span><span class=\"o\">.</span><span class=\"vm\">__name__</span>\n    <span class=\"bp\">cls</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">def</span> <span class=\"nf\">wrapper</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"bp\">cls</span><span class=\"p\">:</span>\n            <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">_import_class_by_fullname</span><span class=\"p\">(</span><span class=\"n\">fullname</span><span class=\"p\">))</span>\n            <span class=\"n\">shortname</span> <span class=\"o\">=</span> <span class=\"n\">fullname</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"s1\">&#39;.&#39;</span><span class=\"p\">)[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n            <span class=\"n\">newmodule</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;.&#39;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">fullname</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"s1\">&#39;.&#39;</span><span class=\"p\">)[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n            <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;&quot;&quot;Importing </span><span class=\"si\">%s</span><span class=\"s2\"> from </span><span class=\"si\">%s</span><span class=\"s2\"> is deprecated, please instead import it from</span>\n<span class=\"s2\">               </span><span class=\"si\">%s</span><span class=\"s2\">. Importing anyway for backward compatibility, but this may cause some</span>\n<span class=\"s2\">               unexpected behaviour.&quot;&quot;&quot;</span>\n            <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"n\">dedent</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">shortname</span><span class=\"p\">,</span> <span class=\"n\">calling_module_name</span><span class=\"p\">,</span> <span class=\"n\">newmodule</span><span class=\"p\">)</span>\n            <span class=\"n\">warnings</span><span class=\"o\">.</span><span class=\"n\">warn</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">stacklevel</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"bp\">cls</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">](</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">wrapper</span>\n</pre></div>\n\n\n<p>With this, the following code:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">labscript_devices.DummyPseudoclock</span> <span class=\"kn\">import</span> <span class=\"n\">DummyPseudoclock</span>\n<span class=\"n\">DummyPseudoclock</span><span class=\"p\">()</span>\n</pre></div>\n\n\n<p>results in:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">test</span><span class=\"o\">.</span><span class=\"n\">py</span><span class=\"p\">:</span><span class=\"mi\">2</span><span class=\"p\">:</span> <span class=\"ne\">UserWarning</span><span class=\"p\">:</span> <span class=\"n\">Importing</span> <span class=\"n\">DummyPseudoclock</span> <span class=\"kn\">from</span> <span class=\"nn\">labscript_devices.DummyPseudoclock</span> <span class=\"nn\">is</span> <span class=\"nn\">deprecated</span><span class=\"p\">,</span> <span class=\"n\">please</span> <span class=\"n\">instead</span> <span class=\"kn\">import</span> <span class=\"nn\">it</span> <span class=\"nn\">from</span> <span class=\"nn\">labscript_devices.DummyPseudoclock.labscript_device.</span> <span class=\"nn\">Importing</span> <span class=\"nn\">anyway</span> <span class=\"nn\">for</span> <span class=\"nn\">backward</span> <span class=\"nn\">compatibility</span><span class=\"o\">,</span> <span class=\"nn\">but</span> <span class=\"nn\">this</span> <span class=\"nn\">may</span> <span class=\"nn\">cause</span> <span class=\"nn\">some</span> <span class=\"nn\">unexpected</span> <span class=\"nn\">behaviour.</span>\n  <span class=\"n\">DummyPseudoclock</span><span class=\"p\">()</span>\n</pre></div>\n\n\n<p>The warning is only printed once if you instantiate the class multiple times.</p>\n<p>I've also implemented the error if you call <code>register_classes</code> twice with the same labscript device name, so as long as you agree with the aliasing/deprecation stuff, I think that's all on the todo list for this pull request.</p>", "type": "rendered"}, "created_on": "2018-10-02T17:52:52.623647+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-10-02T18:19:03.794184+00:00", "type": "pullrequest_comment", "id": 77792305}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/comments/77821365.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51/_/diff#comment-77821365"}}, "parent": {"id": 77792305, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51/comments/77792305.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51/_/diff#comment-77792305"}}, "depth": 3}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 51, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/51.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/51"}}, "title": "Arbitrary subfolders for device code within labscript_devices"}, "content": {"raw": "Ok, sounds good.", "markup": "markdown", "html": "<p>Ok, sounds good.</p>", "type": "rendered"}, "created_on": "2018-10-03T00:13:21.419294+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}, "updated_on": "2018-10-03T00:13:21.429331+00:00", "type": "pullrequest_comment", "id": 77821365}], "page": 1, "size": 11}