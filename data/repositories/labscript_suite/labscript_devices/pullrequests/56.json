{"rendered": {"description": {"raw": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "markup": "markdown", "html": "<p>This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.</p>\n<p>The capabilities of the device can be added as instantiation arguments:</p>\n<div class=\"codehilite language-python\"><pre><span></span>    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span>\n        <span class=\"bp\">self</span><span class=\"p\">,</span>\n        <span class=\"n\">name</span><span class=\"p\">,</span>\n        <span class=\"n\">parent_device</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">clock_terminal</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">MAX_name</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">static_AO</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">static_DO</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">clock_mirror_terminal</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">acquisition_rate</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">AI_range</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">AI_start_delay</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span>\n        <span class=\"n\">AO_range</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">max_AI_multi_chan_rate</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">max_AI_single_chan_rate</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">max_AO_sample_rate</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">max_DO_sample_rate</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">min_semiperiod_measurement</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">num_AI</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span>\n        <span class=\"n\">num_AO</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span>\n        <span class=\"n\">num_CI</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span>\n        <span class=\"n\">ports</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">supports_buffered_AO</span><span class=\"o\">=</span><span class=\"bp\">False</span><span class=\"p\">,</span>\n        <span class=\"n\">supports_buffered_DO</span><span class=\"o\">=</span><span class=\"bp\">False</span><span class=\"p\">,</span>\n        <span class=\"n\">supports_semiperiod_measurement</span><span class=\"o\">=</span><span class=\"bp\">False</span><span class=\"p\">,</span>\n        <span class=\"o\">**</span><span class=\"n\">kwargs</span>\n    <span class=\"p\">):</span>\n</pre></div>\n\n\n<p>Alternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.</p>\n<p>All the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"n\">CAPABILITIES</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">&#39;AI_range&#39;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">10.0</span><span class=\"p\">,</span> <span class=\"mf\">10.0</span><span class=\"p\">],</span>\n    <span class=\"s1\">&#39;AI_start_delay&#39;</span><span class=\"p\">:</span> <span class=\"mf\">7e-08</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;AO_range&#39;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">10.0</span><span class=\"p\">,</span> <span class=\"mf\">10.0</span><span class=\"p\">],</span>\n    <span class=\"s1\">&#39;max_AI_multi_chan_rate&#39;</span><span class=\"p\">:</span> <span class=\"mf\">1000000.0</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;max_AI_single_chan_rate&#39;</span><span class=\"p\">:</span> <span class=\"mf\">2000000.0</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;max_AO_sample_rate&#39;</span><span class=\"p\">:</span> <span class=\"mf\">2857142.8571428573</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;max_DO_sample_rate&#39;</span><span class=\"p\">:</span> <span class=\"mf\">10000000.0</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;min_semiperiod_measurement&#39;</span><span class=\"p\">:</span> <span class=\"mf\">1e-07</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;num_AI&#39;</span><span class=\"p\">:</span> <span class=\"mi\">32</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;num_AO&#39;</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;num_CI&#39;</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;ports&#39;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">&#39;port0&#39;</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">&#39;num_lines&#39;</span><span class=\"p\">:</span> <span class=\"mi\">32</span><span class=\"p\">,</span> <span class=\"s1\">&#39;supports_buffered&#39;</span><span class=\"p\">:</span> <span class=\"bp\">True</span><span class=\"p\">},</span>\n        <span class=\"s1\">&#39;port1&#39;</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">&#39;num_lines&#39;</span><span class=\"p\">:</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"s1\">&#39;supports_buffered&#39;</span><span class=\"p\">:</span> <span class=\"bp\">False</span><span class=\"p\">},</span>\n        <span class=\"s1\">&#39;port2&#39;</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">&#39;num_lines&#39;</span><span class=\"p\">:</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"s1\">&#39;supports_buffered&#39;</span><span class=\"p\">:</span> <span class=\"bp\">False</span><span class=\"p\">},</span>\n    <span class=\"p\">},</span>\n    <span class=\"s1\">&#39;supports_buffered_AO&#39;</span><span class=\"p\">:</span> <span class=\"bp\">True</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;supports_buffered_DO&#39;</span><span class=\"p\">:</span> <span class=\"bp\">True</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;supports_semiperiod_measurement&#39;</span><span class=\"p\">:</span> <span class=\"bp\">True</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">NI_PCIe_6363</span><span class=\"p\">(</span><span class=\"n\">NI_DAQmx</span><span class=\"p\">):</span>\n    <span class=\"n\">description</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;NI-PCIe-6363&#39;</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Any provided kwargs take precedent over capabilities</span>\n        <span class=\"n\">combined_kwargs</span> <span class=\"o\">=</span> <span class=\"n\">CAPABILITIES</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n        <span class=\"n\">combined_kwargs</span><span class=\"o\">.</span><span class=\"n\">update</span><span class=\"p\">(</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n        <span class=\"n\">NI_DAQmx</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">combined_kwargs</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>Futhermore, these subclasses can be automatically generated for new devices. The file <code>labscript_devices/NI_DAQmx/models/get_capabilities.py</code> will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, <code>labscript_devices/NI_DAQmx/models/capabiltiies.json</code>. The classes can then be generated from this JSON file and a template, by running <code>labscript_devices/NI_DAQmx/models/generate_subclasses.py</code>. There is a <code>README</code> file in the folder explaining this process.</p>\n<p>Although there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.</p>\n<p>The capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument <code>AI_range=[-1, 1]</code> even if the device supports a larger analog input range.</p>\n<p>There are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to <code>Task.WaitUntilTaskDone()</code> with a one second timeout, which fixes this race condition without wasting any more time than necessary.</p>\n<p>There was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.</p>\n<p>There is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.</p>\n<p>Some DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.</p>\n<p>I have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.</p>\n<p>The code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).</p>\n<p>Limitations:</p>\n<p>Where a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).</p>\n<p>These classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).</p>\n<p>I have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg <code>from labscript_devices.NI_DAQmx.models import NI_PCIe_6363</code>) and prints a deprecation warning telling the user to use the new import location.</p>\n<p>Another limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port&lt;N&gt;/line&lt;M&gt;' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.</p>\n<p>All in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of <a data-is-external-link=\"true\" href=\"https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997\" rel=\"nofollow\">different behaviour of different devices when it comes to semiperiod measurements</a>.</p>\n<p>As always, testing is appreciated.</p>", "type": "rendered"}, "title": {"raw": "Universal NI DAQmx support", "markup": "markdown", "html": "<p>Universal NI DAQmx support</p>", "type": "rendered"}}, "type": "pullrequest", "description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "links": {"decline": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/pullrequests/56/decline"}, "diffstat": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/diffstat/labscript_suite/labscript_devices:fe5e25655613%0D426f64fa05b8?from_pullrequest_id=56"}, "commits": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/commits.json"}, "self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "comments": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments_page=1.json"}, "merge": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/pullrequests/56/merge"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}, "activity": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/activity.json"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/diff/labscript_suite/labscript_devices:fe5e25655613%0D426f64fa05b8?from_pullrequest_id=56"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/pullrequests/56/approve"}, "statuses": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/statuses_page=1.json"}}, "title": "Universal NI DAQmx support", "close_source_branch": true, "reviewers": [{"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}, {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}, {"display_name": "Shaun Johnstone", "uuid": "{652df738-313d-472c-b7b5-a3f8f98a3322}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B652df738-313d-472c-b7b5-a3f8f98a3322%7D"}, "html": {"href": "https://bitbucket.org/%7B652df738-313d-472c-b7b5-a3f8f98a3322%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/38984f1761fc67ce892911496abee619d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSJ-3.png"}}, "nickname": "shjohnst", "type": "user", "account_id": "557058:1b9a15fb-8e4f-407e-b7b9-567c5e1fa1b4"}], "id": 56, "destination": {"commit": {"hash": "426f64fa05b8", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/426f64fa05b8.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/426f64fa05b8"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "created_on": "2018-11-10T17:30:45.323659+00:00", "summary": {"raw": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "markup": "markdown", "html": "<p>This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.</p>\n<p>The capabilities of the device can be added as instantiation arguments:</p>\n<div class=\"codehilite language-python\"><pre><span></span>    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span>\n        <span class=\"bp\">self</span><span class=\"p\">,</span>\n        <span class=\"n\">name</span><span class=\"p\">,</span>\n        <span class=\"n\">parent_device</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">clock_terminal</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">MAX_name</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">static_AO</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">static_DO</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">clock_mirror_terminal</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">acquisition_rate</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">AI_range</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">AI_start_delay</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span>\n        <span class=\"n\">AO_range</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">max_AI_multi_chan_rate</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">max_AI_single_chan_rate</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">max_AO_sample_rate</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">max_DO_sample_rate</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">min_semiperiod_measurement</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">num_AI</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span>\n        <span class=\"n\">num_AO</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span>\n        <span class=\"n\">num_CI</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span>\n        <span class=\"n\">ports</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">supports_buffered_AO</span><span class=\"o\">=</span><span class=\"bp\">False</span><span class=\"p\">,</span>\n        <span class=\"n\">supports_buffered_DO</span><span class=\"o\">=</span><span class=\"bp\">False</span><span class=\"p\">,</span>\n        <span class=\"n\">supports_semiperiod_measurement</span><span class=\"o\">=</span><span class=\"bp\">False</span><span class=\"p\">,</span>\n        <span class=\"o\">**</span><span class=\"n\">kwargs</span>\n    <span class=\"p\">):</span>\n</pre></div>\n\n\n<p>Alternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.</p>\n<p>All the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"n\">CAPABILITIES</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">&#39;AI_range&#39;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">10.0</span><span class=\"p\">,</span> <span class=\"mf\">10.0</span><span class=\"p\">],</span>\n    <span class=\"s1\">&#39;AI_start_delay&#39;</span><span class=\"p\">:</span> <span class=\"mf\">7e-08</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;AO_range&#39;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">10.0</span><span class=\"p\">,</span> <span class=\"mf\">10.0</span><span class=\"p\">],</span>\n    <span class=\"s1\">&#39;max_AI_multi_chan_rate&#39;</span><span class=\"p\">:</span> <span class=\"mf\">1000000.0</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;max_AI_single_chan_rate&#39;</span><span class=\"p\">:</span> <span class=\"mf\">2000000.0</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;max_AO_sample_rate&#39;</span><span class=\"p\">:</span> <span class=\"mf\">2857142.8571428573</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;max_DO_sample_rate&#39;</span><span class=\"p\">:</span> <span class=\"mf\">10000000.0</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;min_semiperiod_measurement&#39;</span><span class=\"p\">:</span> <span class=\"mf\">1e-07</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;num_AI&#39;</span><span class=\"p\">:</span> <span class=\"mi\">32</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;num_AO&#39;</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;num_CI&#39;</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;ports&#39;</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">&#39;port0&#39;</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">&#39;num_lines&#39;</span><span class=\"p\">:</span> <span class=\"mi\">32</span><span class=\"p\">,</span> <span class=\"s1\">&#39;supports_buffered&#39;</span><span class=\"p\">:</span> <span class=\"bp\">True</span><span class=\"p\">},</span>\n        <span class=\"s1\">&#39;port1&#39;</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">&#39;num_lines&#39;</span><span class=\"p\">:</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"s1\">&#39;supports_buffered&#39;</span><span class=\"p\">:</span> <span class=\"bp\">False</span><span class=\"p\">},</span>\n        <span class=\"s1\">&#39;port2&#39;</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">&#39;num_lines&#39;</span><span class=\"p\">:</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"s1\">&#39;supports_buffered&#39;</span><span class=\"p\">:</span> <span class=\"bp\">False</span><span class=\"p\">},</span>\n    <span class=\"p\">},</span>\n    <span class=\"s1\">&#39;supports_buffered_AO&#39;</span><span class=\"p\">:</span> <span class=\"bp\">True</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;supports_buffered_DO&#39;</span><span class=\"p\">:</span> <span class=\"bp\">True</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;supports_semiperiod_measurement&#39;</span><span class=\"p\">:</span> <span class=\"bp\">True</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">NI_PCIe_6363</span><span class=\"p\">(</span><span class=\"n\">NI_DAQmx</span><span class=\"p\">):</span>\n    <span class=\"n\">description</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;NI-PCIe-6363&#39;</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Any provided kwargs take precedent over capabilities</span>\n        <span class=\"n\">combined_kwargs</span> <span class=\"o\">=</span> <span class=\"n\">CAPABILITIES</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n        <span class=\"n\">combined_kwargs</span><span class=\"o\">.</span><span class=\"n\">update</span><span class=\"p\">(</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n        <span class=\"n\">NI_DAQmx</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">combined_kwargs</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>Futhermore, these subclasses can be automatically generated for new devices. The file <code>labscript_devices/NI_DAQmx/models/get_capabilities.py</code> will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, <code>labscript_devices/NI_DAQmx/models/capabiltiies.json</code>. The classes can then be generated from this JSON file and a template, by running <code>labscript_devices/NI_DAQmx/models/generate_subclasses.py</code>. There is a <code>README</code> file in the folder explaining this process.</p>\n<p>Although there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.</p>\n<p>The capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument <code>AI_range=[-1, 1]</code> even if the device supports a larger analog input range.</p>\n<p>There are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to <code>Task.WaitUntilTaskDone()</code> with a one second timeout, which fixes this race condition without wasting any more time than necessary.</p>\n<p>There was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.</p>\n<p>There is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.</p>\n<p>Some DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.</p>\n<p>I have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.</p>\n<p>The code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).</p>\n<p>Limitations:</p>\n<p>Where a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).</p>\n<p>These classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).</p>\n<p>I have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg <code>from labscript_devices.NI_DAQmx.models import NI_PCIe_6363</code>) and prints a deprecation warning telling the user to use the new import location.</p>\n<p>Another limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port&lt;N&gt;/line&lt;M&gt;' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.</p>\n<p>All in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of <a data-is-external-link=\"true\" href=\"https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997\" rel=\"nofollow\">different behaviour of different devices when it comes to semiperiod measurements</a>.</p>\n<p>As always, testing is appreciated.</p>", "type": "rendered"}, "source": {"commit": {"hash": "192fea8ab7df", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/192fea8ab7df"}, "html": {"href": "#!/cbillington/labscript_devices/commits/192fea8ab7df"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "comment_count": 34, "state": "MERGED", "task_count": 0, "participants": [{"role": "PARTICIPANT", "participated_on": "2019-06-01T17:19:09.628348+00:00", "type": "participant", "approved": false, "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}}, {"role": "REVIEWER", "participated_on": null, "type": "participant", "approved": false, "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}}, {"role": "REVIEWER", "participated_on": "2019-03-27T12:18:27.629744+00:00", "type": "participant", "approved": true, "user": {"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}}, {"role": "PARTICIPANT", "participated_on": "2019-04-30T10:01:35.381960+00:00", "type": "participant", "approved": false, "user": {"display_name": "Lars Kohfahl", "uuid": "{14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a%7D"}, "html": {"href": "https://bitbucket.org/%7B14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/630642264cd55e22515678a3a0489ac7d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLK-2.png"}}, "nickname": "lkohfahl", "type": "user", "account_id": "5aafc5d11396802a57aa7f3b"}}, {"role": "REVIEWER", "participated_on": null, "type": "participant", "approved": false, "user": {"display_name": "Shaun Johnstone", "uuid": "{652df738-313d-472c-b7b5-a3f8f98a3322}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B652df738-313d-472c-b7b5-a3f8f98a3322%7D"}, "html": {"href": "https://bitbucket.org/%7B652df738-313d-472c-b7b5-a3f8f98a3322%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/38984f1761fc67ce892911496abee619d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSJ-3.png"}}, "nickname": "shjohnst", "type": "user", "account_id": "557058:1b9a15fb-8e4f-407e-b7b9-567c5e1fa1b4"}}], "reason": "", "updated_on": "2019-06-01T17:19:17.201430+00:00", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "merge_commit": {"hash": "fe5e25655613", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/fe5e25655613.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/fe5e25655613"}}}, "closed_by": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}}