{"pagelen": 50, "values": [{"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "426f64fa05b8", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/426f64fa05b8.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/426f64fa05b8"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "192fea8ab7df", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/192fea8ab7df"}, "html": {"href": "#!/cbillington/labscript_devices/commits/192fea8ab7df"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "MERGED", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-06-01T17:19:17.215963+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "426f64fa05b8", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/426f64fa05b8.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/426f64fa05b8"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "192fea8ab7df", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/192fea8ab7df"}, "html": {"href": "#!/cbillington/labscript_devices/commits/192fea8ab7df"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-06-01T17:19:15.493578+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/104182009.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-104182009"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Now that BLACS's transition_to_manual is deserialised, I'll merge this.\n\nWill tag BLACS with a version number for the deserialisation and have labscript devices depend on it.\n\nThanks for everyone who tested and helped find issues with this!", "markup": "markdown", "html": "<p>Now that BLACS's transition_to_manual is deserialised, I'll merge this.</p>\n<p>Will tag BLACS with a version number for the deserialisation and have labscript devices depend on it.</p>\n<p>Thanks for everyone who tested and helped find issues with this!</p>", "type": "rendered"}, "created_on": "2019-06-01T17:19:09.600010+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-06-01T17:19:09.628348+00:00", "type": "pullrequest_comment", "id": 104182009}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "21cf797f0b6c", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/21cf797f0b6c.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/21cf797f0b6c"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "192fea8ab7df", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/192fea8ab7df"}, "html": {"href": "#!/cbillington/labscript_devices/commits/192fea8ab7df"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-05-20T16:00:33.052428+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "21cf797f0b6c", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/21cf797f0b6c.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/21cf797f0b6c"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "192fea8ab7df", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/192fea8ab7df"}, "html": {"href": "#!/cbillington/labscript_devices/commits/192fea8ab7df"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-05-20T15:59:59.907183+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "21cf797f0b6c", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/21cf797f0b6c.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/21cf797f0b6c"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "192fea8ab7df", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/192fea8ab7df"}, "html": {"href": "#!/cbillington/labscript_devices/commits/192fea8ab7df"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-05-20T15:59:34.300856+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "21cf797f0b6c", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/21cf797f0b6c.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/21cf797f0b6c"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "192fea8ab7df", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/192fea8ab7df"}, "html": {"href": "#!/cbillington/labscript_devices/commits/192fea8ab7df"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-05-20T15:58:39.839757+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "49bf56369af4", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/49bf56369af4.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/49bf56369af4"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "192fea8ab7df", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/192fea8ab7df"}, "html": {"href": "#!/cbillington/labscript_devices/commits/192fea8ab7df"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-05-16T17:50:06.276591+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "49bf56369af4", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/49bf56369af4.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/49bf56369af4"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "992fcdbb0f26", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/992fcdbb0f26"}, "html": {"href": "#!/cbillington/labscript_devices/commits/992fcdbb0f26"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-05-16T15:33:57.266722+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "49bf56369af4", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/49bf56369af4.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/49bf56369af4"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "992fcdbb0f26", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/992fcdbb0f26"}, "html": {"href": "#!/cbillington/labscript_devices/commits/992fcdbb0f26"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-05-16T03:54:24.093055+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/102223628.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-102223628"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "By the way, if anyone is wondering why this isn't merged yet, it's because BLACS' `transition_to_manual` is still serialised, i.e. one device at a time, and this creates a deadlock if an NI DAQmx device doing analog input is waiting for information about waits from another NI DAQmx device. This is the case at Monash, and although the bug exists in the existing classes, dictionaries in Python 2 have an arbitrary order and so merging this code could cause a deadlock on Monash's setups that just so happen to have an arbitrary order that presently works.\n\nSo this will be merged once [BLACS PR #47](#!/labscript_suite/blacs/pull-requests/47/deserialise-transition_to_manual/diff) or something equivalent is merged, which is on my list of things to do.", "markup": "markdown", "html": "<p>By the way, if anyone is wondering why this isn't merged yet, it's because BLACS' <code>transition_to_manual</code> is still serialised, i.e. one device at a time, and this creates a deadlock if an NI DAQmx device doing analog input is waiting for information about waits from another NI DAQmx device. This is the case at Monash, and although the bug exists in the existing classes, dictionaries in Python 2 have an arbitrary order and so merging this code could cause a deadlock on Monash's setups that just so happen to have an arbitrary order that presently works.</p>\n<p>So this will be merged once <a data-is-external-link=\"true\" href=\"#!/labscript_suite/blacs/pull-requests/47/deserialise-transition_to_manual/diff\" rel=\"nofollow\">BLACS PR #47</a> or something equivalent is merged, which is on my list of things to do.</p>", "type": "rendered"}, "created_on": "2019-05-16T03:38:10.991093+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-05-16T03:38:36.136847+00:00", "type": "pullrequest_comment", "id": 102223628}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "49bf56369af4", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/49bf56369af4.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/49bf56369af4"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "5f5c2682b28b", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/5f5c2682b28b"}, "html": {"href": "#!/cbillington/labscript_devices/commits/5f5c2682b28b"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-05-16T03:33:36.103153+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/102016254.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-102016254"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Note to self, hit this minor bug on shutdown:\n```\n2019-05-14 14:43:00,808 ERROR BLACS.NI_USB_6229_0_acquisition_worker.worker: Exception in job:\nTraceback (most recent call last):\n  File \"C:\\labscript_suite\\labscript_devices\\NI_DAQmx\\blacs_workers.py\", line 439, in shutdown\n    self.stop_task()\n  File \"C:\\labscript_suite\\labscript_devices\\NI_DAQmx\\blacs_workers.py\", line 520, in stop_task\n    if len(self.buffered_chans) and self.task is None:\nTypeError: object of type 'NoneType' has no len()\n```", "markup": "markdown", "html": "<p>Note to self, hit this minor bug on shutdown:</p>\n<div class=\"codehilite\"><pre><span></span>2019-05-14 14:43:00,808 ERROR BLACS.NI_USB_6229_0_acquisition_worker.worker: Exception in job:\nTraceback (most recent call last):\n  File &quot;C:\\labscript_suite\\labscript_devices\\NI_DAQmx\\blacs_workers.py&quot;, line 439, in shutdown\n    self.stop_task()\n  File &quot;C:\\labscript_suite\\labscript_devices\\NI_DAQmx\\blacs_workers.py&quot;, line 520, in stop_task\n    if len(self.buffered_chans) and self.task is None:\nTypeError: object of type &#39;NoneType&#39; has no len()\n</pre></div>", "type": "rendered"}, "created_on": "2019-05-14T18:49:12.365289+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-05-14T18:49:12.375172+00:00", "type": "pullrequest_comment", "id": 102016254}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/102016219.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-102016219"}}, "parent": {"id": 100434369, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/100434369.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-100434369"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Hi lars, apologies for the slow reply. This AI start delay is not related to instructions generated on any devices, it is only about how the analog acquisition data is interpreted later. So I don't think it is the problem.\n\nIt sounds like you are the victim of a timing bug in labscript. Could you post the exact error message you get, or perhaps a script that demonstrates the problem?", "markup": "markdown", "html": "<p>Hi lars, apologies for the slow reply. This AI start delay is not related to instructions generated on any devices, it is only about how the analog acquisition data is interpreted later. So I don't think it is the problem.</p>\n<p>It sounds like you are the victim of a timing bug in labscript. Could you post the exact error message you get, or perhaps a script that demonstrates the problem?</p>", "type": "rendered"}, "created_on": "2019-05-14T18:48:53.956081+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-05-14T18:48:53.971358+00:00", "type": "pullrequest_comment", "id": 102016219}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "49bf56369af4", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/49bf56369af4.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/49bf56369af4"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "b78acc324947", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/b78acc324947"}, "html": {"href": "#!/cbillington/labscript_devices/commits/b78acc324947"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-05-14T18:39:57.091113+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "ab5dc8e458ac", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/ab5dc8e458ac.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/ab5dc8e458ac"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "f325c6f17c72", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/f325c6f17c72"}, "html": {"href": "#!/cbillington/labscript_devices/commits/f325c6f17c72"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-05-09T02:06:31.087358+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/100434369.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-100434369"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "I am currently testing this PR in our second lab. We there use the PCIe\\_6351 AI-card. Getting the capabilities was no problem and also Blacs works fine with it. However, when compiling the first script with runmanager I encountered a problem: It says that the update delays for the pulseblaster are to short. The script is the same as before which but I think I found the problem: In the capabilities of the NI-card it says that the start delay is 70ns. Depending on the pulse sequence this can result in a error as it is now multiple of PB\u2019s 50ns clock.\n\nLooking in our old NI\\_class I think we just did not specify and therefore not use this delay.\n\nAs a quick fix I tried to change the AI\\_start\\_delay in the models/NI\\_6351.py-file to e.g. 100ns but this did not help. Moving the pulses in our script a bit, compiling works and with runviewer it is shown that there is a rising edge on the AI\\_clockline at 2.02us which then causes a problem when having a 2us pulse at the beginning, as we have.\n\nAre there any ideas how to fix it in general? A not so nice fix is to implement a waiting time of some us at the beginning. ", "markup": "markdown", "html": "<p>I am currently testing this PR in our second lab. We there use the PCIe_6351 AI-card. Getting the capabilities was no problem and also Blacs works fine with it. However, when compiling the first script with runmanager I encountered a problem: It says that the update delays for the pulseblaster are to short. The script is the same as before which but I think I found the problem: In the capabilities of the NI-card it says that the start delay is 70ns. Depending on the pulse sequence this can result in a error as it is now multiple of PB\u2019s 50ns clock.</p>\n<p>Looking in our old NI_class I think we just did not specify and therefore not use this delay.</p>\n<p>As a quick fix I tried to change the AI_start_delay in the models/NI_6351.py-file to e.g. 100ns but this did not help. Moving the pulses in our script a bit, compiling works and with runviewer it is shown that there is a rising edge on the AI_clockline at 2.02us which then causes a problem when having a 2us pulse at the beginning, as we have.</p>\n<p>Are there any ideas how to fix it in general? A not so nice fix is to implement a waiting time of some us at the beginning. </p>", "type": "rendered"}, "created_on": "2019-04-30T10:01:35.268183+00:00", "user": {"display_name": "Lars Kohfahl", "uuid": "{14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a%7D"}, "html": {"href": "https://bitbucket.org/%7B14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/630642264cd55e22515678a3a0489ac7d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLK-2.png"}}, "nickname": "lkohfahl", "type": "user", "account_id": "5aafc5d11396802a57aa7f3b"}, "updated_on": "2019-04-30T10:01:35.381960+00:00", "type": "pullrequest_comment", "id": 100434369}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "a2d4d00960d5", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/a2d4d00960d5.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/a2d4d00960d5"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4940132f587f", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/4940132f587f"}, "html": {"href": "#!/cbillington/labscript_devices/commits/4940132f587f"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-04-06T04:22:00.926902+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/97032466.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-97032466"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Okay, then I see where I have to go deeper into the code \\(or leave it as it is :smiley: \\)to solve things. Thanks.", "markup": "markdown", "html": "<p>Okay, then I see where I have to go deeper into the code (or leave it as it is <img class=\"emoji\" src=\"data/pf-emoji-service--cdn.us-east-1.prod.public.atl-paas.net/standard/551c9814-1d37-4573-819d-afab3afeaf32/48x48/1f603.png\" alt=\"\ud83d\ude03\" title=\":smiley:\" data-emoji-short-name=\":smiley:\" /> )to solve things. Thanks.</p>", "type": "rendered"}, "created_on": "2019-04-01T07:07:57.363705+00:00", "user": {"display_name": "Lars Kohfahl", "uuid": "{14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a%7D"}, "html": {"href": "https://bitbucket.org/%7B14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/630642264cd55e22515678a3a0489ac7d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLK-2.png"}}, "nickname": "lkohfahl", "type": "user", "account_id": "5aafc5d11396802a57aa7f3b"}, "updated_on": "2019-04-01T07:07:57.422718+00:00", "type": "pullrequest_comment", "id": 97032466}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/96950195.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-96950195"}}, "parent": {"id": 96942607, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/96942607.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-96942607"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Excellent. So they are just not showing up because the manual-mode analog input pull request from your group hasn\u2019t been merged into mainline yet, whereas you were presumably using it previously. I will get it merged at some point and modify this driver to use it, and then the AI widgets will reappear.\n\nGood to hear everything else is working.\n\nI\u2019m not sure it is worth trying to do anything about the number of samples needing to be a multiple of four. This is pretty tricky given labscript\u2019s design, and is not a requirement for all but the oldest NI DAQ devices. But if it is something you want to automate jsut for your lab, there are hacky ways to do it that might be worth putting in your own setup, but I would be hesitant to make the change to mainline labscript. Basically you would modify the pseudoclock\u2019s collect\\_change\\_times method to modify the change times to be a multiple of four by inserting extra ones, perhaps at the end \\(but before the final instruction\\). But then it\u2019s up to you to make sure this doesn\u2019t violate any timing requirements. Only the pseudoclock controlling that DAQmx device would need the change.\n\n\u200c\n\nEdit: actually it\u2019s not even that simple because collect\\_change\\_times hasn\u2019t expanded ramps yet. This is a hard problem and maybe not worth solving!", "markup": "markdown", "html": "<p>Excellent. So they are just not showing up because the manual-mode analog input pull request from your group hasn\u2019t been merged into mainline yet, whereas you were presumably using it previously. I will get it merged at some point and modify this driver to use it, and then the AI widgets will reappear.</p>\n<p>Good to hear everything else is working.</p>\n<p>I\u2019m not sure it is worth trying to do anything about the number of samples needing to be a multiple of four. This is pretty tricky given labscript\u2019s design, and is not a requirement for all but the oldest NI DAQ devices. But if it is something you want to automate jsut for your lab, there are hacky ways to do it that might be worth putting in your own setup, but I would be hesitant to make the change to mainline labscript. Basically you would modify the pseudoclock\u2019s collect_change_times method to modify the change times to be a multiple of four by inserting extra ones, perhaps at the end (but before the final instruction). But then it\u2019s up to you to make sure this doesn\u2019t violate any timing requirements. Only the pseudoclock controlling that DAQmx device would need the change.</p>\n<p>\u200c</p>\n<p>Edit: actually it\u2019s not even that simple because collect_change_times hasn\u2019t expanded ramps yet. This is a hard problem and maybe not worth solving!</p>", "type": "rendered"}, "created_on": "2019-03-29T16:23:07.211720+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-03-29T17:13:26.263843+00:00", "type": "pullrequest_comment", "id": 96950195}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/96942607.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-96942607"}}, "parent": {"id": 96896208, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/96896208.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-96896208"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Sry, I think I was a littlebit wrong: for the 6251, the AI\u2019s are found. Usually the AO values were shown in our setup in the tab of the 6251-card. Now this is not the case anymore but I just checked: The values are saved, so the card and the communication with it work fine.", "markup": "markdown", "html": "<p>Sry, I think I was a littlebit wrong: for the 6251, the AI\u2019s are found. Usually the AO values were shown in our setup in the tab of the 6251-card. Now this is not the case anymore but I just checked: The values are saved, so the card and the communication with it work fine.</p>", "type": "rendered"}, "created_on": "2019-03-29T15:33:03.610412+00:00", "user": {"display_name": "Lars Kohfahl", "uuid": "{14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a%7D"}, "html": {"href": "https://bitbucket.org/%7B14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/630642264cd55e22515678a3a0489ac7d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLK-2.png"}}, "nickname": "lkohfahl", "type": "user", "account_id": "5aafc5d11396802a57aa7f3b"}, "updated_on": "2019-03-29T15:33:03.686271+00:00", "type": "pullrequest_comment", "id": 96942607}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/96896208.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-96896208"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Thanks for that update. Due to a conference it took some time for testing, so here are my results:\n\nAll cards initialize now.\n\nFor the NI\\_6534: It is working fine down to the minimum pulse length of 100ns. Also restarting the tab and reinitialising works fine\n\nFor the NI\\_6713: Outputs work fine; Timing is also okay but there is this problem with \u201c4 samples per channel\u201d poping up depending on my code \\( which makes sense :smiley: \\).\n\nFor NI\\_6251: get capabilities finds 2 Anaolog Outputs and port 0 to 2 with 8 Digital outs each but this card has 16 analog ins which are not found.", "markup": "markdown", "html": "<p>Thanks for that update. Due to a conference it took some time for testing, so here are my results:</p>\n<p>All cards initialize now.</p>\n<p>For the NI_6534: It is working fine down to the minimum pulse length of 100ns. Also restarting the tab and reinitialising works fine</p>\n<p>For the NI_6713: Outputs work fine; Timing is also okay but there is this problem with \u201c4 samples per channel\u201d poping up depending on my code ( which makes sense <img class=\"emoji\" src=\"data/pf-emoji-service--cdn.us-east-1.prod.public.atl-paas.net/standard/551c9814-1d37-4573-819d-afab3afeaf32/48x48/1f603.png\" alt=\"\ud83d\ude03\" title=\":smiley:\" data-emoji-short-name=\":smiley:\" /> ).</p>\n<p>For NI_6251: get capabilities finds 2 Anaolog Outputs and port 0 to 2 with 8 Digital outs each but this card has 16 analog ins which are not found.</p>", "type": "rendered"}, "created_on": "2019-03-29T10:47:58.291630+00:00", "user": {"display_name": "Lars Kohfahl", "uuid": "{14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a%7D"}, "html": {"href": "https://bitbucket.org/%7B14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/630642264cd55e22515678a3a0489ac7d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLK-2.png"}}, "nickname": "lkohfahl", "type": "user", "account_id": "5aafc5d11396802a57aa7f3b"}, "updated_on": "2019-03-29T10:47:58.368293+00:00", "type": "pullrequest_comment", "id": 96896208}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"approval": {"date": "2019-03-27T12:18:27.629744+00:00", "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "user": {"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/95920777.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-95920777"}}, "parent": {"id": 95836681, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/95836681.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-95836681"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Try the most recent commit - this one ignores ports that have zero lines when setting up the manual mode tasks. Works for me with a simulated device, in manual mode at least.", "markup": "markdown", "html": "<p>Try the most recent commit - this one ignores ports that have zero lines when setting up the manual mode tasks. Works for me with a simulated device, in manual mode at least.</p>", "type": "rendered"}, "created_on": "2019-03-21T16:18:24.650134+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-03-21T16:18:24.671848+00:00", "type": "pullrequest_comment", "id": 95920777}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "a669226f0fbb", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/a669226f0fbb.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/a669226f0fbb"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "0a498b108e54", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/0a498b108e54"}, "html": {"href": "#!/cbillington/labscript_devices/commits/0a498b108e54"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-03-21T16:17:20.471076+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/95906134.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-95906134"}}, "parent": {"id": 95836681, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/95836681.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-95836681"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "I would have suspected the same thing, and I\u2019m not sure why your fix \\(modifying the subclass\u2019s capabilities dict to exclude ports 4 and 5\\), would not have worked. I\u2019ll see if I can reproduce the issue with a simulated device.\n\nAh, to be clear, the capabilities are stored both in capabilities.json and NI\\_PCI\\_6534.py. The former is used to generate the latter. So modifying NI\\_PCI\\_6534.py is what you would want to do to test your theory.\n\n\u200c", "markup": "markdown", "html": "<p>I would have suspected the same thing, and I\u2019m not sure why your fix (modifying the subclass\u2019s capabilities dict to exclude ports 4 and 5), would not have worked. I\u2019ll see if I can reproduce the issue with a simulated device.</p>\n<p>Ah, to be clear, the capabilities are stored both in capabilities.json and NI_PCI_6534.py. The former is used to generate the latter. So modifying NI_PCI_6534.py is what you would want to do to test your theory.</p>\n<p>\u200c</p>", "type": "rendered"}, "created_on": "2019-03-21T15:07:56.722751+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-03-21T15:10:26.042584+00:00", "type": "pullrequest_comment", "id": 95906134}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/95836681.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-95836681"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "The last update works fine for us for PCI\\_6713 and PCI\\_6251. NI\\_6534 has a problem when seting up the DO channels.\n\nThe error message is the following:  \n\n```\nException in worker - Thu Mar 21, 09:11:56 :\r\nTraceback (most recent call last):\r\n  File \"C:\\labscript_suite\\labscript_devices\\NI_DAQmx\\blacs_workers.py\", line 55, in init\r\n    self.start_manual_mode_tasks()\r\n  File \"C:\\labscript_suite\\labscript_devices\\NI_DAQmx\\blacs_workers.py\", line 114, in start_manual_mode_tasks\r\n    self.DO_task.StartTask()\r\n  File \"<string>\", line 3, in StartTask\r\n  File \"<string>\", line 2, in function\r\n  File \"C:\\ProgramData\\Anaconda3\\lib\\site-packages\\PyDAQmx\\DAQmxFunctions.py\", line 62, in mafunction\r\n    raise exception_class(errBuff.value.decode(\"utf-8\"), f.__name__)\r\nPyDAQmx.DAQmxFunctions.InvalidChannelError: Channel is not in the task, and the channel is not a valid global channel.\r\n\r\nMake sure that the channel is in the task or that the channel is a valid global channel. If you explicitly named the virtual channel in DAQmx Create Channel, you must use the name assigned to that channel. Also, check for typing errors.\r\nTask Name: _unnamedTask<0>\r\n\r\nStatus Code: -200087\r\n in function DAQmxStartTask\n```\n\nI had a look in our current NI\\_DAQmx class from @PhyNerd and he initialised the DO\\_channels like this:\n\n```\n# TODO: Currently labscript only supports one DO port, easy to add more\r\n        # by passing a suitable structure of DO ports\r\n        # I verified above that num['num_DO'] is a factor of 8\r\n        for i in range(self.num['num_ports_DO']):\r\n            for j in range(self.num['num_DO']//self.num['num_ports_DO']//8):\r\n                self.do_task.CreateDOChan(self.MAX_name+\"/port%d/line%d:%d\"%(i, 8*j, 8*j+7),\"\", DAQmx_Val_ChanForAllLines)\r\n\r\n        # currently do not allow direct access to PFI ports.  In the future can refer to NU_USB6346 code for an example\n```\n\nAs we pass in our NI\\_DAQmx class the number of DO ports by hand \\(num\\_DO\\_ports =4\\) and we encountered yesterday that automatically 6 ports are found I thought that this is maybe causing the problem, so I removed the two extra ports in the model-file but this did not change anything. I suspect this is because the port settings are stored somewhere else aswell as before and after the change blacs shows 5 ports in the tab \\(port 0-3 and port 5\\).", "markup": "markdown", "html": "<p>The last update works fine for us for PCI_6713 and PCI_6251. NI_6534 has a problem when seting up the DO channels.</p>\n<p>The error message is the following:  </p>\n<div class=\"codehilite\"><pre><span></span>Exception in worker - Thu Mar 21, 09:11:56 :\nTraceback (most recent call last):\n  File &quot;C:\\labscript_suite\\labscript_devices\\NI_DAQmx\\blacs_workers.py&quot;, line 55, in init\n    self.start_manual_mode_tasks()\n  File &quot;C:\\labscript_suite\\labscript_devices\\NI_DAQmx\\blacs_workers.py&quot;, line 114, in start_manual_mode_tasks\n    self.DO_task.StartTask()\n  File &quot;&lt;string&gt;&quot;, line 3, in StartTask\n  File &quot;&lt;string&gt;&quot;, line 2, in function\n  File &quot;C:\\ProgramData\\Anaconda3\\lib\\site-packages\\PyDAQmx\\DAQmxFunctions.py&quot;, line 62, in mafunction\n    raise exception_class(errBuff.value.decode(&quot;utf-8&quot;), f.__name__)\nPyDAQmx.DAQmxFunctions.InvalidChannelError: Channel is not in the task, and the channel is not a valid global channel.\n\nMake sure that the channel is in the task or that the channel is a valid global channel. If you explicitly named the virtual channel in DAQmx Create Channel, you must use the name assigned to that channel. Also, check for typing errors.\nTask Name: _unnamedTask&lt;0&gt;\n\nStatus Code: -200087\n in function DAQmxStartTask\n</pre></div>\n\n\n<p>I had a look in our current NI_DAQmx class from @PhyNerd and he initialised the DO_channels like this:</p>\n<div class=\"codehilite\"><pre><span></span># TODO: Currently labscript only supports one DO port, easy to add more\n        # by passing a suitable structure of DO ports\n        # I verified above that num[&#39;num_DO&#39;] is a factor of 8\n        for i in range(self.num[&#39;num_ports_DO&#39;]):\n            for j in range(self.num[&#39;num_DO&#39;]//self.num[&#39;num_ports_DO&#39;]//8):\n                self.do_task.CreateDOChan(self.MAX_name+&quot;/port%d/line%d:%d&quot;%(i, 8*j, 8*j+7),&quot;&quot;, DAQmx_Val_ChanForAllLines)\n\n        # currently do not allow direct access to PFI ports.  In the future can refer to NU_USB6346 code for an example\n</pre></div>\n\n\n<p>As we pass in our NI_DAQmx class the number of DO ports by hand (num_DO_ports =4) and we encountered yesterday that automatically 6 ports are found I thought that this is maybe causing the problem, so I removed the two extra ports in the model-file but this did not change anything. I suspect this is because the port settings are stored somewhere else aswell as before and after the change blacs shows 5 ports in the tab (port 0-3 and port 5).</p>", "type": "rendered"}, "created_on": "2019-03-21T08:28:18.508414+00:00", "user": {"display_name": "Lars Kohfahl", "uuid": "{14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a%7D"}, "html": {"href": "https://bitbucket.org/%7B14b59397-cbc0-4d8c-8a4a-fe99fb4d2d4a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/630642264cd55e22515678a3a0489ac7d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsLK-2.png"}}, "nickname": "lkohfahl", "type": "user", "account_id": "5aafc5d11396802a57aa7f3b"}, "updated_on": "2019-03-21T08:28:18.679358+00:00", "type": "pullrequest_comment", "id": 95836681}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "a669226f0fbb", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/a669226f0fbb.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/a669226f0fbb"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "baceabb22a11", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/baceabb22a11"}, "html": {"href": "#!/cbillington/labscript_devices/commits/baceabb22a11"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-03-20T16:21:20.729300+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "a669226f0fbb", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/a669226f0fbb.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/a669226f0fbb"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "cba6c6ff30b4", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/cba6c6ff30b4"}, "html": {"href": "#!/cbillington/labscript_devices/commits/cba6c6ff30b4"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-03-20T15:55:59.481804+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "66135a4f6547", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/66135a4f6547.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/66135a4f6547"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4f417ab05c6a", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/4f417ab05c6a"}, "html": {"href": "#!/cbillington/labscript_devices/commits/4f417ab05c6a"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-03-13T00:05:20.984845+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/90502753.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-90502753"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "As far as I know, we are at feature parity with the existing classes for this one, and there are no known bugs that do not also exist in the old classes. So this is getting close to being mergeable.\n\nAny chance for testing at Monash, @shjohnst or @lincolndturner ?", "markup": "markdown", "html": "<p>As far as I know, we are at feature parity with the existing classes for this one, and there are no known bugs that do not also exist in the old classes. So this is getting close to being mergeable.</p>\n<p>Any chance for testing at Monash, @shjohnst or @lincolndturner ?</p>", "type": "rendered"}, "created_on": "2019-02-05T16:17:26.077065+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-02-05T16:17:26.128383+00:00", "type": "pullrequest_comment", "id": 90502753}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "b2aecf92d620", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/b2aecf92d620.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/b2aecf92d620"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "b70c8c122041", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/b70c8c122041"}, "html": {"href": "#!/cbillington/labscript_devices/commits/b70c8c122041"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-01-30T02:03:41.602711+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/89754765.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-89754765"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "I've pushed a fix for updating the wait timeout line at the end of a shot. It's not tested (commit 35c392b286db), but is pretty simple so any errors will probably be trivial.", "markup": "markdown", "html": "<p>I've pushed a fix for updating the wait timeout line at the end of a shot. It's not tested (commit <a href=\"#!/labscript_suite/labscript_devices/commits/35c392b286db\" rel=\"nofollow\" class=\"ap-connect-link\">35c392b286db</a>), but is pretty simple so any errors will probably be trivial.</p>", "type": "rendered"}, "created_on": "2019-01-30T01:34:24.951033+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-01-30T01:34:24.959885+00:00", "type": "pullrequest_comment", "id": 89754765}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "b2aecf92d620", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/b2aecf92d620.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/b2aecf92d620"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "35c392b286db", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/35c392b286db"}, "html": {"href": "#!/cbillington/labscript_devices/commits/35c392b286db"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-01-30T01:31:49.695941+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/89668888.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-89668888"}}, "parent": {"id": 89623758, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/89623758.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-89623758"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Thanks! Fixed. Was just a silly mistake, but staying  away from the `f\"\"` strings for now to retain Python 2 compatibility.", "markup": "markdown", "html": "<p>Thanks! Fixed. Was just a silly mistake, but staying  away from the <code>f\"\"</code> strings for now to retain Python 2 compatibility.</p>", "type": "rendered"}, "created_on": "2019-01-29T13:49:30.512066+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-01-29T13:49:30.528786+00:00", "type": "pullrequest_comment", "id": 89668888}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "b2aecf92d620", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/b2aecf92d620.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/b2aecf92d620"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4b5438720a8d", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/4b5438720a8d"}, "html": {"href": "#!/cbillington/labscript_devices/commits/4b5438720a8d"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-01-29T13:47:51.889389+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/89623758.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-89623758"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "SUT observed a bug in the message construction of `_check_bounds`\\(see below\\).", "markup": "markdown", "html": "<p>SUT observed a bug in the message construction of <code>_check_bounds</code>(see below).</p>", "type": "rendered"}, "created_on": "2019-01-29T09:34:51.393803+00:00", "user": {"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}, "updated_on": "2019-01-29T09:34:51.402474+00:00", "type": "pullrequest_comment", "id": 89623758}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/89623498.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-89623498"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "This raises`ValueError: unsupported format character '(' (0x28) at index 10`.  How about just\n\n```python\nmsg = f\"{output.description} {output.name} can only have\" + \\\n    f\"values between {vmin:e} and {vmax:e} Volts, the limit imposed by {self.name}\"\n```", "markup": "markdown", "html": "<p>This raises<code>ValueError: unsupported format character '(' (0x28) at index 10</code>.  How about just</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"s2\">&quot;{output.description} {output.name} can only have&quot;</span> <span class=\"o\">+</span> \\\n    <span class=\"n\">f</span><span class=\"s2\">&quot;values between {vmin:e} and {vmax:e} Volts, the limit imposed by {self.name}&quot;</span>\n</pre></div>", "type": "rendered"}, "created_on": "2019-01-29T09:33:36.184165+00:00", "user": {"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}, "inline": {}, "updated_on": "2019-01-29T09:33:36.204714+00:00", "type": "pullrequest_comment", "id": 89623498}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "b2aecf92d620", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/b2aecf92d620.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/b2aecf92d620"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "2b4ad8422d09", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/2b4ad8422d09"}, "html": {"href": "#!/cbillington/labscript_devices/commits/2b4ad8422d09"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-01-28T21:57:21.047419+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/89416902.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-89416902"}}, "parent": {"id": 89379618, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/89379618.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-89379618"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Tested up to 5572db on monashspinor. Can confirm that waits now work.\nTested shots with a WaitMonitor in the connection table, with and without a\nwait instruction. Analog acquisition occurred before the single wait\ninstruction.", "markup": "markdown", "html": "<p>Tested up to 5572db on monashspinor. Can confirm that waits now work.\nTested shots with a WaitMonitor in the connection table, with and without a\nwait instruction. Analog acquisition occurred before the single wait\ninstruction.</p>", "type": "rendered"}, "created_on": "2019-01-26T20:10:07.604459+00:00", "user": {"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}, "updated_on": "2019-01-26T20:10:10.677014+00:00", "type": "pullrequest_comment", "id": 89416902}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/89415952.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-89415952"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Fix pushed for the issue where checking that digital outs are not all zero prevents compiling a connection table.\n\nI've now changed it so that if digital outs are all zero, the DO task is simply run as if they were static outputs. So this works around the issue without the user having to add dummy instructions. The only downside is that static outputs are set up in software time at the start of the shot, so if the front panel had a DO on and it is off during the shot, it will turn off in software time prior to the master clock starting. I don't think this is much of an issue but am happy to be convinced otherwise.\n\nAlso the previous fixes had bugs that I've resolved upon some testing. More testing appreciated, as I have only been able to test with simulated devices so far.\n\nRemaining issues (not necessarily blocking getting this merged, but for the sake of keeping track):\n\n* Modality of inputs/outputs. Can we make the clock input and wait monitor input not be configured as outputs during manual mode, even though their ports are added to the output task? I'm not sure how to proceed with this one, since the ports are treated as a whole in order to avoid using WriteDigitalLines and avoid bugs discussed upthread. But worth looking into.\n\n* Update the front panel at the end of a shot to have the wait monitor timeout trigger be in its unarmed state. This should be relatively simple.\n\n* Include a quirk for the max AO rate of the PXI-6738 depending on exactly which AO channels are in use. Will probably just add an if statement to the relevant code in the main class rather than trying to do anything with the subclass. Despite looking like poor form to add a special case, I think this could be a sustainable way to add model-specific quirks, even though it looks like a good use-case for implementing things in subclasses. I don't think it is actually suitable for going the object-oriented route since there is not necessarily going to be a hierarchy that determines which quirks different devices need. ", "markup": "markdown", "html": "<p>Fix pushed for the issue where checking that digital outs are not all zero prevents compiling a connection table.</p>\n<p>I've now changed it so that if digital outs are all zero, the DO task is simply run as if they were static outputs. So this works around the issue without the user having to add dummy instructions. The only downside is that static outputs are set up in software time at the start of the shot, so if the front panel had a DO on and it is off during the shot, it will turn off in software time prior to the master clock starting. I don't think this is much of an issue but am happy to be convinced otherwise.</p>\n<p>Also the previous fixes had bugs that I've resolved upon some testing. More testing appreciated, as I have only been able to test with simulated devices so far.</p>\n<p>Remaining issues (not necessarily blocking getting this merged, but for the sake of keeping track):</p>\n<ul>\n<li>\n<p>Modality of inputs/outputs. Can we make the clock input and wait monitor input not be configured as outputs during manual mode, even though their ports are added to the output task? I'm not sure how to proceed with this one, since the ports are treated as a whole in order to avoid using WriteDigitalLines and avoid bugs discussed upthread. But worth looking into.</p>\n</li>\n<li>\n<p>Update the front panel at the end of a shot to have the wait monitor timeout trigger be in its unarmed state. This should be relatively simple.</p>\n</li>\n<li>\n<p>Include a quirk for the max AO rate of the PXI-6738 depending on exactly which AO channels are in use. Will probably just add an if statement to the relevant code in the main class rather than trying to do anything with the subclass. Despite looking like poor form to add a special case, I think this could be a sustainable way to add model-specific quirks, even though it looks like a good use-case for implementing things in subclasses. I don't think it is actually suitable for going the object-oriented route since there is not necessarily going to be a hierarchy that determines which quirks different devices need. </p>\n</li>\n</ul>", "type": "rendered"}, "created_on": "2019-01-26T17:53:38.603906+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-01-26T17:54:45.111758+00:00", "type": "pullrequest_comment", "id": 89415952}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "84a903a2a405", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/84a903a2a405.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/84a903a2a405"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "5572dbed8b86", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/5572dbed8b86"}, "html": {"href": "#!/cbillington/labscript_devices/commits/5572dbed8b86"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-01-25T23:40:21.094409+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "84a903a2a405", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/84a903a2a405.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/84a903a2a405"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "6647e5ba2858", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/6647e5ba2858"}, "html": {"href": "#!/cbillington/labscript_devices/commits/6647e5ba2858"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-01-25T22:56:14.185567+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "84a903a2a405", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/84a903a2a405.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/84a903a2a405"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "1764a3ad9300", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/1764a3ad9300"}, "html": {"href": "#!/cbillington/labscript_devices/commits/1764a3ad9300"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-01-25T22:36:57.583122+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "84a903a2a405", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/84a903a2a405.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/84a903a2a405"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "e826c2383842", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/e826c2383842"}, "html": {"href": "#!/cbillington/labscript_devices/commits/e826c2383842"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-01-25T22:10:38.857485+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "84a903a2a405", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/84a903a2a405.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/84a903a2a405"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "ce9764f23e20", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/ce9764f23e20"}, "html": {"href": "#!/cbillington/labscript_devices/commits/ce9764f23e20"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-01-25T22:05:11.663829+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/89379618.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-89379618"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Some fixes have been pushed.\n\nThese are:\n\n* Ensuring arrays passed to DAQmx  are contiguous in memory.\n* Explicitly configuring the output buffer size prior to writing buffered digital data, to avoid multiple writes confusing DAQmx about buffer sizes even though all the write calls had the same npts. \n* Avoiding using `WriteDigitalLines` in favour of `WriteDigitalU32` for manual mode to workaround the issue discussed above where `program_manual` was failing sometimes for ports with <8 lines.\n* Avoiding using `WriteDigitalU8` and `WriteDigitalU16` in favour of `WriteDigitalU32` for buffered mode, to work around a bug where some boards reject `WriteDigitalU8` say, even though the port size is 8. I'm under the impression `WriteDigitalU32` should always work even for ports narrower than 32 bits, that it uses the least-significant bits only up to the port size. But it would be nice if anyone could test that this actually produces output on the correct channel, say, that toggling port1/line0 in manual mode works on a device with a port0 of width < 32. I can test at NIST once the US government re-opens.\n* `NI_DAQmxAcquisitionWorker.transition_to_manual` was returning `False` when there were no acquisitions, which means failure and caused a spurious crash. It now returns True.\n* A fix for the waits issue. It was caused by calls to `transition_to_manual` for multiple workers of a single device being called in *serial*. So `NI_DAQmxAcquisitionWorker.transition_to_manual` was running before `NI_DAQmxWaitMonitorWorker.transition_to_manual`, but the former is waiting on the latter to process wait durations, so it is a deadlock. The order they are called is set by the order the workers were created in the BLACS tab `__init__` method. I can see that that order reversed when I re-wrote the code. It's a bit unappealing for this to be what it depends on, but I've just switched the order back again for now. Perhaps we can make BLACS call them in parallel in the future.", "markup": "markdown", "html": "<p>Some fixes have been pushed.</p>\n<p>These are:</p>\n<ul>\n<li>Ensuring arrays passed to DAQmx  are contiguous in memory.</li>\n<li>Explicitly configuring the output buffer size prior to writing buffered digital data, to avoid multiple writes confusing DAQmx about buffer sizes even though all the write calls had the same npts. </li>\n<li>Avoiding using <code>WriteDigitalLines</code> in favour of <code>WriteDigitalU32</code> for manual mode to workaround the issue discussed above where <code>program_manual</code> was failing sometimes for ports with &lt;8 lines.</li>\n<li>Avoiding using <code>WriteDigitalU8</code> and <code>WriteDigitalU16</code> in favour of <code>WriteDigitalU32</code> for buffered mode, to work around a bug where some boards reject <code>WriteDigitalU8</code> say, even though the port size is 8. I'm under the impression <code>WriteDigitalU32</code> should always work even for ports narrower than 32 bits, that it uses the least-significant bits only up to the port size. But it would be nice if anyone could test that this actually produces output on the correct channel, say, that toggling port1/line0 in manual mode works on a device with a port0 of width &lt; 32. I can test at NIST once the US government re-opens.</li>\n<li><code>NI_DAQmxAcquisitionWorker.transition_to_manual</code> was returning <code>False</code> when there were no acquisitions, which means failure and caused a spurious crash. It now returns True.</li>\n<li>A fix for the waits issue. It was caused by calls to <code>transition_to_manual</code> for multiple workers of a single device being called in <em>serial</em>. So <code>NI_DAQmxAcquisitionWorker.transition_to_manual</code> was running before <code>NI_DAQmxWaitMonitorWorker.transition_to_manual</code>, but the former is waiting on the latter to process wait durations, so it is a deadlock. The order they are called is set by the order the workers were created in the BLACS tab <code>__init__</code> method. I can see that that order reversed when I re-wrote the code. It's a bit unappealing for this to be what it depends on, but I've just switched the order back again for now. Perhaps we can make BLACS call them in parallel in the future.</li>\n</ul>", "type": "rendered"}, "created_on": "2019-01-25T17:37:11.573085+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-01-25T17:58:48.900359+00:00", "type": "pullrequest_comment", "id": 89379618}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "84a903a2a405", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/84a903a2a405.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/84a903a2a405"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "55ee9afbb9e6", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/55ee9afbb9e6"}, "html": {"href": "#!/cbillington/labscript_devices/commits/55ee9afbb9e6"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-01-25T17:56:19.270567+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "84a903a2a405", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/84a903a2a405.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/84a903a2a405"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "ead375317906", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/ead375317906"}, "html": {"href": "#!/cbillington/labscript_devices/commits/ead375317906"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-01-25T17:34:34.967297+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "84a903a2a405", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/84a903a2a405.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/84a903a2a405"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "29a0df595b06", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/29a0df595b06"}, "html": {"href": "#!/cbillington/labscript_devices/commits/29a0df595b06"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-01-25T16:58:25.226139+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}], "next": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/activity_ctx=MLI5Hg.json"}