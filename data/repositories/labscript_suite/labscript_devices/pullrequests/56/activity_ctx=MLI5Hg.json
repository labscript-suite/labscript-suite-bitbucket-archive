{"pagelen": 50, "values": [{"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "84a903a2a405", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/84a903a2a405.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/84a903a2a405"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "e16f8b8ede5a", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/e16f8b8ede5a"}, "html": {"href": "#!/cbillington/labscript_devices/commits/e16f8b8ede5a"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-01-25T02:57:09.398681+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/84918937.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-84918937"}}, "parent": {"id": 83702984, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/83702984.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-83702984"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "\u200c\n\n> Sounds like maybe the acquisition worker isn't getting the zprocess event from the wait monitor worker indicating that waits are processed. If you're going to debug this further, if you turn on \\(via labconfig\\) the progress bar plugin for BLACS, it should indicate whether it's getting stuck on a wait - the progress bar also listens for zprocess events from the wait monitor in order to display waiting status.\n\nThe wait completes, even in the event of timeout. Some observations:\n\n* The `wait_monitor_worker` completes `wait_monitor` \\(reporting \u2018All waits finished\u2019\\).\n* The `wait_monitor_worker` never begins `transition_to_manual`, and thus never runs `wait_durations_analysed.post()`.\n* The `acquisition_worker` subsequently hangs on the `wait_durations_analysed.wait()` call in `extract_measurements` \\(during `transition_to_manual`\\). \n\nOn a related note, calls to `zprocess.Event.wait()` should ultimately time out by specifying a reasonable timeout value.", "markup": "markdown", "html": "<p>\u200c</p>\n<blockquote>\n<p>Sounds like maybe the acquisition worker isn't getting the zprocess event from the wait monitor worker indicating that waits are processed. If you're going to debug this further, if you turn on (via labconfig) the progress bar plugin for BLACS, it should indicate whether it's getting stuck on a wait - the progress bar also listens for zprocess events from the wait monitor in order to display waiting status.</p>\n</blockquote>\n<p>The wait completes, even in the event of timeout. Some observations:</p>\n<ul>\n<li>The <code>wait_monitor_worker</code> completes <code>wait_monitor</code> (reporting \u2018All waits finished\u2019).</li>\n<li>The <code>wait_monitor_worker</code> never begins <code>transition_to_manual</code>, and thus never runs <code>wait_durations_analysed.post()</code>.</li>\n<li>The <code>acquisition_worker</code> subsequently hangs on the <code>wait_durations_analysed.wait()</code> call in <code>extract_measurements</code> (during <code>transition_to_manual</code>). </li>\n</ul>\n<p>On a related note, calls to <code>zprocess.Event.wait()</code> should ultimately time out by specifying a reasonable timeout value.</p>", "type": "rendered"}, "created_on": "2018-12-07T09:51:20.119928+00:00", "user": {"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}, "updated_on": "2018-12-07T09:51:20.132443+00:00", "type": "pullrequest_comment", "id": 84918937}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/83779881.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-83779881"}}, "parent": {"id": 83775084, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/83775084.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-83775084"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Yes, this requires adding some dummy instructions for at least one `DigitalOut` \\(or subclass\\) per parent device, in the connection table Python script. This isn't so tricky, but perhaps the requirement could be circumvented with a compilation flag?", "markup": "markdown", "html": "<p>Yes, this requires adding some dummy instructions for at least one <code>DigitalOut</code> (or subclass) per parent device, in the connection table Python script. This isn't so tricky, but perhaps the requirement could be circumvented with a compilation flag?</p>", "type": "rendered"}, "created_on": "2018-11-28T00:20:53.726974+00:00", "user": {"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}, "updated_on": "2018-11-28T00:32:20.407238+00:00", "type": "pullrequest_comment", "id": 83779881}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/83775084.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-83775084"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Additional issue: the `_check_digitals_do_something` function, that helps sidestep a bug in DAQmx, makes it tricky to compile connection tables, since generally speaking the outputs in connection tables don't do anything. Perhaps this check should be moved to run-time. Not ideal, but maybe the best move.", "markup": "markdown", "html": "<p>Additional issue: the <code>_check_digitals_do_something</code> function, that helps sidestep a bug in DAQmx, makes it tricky to compile connection tables, since generally speaking the outputs in connection tables don't do anything. Perhaps this check should be moved to run-time. Not ideal, but maybe the best move.</p>", "type": "rendered"}, "created_on": "2018-11-27T23:03:58.779276+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-11-27T23:03:58.788351+00:00", "type": "pullrequest_comment", "id": 83775084}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/83766972.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-83766972"}}, "parent": {"id": 83702984, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/83702984.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-83702984"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "> The code working even when a line is a clock input makes sense, as it is only being configured as an output in manual mode. It will be an input in buffered mode. I guess it's bad manners to potentially be putting a voltage across the PulseBlaster's clock output, but this is how it has been set up so far for at least one of our devices \\(I forget which\\) where we had control over the PFIs in manual mode.\n\n1. Even though it\u2019s been this way for some time, any modality of inputs/outputs between buffered and manual mode is undesirable.\n2. There is at least one way in which a digital line / PFI can change state during an experiment shot that is not reflected in the device tab after `transition_to_manual`. The `final_values` returned by `program_buffered_DO` \\([blacs\\_workers.py](#!/labscript_suite/labscript_devices/pull-requests/56/universal-ni-daqmx-support/diff#LNI_DAQmx/blacs_workers.pyT172)\\) do not account for changes to a wait `timeout_monitor` output. This is the source of a gotchya in the @monashbec , whereby the wait timeout trigger is a PFI line and `wait_trigger_type='falling'`. There's a bootstrapping problem whereby the default value of this output is low, leading to the master psuedoclock \\(a PulseBlaster\\) executing its pulse program indefinitely.\n\n    * In the event that a shot with a wait does get executed \\(despite the PulseBlaster not being in a well defined state prior to the shot\\), the wait timeout trigger may go high \\(trigger rearm state written [here](#!/labscript_suite/labscript_devices/pull-requests/56/universal-ni-daqmx-support/diff#LNI_DAQmx/blacs_workers.pyT839) in `start_tasks`\\) but this is not reflected on the device tab after the shot. \\(Thus it is not saved in the blacs front panel and the problem will return upon relaunching blacs.\\)\n    * Changing the output of the timeout trigger to high in manual mode and restarting the PulseBlaster ensures the system is in a well defined \\(static\\) state.\n    \n\nI wonder if we can remedy these issues \\(1: inputs never being outputs and vice versa, and 2: device tab reflects physical state of all outputs after a shot\\) in this PR.", "markup": "markdown", "html": "<blockquote>\n<p>The code working even when a line is a clock input makes sense, as it is only being configured as an output in manual mode. It will be an input in buffered mode. I guess it's bad manners to potentially be putting a voltage across the PulseBlaster's clock output, but this is how it has been set up so far for at least one of our devices (I forget which) where we had control over the PFIs in manual mode.</p>\n</blockquote>\n<ol>\n<li>Even though it\u2019s been this way for some time, any modality of inputs/outputs between buffered and manual mode is undesirable.</li>\n<li>\n<p>There is at least one way in which a digital line / PFI can change state during an experiment shot that is not reflected in the device tab after <code>transition_to_manual</code>. The <code>final_values</code> returned by <code>program_buffered_DO</code> (<a data-is-external-link=\"true\" href=\"#!/labscript_suite/labscript_devices/pull-requests/56/universal-ni-daqmx-support/diff#LNI_DAQmx/blacs_workers.pyT172\" rel=\"nofollow\">blacs_workers.py</a>) do not account for changes to a wait <code>timeout_monitor</code> output. This is the source of a gotchya in the @monashbec , whereby the wait timeout trigger is a PFI line and <code>wait_trigger_type='falling'</code>. There's a bootstrapping problem whereby the default value of this output is low, leading to the master psuedoclock (a PulseBlaster) executing its pulse program indefinitely.</p>\n<ul>\n<li>In the event that a shot with a wait does get executed (despite the PulseBlaster not being in a well defined state prior to the shot), the wait timeout trigger may go high (trigger rearm state written <a data-is-external-link=\"true\" href=\"#!/labscript_suite/labscript_devices/pull-requests/56/universal-ni-daqmx-support/diff#LNI_DAQmx/blacs_workers.pyT839\" rel=\"nofollow\">here</a> in <code>start_tasks</code>) but this is not reflected on the device tab after the shot. (Thus it is not saved in the blacs front panel and the problem will return upon relaunching blacs.)</li>\n<li>Changing the output of the timeout trigger to high in manual mode and restarting the PulseBlaster ensures the system is in a well defined (static) state.</li>\n</ul>\n</li>\n</ol>\n<p>I wonder if we can remedy these issues (1: inputs never being outputs and vice versa, and 2: device tab reflects physical state of all outputs after a shot) in this PR.</p>", "type": "rendered"}, "created_on": "2018-11-27T21:33:14.306488+00:00", "user": {"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}, "updated_on": "2018-11-27T22:10:18.805154+00:00", "type": "pullrequest_comment", "id": 83766972}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/83671312.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-83671312"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Tested this today on Swinburne\u2019s quantum\\_gas\\_microscope and in the monashspinor lab. The following procedure worked beautifully:\n\n`$ python NI_DAQmx/models/get_capabilities.py`\n\n`$ python NI_DAQmx/models/generate_subclasses.py`\n\nThe boards I tested were: PXIe-6361, PXIe-6738, PXIe-6535 \\(quantum\\_gas\\_microscope running Python 2\\) and PCIe-6363, PCIe-6733 \\(monashspinor running Python 2 and 3\\).\n\nI\u2019ve fixed a bug which prevented shots from executing when a board supporting analog input had no acquisitions requested \\(see e9e6bfc and 4003ba4\\).\n\nOutstanding issues include:\n\n* Had to manually decrease `max_AO_sample_rate` on the PXIe-6738 from 1 MS/s to 400 kS/s.\n* When configuring DO channels in `setup_manual_mode_tasks` of [blacs\\_workers.py](#!/labscript_suite/labscript_devices/pull-requests/56/universal-ni-daqmx-support/diff#LNI_DAQmx/blacs_workers.pyT107), including `'/<MAX_name>/port1/line0:7'` in the call to `DO_task.CreateDOChan` caused the subsequent call to `DO_task.WriteDigitalLines` in `program_manual` to fail with:  \n   `InvalidDigDataWriteError: Attempted writing digital data that is not supported.`\n\n    `Data: 99`\n\n\n\n    `Supported Values: 0, 1`\n\n\n\n    `Task Name: _unnamedTask<1>`\n\n\n\n    `Status Code: -200562`\n\n\n\n    Some observations:\n\n\n\n    * `DO_data` is a list of 10 zeros \\(uint8\\), corresponding to the 2 lines on port0 and 8 lines on port1.\n    * This code works on the other cards tested, even when:\n    \n        * some ports are static; and/or\n        * not all ports have the same number of lines, e.g. the PXIe-6535 which has 8\\+8\\+8\\+8\\+6 lines across port 0-4; and/or\n        * used for PFI lines. \\(This confuses me, since some of these are inputs, e.g. `clock_terminal`.\\)\n        \n    * Calling `DO_task.CreateDOChan` with only the first port `'/<MAX_name>/port0/line0:1'` works \\(using a hard-coded conditional\\), even when using the list of 10 zeros for the value of `DO_data`.\n    \n* Waits don't work \\(at least not as configured with the PCIe-6363 on monashspinor\\). The shot fails to complete, with the PCIe-6363 device tab stuck on `transition_to_manual` \\(`acquisiton_worker`\\). I\u2019ll debug this further another day.\n\nThis is a really great bit of development!", "markup": "markdown", "html": "<p>Tested this today on Swinburne\u2019s quantum_gas_microscope and in the monashspinor lab. The following procedure worked beautifully:</p>\n<p><code>$ python NI_DAQmx/models/get_capabilities.py</code></p>\n<p><code>$ python NI_DAQmx/models/generate_subclasses.py</code></p>\n<p>The boards I tested were: PXIe-6361, PXIe-6738, PXIe-6535 (quantum_gas_microscope running Python 2) and PCIe-6363, PCIe-6733 (monashspinor running Python 2 and 3).</p>\n<p>I\u2019ve fixed a bug which prevented shots from executing when a board supporting analog input had no acquisitions requested (see <a href=\"#!/labscript_suite/labscript_devices/commits/e9e6bfc\" rel=\"nofollow\" class=\"ap-connect-link\">e9e6bfc</a> and <a href=\"#!/labscript_suite/labscript_devices/commits/4003ba4\" rel=\"nofollow\" class=\"ap-connect-link\">4003ba4</a>).</p>\n<p>Outstanding issues include:</p>\n<ul>\n<li>Had to manually decrease <code>max_AO_sample_rate</code> on the PXIe-6738 from 1 MS/s to 400 kS/s.</li>\n<li>\n<p>When configuring DO channels in <code>setup_manual_mode_tasks</code> of <a data-is-external-link=\"true\" href=\"#!/labscript_suite/labscript_devices/pull-requests/56/universal-ni-daqmx-support/diff#LNI_DAQmx/blacs_workers.pyT107\" rel=\"nofollow\">blacs_workers.py</a>, including <code>'/&lt;MAX_name&gt;/port1/line0:7'</code> in the call to <code>DO_task.CreateDOChan</code> caused the subsequent call to <code>DO_task.WriteDigitalLines</code> in <code>program_manual</code> to fail with:<br />\n<code>InvalidDigDataWriteError: Attempted writing digital data that is not supported.</code></p>\n<p><code>Data: 99</code></p>\n<p><code>Supported Values: 0, 1</code></p>\n<p><code>Task Name: _unnamedTask&lt;1&gt;</code></p>\n<p><code>Status Code: -200562</code></p>\n<p>Some observations:</p>\n<ul>\n<li><code>DO_data</code> is a list of 10 zeros (uint8), corresponding to the 2 lines on port0 and 8 lines on port1.</li>\n<li>\n<p>This code works on the other cards tested, even when:</p>\n<ul>\n<li>some ports are static; and/or</li>\n<li>not all ports have the same number of lines, e.g. the PXIe-6535 which has 8+8+8+8+6 lines across port 0-4; and/or</li>\n<li>used for PFI lines. (This confuses me, since some of these are inputs, e.g. <code>clock_terminal</code>.)</li>\n</ul>\n</li>\n<li>\n<p>Calling <code>DO_task.CreateDOChan</code> with only the first port <code>'/&lt;MAX_name&gt;/port0/line0:1'</code> works (using a hard-coded conditional), even when using the list of 10 zeros for the value of <code>DO_data</code>.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Waits don't work (at least not as configured with the PCIe-6363 on monashspinor). The shot fails to complete, with the PCIe-6363 device tab stuck on <code>transition_to_manual</code> (<code>acquisiton_worker</code>). I\u2019ll debug this further another day.</p>\n</li>\n</ul>\n<p>This is a really great bit of development!</p>", "type": "rendered"}, "created_on": "2018-11-27T10:46:19.504578+00:00", "user": {"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}, "updated_on": "2018-11-27T20:43:23.894492+00:00", "type": "pullrequest_comment", "id": 83671312}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/83742900.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-83742900"}}, "parent": {"id": 83671312, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/83671312.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-83671312"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "The DO issue with the PXIe-6738 looks like it might be trying to write data from uninitialised memory to the device. The value listed in the error for me is variously 252, 111, 44, and a decent fraction of the time, there is no error (I suppose random memory  is more likely to contain zeros than other values?). So that looks like some random byte from memory. I'd check if the last two binary digits are the values I was actually trying to input to port0, but I can't get the bug to reproduce reliably (presumably because that part of memory is more likely to contain valid values the more the code is run?).\n\nDespite your observation, I'm not sure I buy that the bug depends on whether `'/<MAX_name>/port1/line0:7'` is included, for me it seems probabilistic, presumably based on the values in the uninitialised memory. After restarting BLACS a few times, I'm no longer seeing the error at all, which is a little annoying for trying to debug.", "markup": "markdown", "html": "<p>The DO issue with the PXIe-6738 looks like it might be trying to write data from uninitialised memory to the device. The value listed in the error for me is variously 252, 111, 44, and a decent fraction of the time, there is no error (I suppose random memory  is more likely to contain zeros than other values?). So that looks like some random byte from memory. I'd check if the last two binary digits are the values I was actually trying to input to port0, but I can't get the bug to reproduce reliably (presumably because that part of memory is more likely to contain valid values the more the code is run?).</p>\n<p>Despite your observation, I'm not sure I buy that the bug depends on whether <code>'/&lt;MAX_name&gt;/port1/line0:7'</code> is included, for me it seems probabilistic, presumably based on the values in the uninitialised memory. After restarting BLACS a few times, I'm no longer seeing the error at all, which is a little annoying for trying to debug.</p>", "type": "rendered"}, "created_on": "2018-11-27T17:50:55.759643+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-11-27T17:50:55.771250+00:00", "type": "pullrequest_comment", "id": 83742900}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/83735302.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-83735302"}}, "parent": {"id": 83671312, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/83671312.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-83671312"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "The PXI-6738 documentation says:\n\n\"You can achieve the maximum sample rate if using up to eight channels, where each channel is on a separate bank.\"\n\nIt has 32 AOs, so presumably a 'bank' is a block of four consecutive AOs. We can put that check in, but I'll have a quick think about where a device-specific check like this should go, or if it's something more general whether it can be introspected, similarly to how there are separate `max_AI_multi_chan_rate` and `max_AI_single_chan_rate` capabilities.", "markup": "markdown", "html": "<p>The PXI-6738 documentation says:</p>\n<p>\"You can achieve the maximum sample rate if using up to eight channels, where each channel is on a separate bank.\"</p>\n<p>It has 32 AOs, so presumably a 'bank' is a block of four consecutive AOs. We can put that check in, but I'll have a quick think about where a device-specific check like this should go, or if it's something more general whether it can be introspected, similarly to how there are separate <code>max_AI_multi_chan_rate</code> and <code>max_AI_single_chan_rate</code> capabilities.</p>", "type": "rendered"}, "created_on": "2018-11-27T16:52:44.798747+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-11-27T16:52:44.821557+00:00", "type": "pullrequest_comment", "id": 83735302}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/83702984.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-83702984"}}, "parent": {"id": 83671312, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/83671312.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-83671312"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Excellent, thanks so much for testing and debugging!\n\nAnalog input was the last thing I implemented, so, naturally, I had not tested what happens when there is none of it :p. Thanks for the fix!\n\nAs for the other issues:\n\n* I'll investigate the sample rate of the PCIe-6738. Perhaps it is a bug in DAQmx that it is over-reported, or perhaps we're using it wrong (perhaps confusion between single channel sample rate vs per channel sample rate). If it is just a bug to be fixed with a manual override like this, then I'll do something like make a `capabilties_overrides.json` that will be merged with the introspected capabilities.\n* I should be able to reproduce the digital output issue with a simulated device here at NIST. The most unusual thing about that device that jumps out at me is that the number of lines on port 0 is so small, and is not a multiple of 8. I've seen another device < 8 lines on a port, but it was the last port. So that's something different. It seems the DAQmx API works interchangeably with sending individual ones and zeros as uint8s as we're doing in manual mode, or with packing ones and zeros into integer datatypes as we're doing in buffered mode. But there is no 2-bit integer datatype, uint8 is the minimum. So I wonder if some internal conversion to integer datatypes has the DAQmx API confused. Not sure why it is saying that the data is \"99\".\n* Ah, I had put some effort into waits, so that's a shame that they're not working. Sounds like maybe the acquisition worker isn't getting the zprocess event from the wait monitor worker indicating that waits are processed. If you're going to debug this further, if you turn on (via labconfig) the progress bar plugin for BLACS, it should indicate whether it's getting stuck on a wait - the progress bar also listens for zprocess events from the wait monitor in order to display waiting status. Biggest suspect for waits not working is incorrect detection of whether the card supports 'incomplete sample detection'. I may be able to look into this as there is a PCIe-6363 around here.\n\nEdit: The code working even when a line is a clock input makes sense, as it is only being configured as an output in manual mode. It will be an input in buffered mode. I guess it's bad manners to potentially be putting a voltage across the PulseBlaster's clock output, but this is how it has been set up so far for at least one of our devices (I forget which) where we had control over the PFIs in manual mode.", "markup": "markdown", "html": "<p>Excellent, thanks so much for testing and debugging!</p>\n<p>Analog input was the last thing I implemented, so, naturally, I had not tested what happens when there is none of it :p. Thanks for the fix!</p>\n<p>As for the other issues:</p>\n<ul>\n<li>I'll investigate the sample rate of the PCIe-6738. Perhaps it is a bug in DAQmx that it is over-reported, or perhaps we're using it wrong (perhaps confusion between single channel sample rate vs per channel sample rate). If it is just a bug to be fixed with a manual override like this, then I'll do something like make a <code>capabilties_overrides.json</code> that will be merged with the introspected capabilities.</li>\n<li>I should be able to reproduce the digital output issue with a simulated device here at NIST. The most unusual thing about that device that jumps out at me is that the number of lines on port 0 is so small, and is not a multiple of 8. I've seen another device &lt; 8 lines on a port, but it was the last port. So that's something different. It seems the DAQmx API works interchangeably with sending individual ones and zeros as uint8s as we're doing in manual mode, or with packing ones and zeros into integer datatypes as we're doing in buffered mode. But there is no 2-bit integer datatype, uint8 is the minimum. So I wonder if some internal conversion to integer datatypes has the DAQmx API confused. Not sure why it is saying that the data is \"99\".</li>\n<li>Ah, I had put some effort into waits, so that's a shame that they're not working. Sounds like maybe the acquisition worker isn't getting the zprocess event from the wait monitor worker indicating that waits are processed. If you're going to debug this further, if you turn on (via labconfig) the progress bar plugin for BLACS, it should indicate whether it's getting stuck on a wait - the progress bar also listens for zprocess events from the wait monitor in order to display waiting status. Biggest suspect for waits not working is incorrect detection of whether the card supports 'incomplete sample detection'. I may be able to look into this as there is a PCIe-6363 around here.</li>\n</ul>\n<p>Edit: The code working even when a line is a clock input makes sense, as it is only being configured as an output in manual mode. It will be an input in buffered mode. I guess it's bad manners to potentially be putting a voltage across the PulseBlaster's clock output, but this is how it has been set up so far for at least one of our devices (I forget which) where we had control over the PFIs in manual mode.</p>", "type": "rendered"}, "created_on": "2018-11-27T14:03:05.172003+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-11-27T16:45:44.586389+00:00", "type": "pullrequest_comment", "id": 83702984}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "c5614ae63813", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/c5614ae63813.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/c5614ae63813"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4003ba433385", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/4003ba433385"}, "html": {"href": "#!/cbillington/labscript_devices/commits/4003ba433385"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}, "date": "2018-11-27T06:26:14.268054+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "addb7eef22b4", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/addb7eef22b4.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/addb7eef22b4"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "86152a592eee", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/86152a592eee"}, "html": {"href": "#!/cbillington/labscript_devices/commits/86152a592eee"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}, "date": "2018-11-25T03:08:26.368686+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/83449998.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-83449998"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Typo in \u2018number\u2019.", "markup": "markdown", "html": "<p>Typo in \u2018number\u2019.</p>", "type": "rendered"}, "created_on": "2018-11-25T02:58:12.191342+00:00", "user": {"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}, "inline": {}, "updated_on": "2018-11-25T02:58:12.198590+00:00", "type": "pullrequest_comment", "id": 83449998}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "addb7eef22b4", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/addb7eef22b4.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/addb7eef22b4"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "2159560805b5", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/2159560805b5"}, "html": {"href": "#!/cbillington/labscript_devices/commits/2159560805b5"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2018-11-24T05:15:17.605034+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/83442452.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-83442452"}}, "parent": {"id": 83442425, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/83442425.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-83442425"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Thanks for catching that! In line with the other error checking functions, I'll have it do `if not analogs: return`", "markup": "markdown", "html": "<p>Thanks for catching that! In line with the other error checking functions, I'll have it do <code>if not analogs: return</code></p>", "type": "rendered"}, "created_on": "2018-11-24T05:11:37.255240+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "inline": {}, "updated_on": "2018-11-24T05:11:37.269985+00:00", "type": "pullrequest_comment", "id": 83442452}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/83442425.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-83442425"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "This fails with `TypeError` when there are no analog outputs \\(as `AO_range` is `None`\\). Suggest that call to this method be conditional on `self.analogs`.", "markup": "markdown", "html": "<p>This fails with <code>TypeError</code> when there are no analog outputs (as <code>AO_range</code> is <code>None</code>). Suggest that call to this method be conditional on <code>self.analogs</code>.</p>", "type": "rendered"}, "created_on": "2018-11-24T04:57:53.905793+00:00", "user": {"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}, "inline": {}, "updated_on": "2018-11-24T04:57:53.912334+00:00", "type": "pullrequest_comment", "id": 83442425}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "e826a00ed0fd", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/e826a00ed0fd.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/e826a00ed0fd"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "c93a9cec48cb", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/c93a9cec48cb"}, "html": {"href": "#!/cbillington/labscript_devices/commits/c93a9cec48cb"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2018-11-13T21:13:59.171332+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/82296973.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-82296973"}}, "parent": {"id": 81996660, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/81996660.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-81996660"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "I've fixed this issue - the code was not correctly iterating over possible clock terminals when checking if a port can support buffered output.\n\nIt now correctly detects that the PXIe-6535 supports buffered output on ports 0-3 but not port 4.", "markup": "markdown", "html": "<p>I've fixed this issue - the code was not correctly iterating over possible clock terminals when checking if a port can support buffered output.</p>\n<p>It now correctly detects that the PXIe-6535 supports buffered output on ports 0-3 but not port 4.</p>", "type": "rendered"}, "created_on": "2018-11-13T21:07:38.298750+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-11-13T21:07:38.312105+00:00", "type": "pullrequest_comment", "id": 82296973}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "e826a00ed0fd", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/e826a00ed0fd.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/e826a00ed0fd"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "9ab7d7ee13b1", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/9ab7d7ee13b1"}, "html": {"href": "#!/cbillington/labscript_devices/commits/9ab7d7ee13b1"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2018-11-13T20:34:11.042112+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/81996660.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-81996660"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "The introspection code in this pull request reports that the digital outputs of the PXIe-6535 do not support buffered output. In pull request #9 however, which added code for the PXIe-6535,  it looks like they do support buffered output. @cast7989 could you confirm that they do support buffered output? I do not have a PXIe-6535, so I can only see the behaviour of a simulated device.\n\nI know the NI PXI stuff can be modular. Perhaps the ports only support buffered output if there are additional modules connected? Otherwise, there might be an unwarranted assumption in the introspection code. It looks like this:\n\n```python\ndef port_supports_buffered(device_name, port, clock_terminal='PFI0'):\n    if clock_terminal not in DAQmxGetDevTerminals(device_name):\n        return False\n    npts = 10\n    task = Task()\n    clock_terminal = '/' + device_name + '/' + clock_terminal\n    data = np.zeros(npts, dtype=np.uint8)\n    task.CreateDOChan(\n        device_name + \"/\" + port + '/line0', \"\", c.DAQmx_Val_ChanForAllLines\n    )\n    task.CfgSampClkTiming(\n        clock_terminal, 100, c.DAQmx_Val_Rising, c.DAQmx_Val_FiniteSamps, npts\n    )\n    written = int32()\n    try:\n        task.WriteDigitalLines(\n            npts, False, 10.0, c.DAQmx_Val_GroupByScanNumber, data, byref(written), None\n        )\n    except (\n        PyDAQmx.DAQmxFunctions.BufferedOperationsNotSupportedOnSelectedLinesError,\n        PyDAQmx.DAQmxFunctions.PhysicalChanNotSupportedGivenSampTimingType653xError,\n    ):\n        return False\n    except PyDAQmx.DAQmxFunctions.RouteNotSupportedByHW_RoutingError as e:\n        valid_terms = e.message.split('Suggested Values: ')[1].split('\\n')[0]\n        # Try again with one of the suggested terminals:\n        return port_supports_buffered(device_name, port, valid_terms[0].split(', ')[0])\n    else:\n        return True\n    finally:\n        task.ClearTask()\n\n```\n\nSo the code is attempting to do buffered output on a port and seeing if it gets an error. The only potentially unwarranted assumption that  jumps out to me is the initial check for a terminal called 'PFI0'. If there are devices that can have externally clocked output but do not have a terminal named PFI0, then they would erroneously be considered not to support buffered output.\n\nI will investigate this with the simulated device - perhaps there are different terminal naming patterns on the PXI devices, such that PFI0 is not one of them.", "markup": "markdown", "html": "<p>The introspection code in this pull request reports that the digital outputs of the PXIe-6535 do not support buffered output. In <a href=\"#!/labscript_suite/labscript_devices/pull-requests/9/update-of-niboardpy-for-dio-cards-with\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #9</a> however, which added code for the PXIe-6535,  it looks like they do support buffered output. @cast7989 could you confirm that they do support buffered output? I do not have a PXIe-6535, so I can only see the behaviour of a simulated device.</p>\n<p>I know the NI PXI stuff can be modular. Perhaps the ports only support buffered output if there are additional modules connected? Otherwise, there might be an unwarranted assumption in the introspection code. It looks like this:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">port_supports_buffered</span><span class=\"p\">(</span><span class=\"n\">device_name</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"p\">,</span> <span class=\"n\">clock_terminal</span><span class=\"o\">=</span><span class=\"s1\">&#39;PFI0&#39;</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">clock_terminal</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">DAQmxGetDevTerminals</span><span class=\"p\">(</span><span class=\"n\">device_name</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">False</span>\n    <span class=\"n\">npts</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n    <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"n\">Task</span><span class=\"p\">()</span>\n    <span class=\"n\">clock_terminal</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;/&#39;</span> <span class=\"o\">+</span> <span class=\"n\">device_name</span> <span class=\"o\">+</span> <span class=\"s1\">&#39;/&#39;</span> <span class=\"o\">+</span> <span class=\"n\">clock_terminal</span>\n    <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">(</span><span class=\"n\">npts</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">uint8</span><span class=\"p\">)</span>\n    <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">CreateDOChan</span><span class=\"p\">(</span>\n        <span class=\"n\">device_name</span> <span class=\"o\">+</span> <span class=\"s2\">&quot;/&quot;</span> <span class=\"o\">+</span> <span class=\"n\">port</span> <span class=\"o\">+</span> <span class=\"s1\">&#39;/line0&#39;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;&quot;</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">DAQmx_Val_ChanForAllLines</span>\n    <span class=\"p\">)</span>\n    <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">CfgSampClkTiming</span><span class=\"p\">(</span>\n        <span class=\"n\">clock_terminal</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">DAQmx_Val_Rising</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">DAQmx_Val_FiniteSamps</span><span class=\"p\">,</span> <span class=\"n\">npts</span>\n    <span class=\"p\">)</span>\n    <span class=\"n\">written</span> <span class=\"o\">=</span> <span class=\"n\">int32</span><span class=\"p\">()</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">WriteDigitalLines</span><span class=\"p\">(</span>\n            <span class=\"n\">npts</span><span class=\"p\">,</span> <span class=\"bp\">False</span><span class=\"p\">,</span> <span class=\"mf\">10.0</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">DAQmx_Val_GroupByScanNumber</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">byref</span><span class=\"p\">(</span><span class=\"n\">written</span><span class=\"p\">),</span> <span class=\"bp\">None</span>\n        <span class=\"p\">)</span>\n    <span class=\"k\">except</span> <span class=\"p\">(</span>\n        <span class=\"n\">PyDAQmx</span><span class=\"o\">.</span><span class=\"n\">DAQmxFunctions</span><span class=\"o\">.</span><span class=\"n\">BufferedOperationsNotSupportedOnSelectedLinesError</span><span class=\"p\">,</span>\n        <span class=\"n\">PyDAQmx</span><span class=\"o\">.</span><span class=\"n\">DAQmxFunctions</span><span class=\"o\">.</span><span class=\"n\">PhysicalChanNotSupportedGivenSampTimingType653xError</span><span class=\"p\">,</span>\n    <span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">False</span>\n    <span class=\"k\">except</span> <span class=\"n\">PyDAQmx</span><span class=\"o\">.</span><span class=\"n\">DAQmxFunctions</span><span class=\"o\">.</span><span class=\"n\">RouteNotSupportedByHW_RoutingError</span> <span class=\"k\">as</span> <span class=\"n\">e</span><span class=\"p\">:</span>\n        <span class=\"n\">valid_terms</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">message</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"s1\">&#39;Suggested Values: &#39;</span><span class=\"p\">)[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"s1\">&#39;</span><span class=\"se\">\\n</span><span class=\"s1\">&#39;</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n        <span class=\"c1\"># Try again with one of the suggested terminals:</span>\n        <span class=\"k\">return</span> <span class=\"n\">port_supports_buffered</span><span class=\"p\">(</span><span class=\"n\">device_name</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"p\">,</span> <span class=\"n\">valid_terms</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"s1\">&#39;, &#39;</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"bp\">True</span>\n    <span class=\"k\">finally</span><span class=\"p\">:</span>\n        <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">ClearTask</span><span class=\"p\">()</span>\n</pre></div>\n\n\n<p>So the code is attempting to do buffered output on a port and seeing if it gets an error. The only potentially unwarranted assumption that  jumps out to me is the initial check for a terminal called 'PFI0'. If there are devices that can have externally clocked output but do not have a terminal named PFI0, then they would erroneously be considered not to support buffered output.</p>\n<p>I will investigate this with the simulated device - perhaps there are different terminal naming patterns on the PXI devices, such that PFI0 is not one of them.</p>", "type": "rendered"}, "created_on": "2018-11-10T18:17:10.877324+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-11-10T18:21:53.724465+00:00", "type": "pullrequest_comment", "id": 81996660}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/81996483.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-81996483"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Note to self: version tag 2.3.0 required after merging.", "markup": "markdown", "html": "<p>Note to self: version tag 2.3.0 required after merging.</p>", "type": "rendered"}, "created_on": "2018-11-10T17:54:16.936868+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-11-10T17:54:16.943455+00:00", "type": "pullrequest_comment", "id": 81996483}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.StopTask(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 2 and 3 compatible. Adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device has some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports during a shot. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the runviewer code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (eg `from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "e826a00ed0fd", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/e826a00ed0fd.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/e826a00ed0fd"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4c3e2621ed7b", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/4c3e2621ed7b"}, "html": {"href": "#!/cbillington/labscript_devices/commits/4c3e2621ed7b"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2018-11-10T17:52:41.720599+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range'=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.Stop(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output on, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 3 compatible. In fact adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device ha some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (`from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "e826a00ed0fd", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/e826a00ed0fd.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/e826a00ed0fd"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4c3e2621ed7b", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/4c3e2621ed7b"}, "html": {"href": "#!/cbillington/labscript_devices/commits/4c3e2621ed7b"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2018-11-10T17:34:29.985796+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range'=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.Stop(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output on, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 3 compatible. In fact adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device ha some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (`from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "e826a00ed0fd", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/e826a00ed0fd.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/e826a00ed0fd"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "2d1261c03d38", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/2d1261c03d38"}, "html": {"href": "#!/cbillington/labscript_devices/commits/2d1261c03d38"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2018-11-10T17:30:45.396234+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}, {"update": {"description": "This PR adds a subfolder containing a general-purpose labscript device, BLACS tab, and BLACS workers for NI DAQmx devices.\r\n\r\nThe capabilities of the device can be added as instantiation arguments:\r\n\r\n```python\r\n    def __init__(\r\n        self,\r\n        name,\r\n        parent_device=None,\r\n        clock_terminal=None,\r\n        MAX_name=None,\r\n        static_AO=None,\r\n        static_DO=None,\r\n        clock_mirror_terminal=None,\r\n        acquisition_rate=None,\r\n        AI_range=None,\r\n        AI_start_delay=0,\r\n        AO_range=None,\r\n        max_AI_multi_chan_rate=None,\r\n        max_AI_single_chan_rate=None,\r\n        max_AO_sample_rate=None,\r\n        max_DO_sample_rate=None,\r\n        min_semiperiod_measurement=None,\r\n        num_AI=0,\r\n        num_AO=0,\r\n        num_CI=0,\r\n        ports=None,\r\n        supports_buffered_AO=False,\r\n        supports_buffered_DO=False,\r\n        supports_semiperiod_measurement=False,\r\n        **kwargs\r\n    ):\r\n```\r\n\r\nAlternately (and preferably), subclasses can be made that have the capabilities already set. I have made subclasses for all the models that we know about already.\r\n\r\nAll the subclasses do is set default values for the capabilities arguments. For example, here is one of them in full:\r\n\r\n```python\r\nCAPABILITIES = {\r\n    'AI_range': [-10.0, 10.0],\r\n    'AI_start_delay': 7e-08,\r\n    'AO_range': [-10.0, 10.0],\r\n    'max_AI_multi_chan_rate': 1000000.0,\r\n    'max_AI_single_chan_rate': 2000000.0,\r\n    'max_AO_sample_rate': 2857142.8571428573,\r\n    'max_DO_sample_rate': 10000000.0,\r\n    'min_semiperiod_measurement': 1e-07,\r\n    'num_AI': 32,\r\n    'num_AO': 4,\r\n    'num_CI': 4,\r\n    'ports': {\r\n        'port0': {'num_lines': 32, 'supports_buffered': True},\r\n        'port1': {'num_lines': 8, 'supports_buffered': False},\r\n        'port2': {'num_lines': 8, 'supports_buffered': False},\r\n    },\r\n    'supports_buffered_AO': True,\r\n    'supports_buffered_DO': True,\r\n    'supports_semiperiod_measurement': True,\r\n}\r\n\r\n\r\nclass NI_PCIe_6363(NI_DAQmx):\r\n    description = 'NI-PCIe-6363'\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        # Any provided kwargs take precedent over capabilities\r\n        combined_kwargs = CAPABILITIES.copy()\r\n        combined_kwargs.update(kwargs)\r\n        NI_DAQmx.__init__(self, *args, **combined_kwargs)\r\n```\r\n\r\nFuthermore, these subclasses can be automatically generated for new devices. The file `labscript_devices/NI_DAQmx/models/get_capabilities.py` will introspect the capabilities of all devices attached to the current computer (or configured as 'simulated devices' in NI MAX, meaning this can be done without the actual hardware on hand), and update a JSON file, `labscript_devices/NI_DAQmx/models/capabiltiies.json`. The classes can then be generated from this JSON file and a template, by running `labscript_devices/NI_DAQmx/models/generate_subclasses.py`. There is a `README` file in the folder explaining this process.\r\n\r\nAlthough there are subclasses for the labscript device, all models use the same BLACS tab, BLACS workers, and runviewer parser classes. The capabilities are saved as connection table properties, so the general-purpose classes can read them from there and behave accordingly.\r\n\r\nThe capabilities of any of the subclasses can be overridden by passing in different values as keyword arguments. For example, to configure a smaller range of analog input voltage, you could pass in a keyword argument `AI_range'=[-1, 1]` even if the device supports a larger analog input range.\r\n\r\nThere are a number of bugfixes and features in this code based on what has been learned in the Spielman fork and elsewhere. For example, there was a race condition when ending shots - the DAQmx driver sometimes would not know that the device was finished outputting all samples before BLACS came and said task.Stop(), this would raise an error. This was presumably just because USB communication from the device back to the computer can take a few milliseconds. Shots now end with a call to `Task.WaitUntilTaskDone()` with a one second timeout, which fixes this race condition without wasting any more time than necessary.\r\n\r\nThere was also a bug in DAQmx where the driver would raise obscure errors if digital outputs are all zero for the whole shot. There is now error checking for this, telling you \"please make a digital output do something\". There is more error checking in general in the labscript device, and the code makes fewer assumptions about whether any children have been added, etc.\r\n\r\nThere is an additional feature here that I had added in the Spielman fork but mainline hasn't seen yet: 'clock_mirror_terminal'. This is a channel on which the clock input will also be output on, which allows daisy chaining a number of DAQmx devices together when they share a clocking signal.\r\n\r\nSome DAQmx devices do not support clocked output, and so can only have static output. This labscript device supports this, such that analog and digital outputs can be StaticAnalogOut and StaticDigitalOut objects. In this case, if a device supports analog input still, it can still have a parent pseudoclock, but it will only be used to trigger the start of acquisition.\r\n\r\nI have not integrated @PhyNerd's manual mode analog input with this PR yet, but the BLACS worker does acquire during manual mode, transitioning between a manual mode task and a buffered mode task when shots stop and start. It presently just throws the manual mode data down the drain, but there is a logical spot to slot in a zmq send call to send the data to the broker instead once manual mode analog input is merged into mainline and I or someone else has time.\r\n\r\nThe code is Python 3 compatible. In fact adding support for a new device requires a Python-3-only library (though it will still work without that library, it will just not format the generated code well).\r\n\r\n\r\nLimitations:\r\n\r\nWhere a device ha some digital ports supporting buffered output and some not, I have not bothered to implement support for using all of them simultaneously. If static_DO is True, then you can use all digital outputs as StaticDigitalOut. If static_DO is False, you can use the ports that support buffered output, but simply cannot use the other ports. We can improve this in the future but I anticipate not many people caring about this (use of the non-buffered outputs during a shot has been unavailable in the existing DAQmx classes for a long time and nobody has complained).\r\n\r\nThese classes are not backward compatible with shots compiled with previous DAQmx classes. However, they should be compatible with existing experiment scripts. BLACS will reject shots with mismatching connection tables, and so will not run old shots. The error message won't be particularly helpful though since it will be about all the connection table properties not matching, and won't specifically emphasise the version. After updating, if BLACS starts up and the BLACS tab finds that the connection table was compiled with an older, incompatible version of an NI DAQmx class, it raises an error saying either to downgrade labscript_devices, or to recompile the connection table. The runviewer parser also raises a similar error if it is given a shot file compiled with the previous classes, but this is not super useful because as it stands, runviewer just suppresses these errors and writes a simple \"could not load device\" line to the terminal. But this is a problem with runviewer, it should be changed to expose the error (there is a TODO in the code to this effect).\r\n\r\nI have removed the previous device classes from labscript_devices, and replaced them with an import alias that imports the new classes from their new locations within this submodule (`from labscript_devices.NI_DAQmx.models import NI_PCIe_6363`) and prints a deprecation warning telling the user to use the new import location.\r\n\r\nAnother limitation is that there is no way to introspect which ports and lines correspond to which 'PFI' on DAQmx devices. There is no systematic pattern and no way I can think of to get at this information programmatically. Therefore the BLACS tab in this PR simply labels all digital outs as 'port<N>/line<M>' and does not label them with their alternate 'PFI' names. This is a change, and may take a little getting used to. We could hard-code the mapping in the subclasses, but as all information about devices is currently introspected, such that no data needs to be manually input by the user to add support for a device, it is unappealing to me to add a manual step such as this, which also adds complexity to the code as the code would then have to handle that some digital outs would have multiple names. Using ports and lines only is simpler.\r\n\r\nAll in all the code in this PR has been quite carefully considered, and while I'm sure there will be bugs to iron out, I've tested it with a number of devices and ensured analog and digital output work, analog input works, and that wait monitors work too. This last one was a pain in the neck because of [different behaviour of different devices when it comes to semiperiod measurements](https://forums.ni.com/t5/Multifunction-DAQ/How-can-I-tell-programmatically-whether-a-given-DAQmx-device-has/m-p/3849997).\r\n\r\nAs always, testing is appreciated.", "title": "Universal NI DAQmx support", "destination": {"commit": {"hash": "e826a00ed0fd", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/e826a00ed0fd.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/e826a00ed0fd"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "2d1261c03d38", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/2d1261c03d38"}, "html": {"href": "#!/cbillington/labscript_devices/commits/2d1261c03d38"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "NI_DAQmx"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2018-11-10T17:30:45.335533+00:00"}, "pull_request": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}}]}