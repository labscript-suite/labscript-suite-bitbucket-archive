{"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56/comments/89379618.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56/_/diff#comment-89379618"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 56, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/56.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/56"}}, "title": "Universal NI DAQmx support"}, "content": {"raw": "Some fixes have been pushed.\n\nThese are:\n\n* Ensuring arrays passed to DAQmx  are contiguous in memory.\n* Explicitly configuring the output buffer size prior to writing buffered digital data, to avoid multiple writes confusing DAQmx about buffer sizes even though all the write calls had the same npts. \n* Avoiding using `WriteDigitalLines` in favour of `WriteDigitalU32` for manual mode to workaround the issue discussed above where `program_manual` was failing sometimes for ports with <8 lines.\n* Avoiding using `WriteDigitalU8` and `WriteDigitalU16` in favour of `WriteDigitalU32` for buffered mode, to work around a bug where some boards reject `WriteDigitalU8` say, even though the port size is 8. I'm under the impression `WriteDigitalU32` should always work even for ports narrower than 32 bits, that it uses the least-significant bits only up to the port size. But it would be nice if anyone could test that this actually produces output on the correct channel, say, that toggling port1/line0 in manual mode works on a device with a port0 of width < 32. I can test at NIST once the US government re-opens.\n* `NI_DAQmxAcquisitionWorker.transition_to_manual` was returning `False` when there were no acquisitions, which means failure and caused a spurious crash. It now returns True.\n* A fix for the waits issue. It was caused by calls to `transition_to_manual` for multiple workers of a single device being called in *serial*. So `NI_DAQmxAcquisitionWorker.transition_to_manual` was running before `NI_DAQmxWaitMonitorWorker.transition_to_manual`, but the former is waiting on the latter to process wait durations, so it is a deadlock. The order they are called is set by the order the workers were created in the BLACS tab `__init__` method. I can see that that order reversed when I re-wrote the code. It's a bit unappealing for this to be what it depends on, but I've just switched the order back again for now. Perhaps we can make BLACS call them in parallel in the future.", "markup": "markdown", "html": "<p>Some fixes have been pushed.</p>\n<p>These are:</p>\n<ul>\n<li>Ensuring arrays passed to DAQmx  are contiguous in memory.</li>\n<li>Explicitly configuring the output buffer size prior to writing buffered digital data, to avoid multiple writes confusing DAQmx about buffer sizes even though all the write calls had the same npts. </li>\n<li>Avoiding using <code>WriteDigitalLines</code> in favour of <code>WriteDigitalU32</code> for manual mode to workaround the issue discussed above where <code>program_manual</code> was failing sometimes for ports with &lt;8 lines.</li>\n<li>Avoiding using <code>WriteDigitalU8</code> and <code>WriteDigitalU16</code> in favour of <code>WriteDigitalU32</code> for buffered mode, to work around a bug where some boards reject <code>WriteDigitalU8</code> say, even though the port size is 8. I'm under the impression <code>WriteDigitalU32</code> should always work even for ports narrower than 32 bits, that it uses the least-significant bits only up to the port size. But it would be nice if anyone could test that this actually produces output on the correct channel, say, that toggling port1/line0 in manual mode works on a device with a port0 of width &lt; 32. I can test at NIST once the US government re-opens.</li>\n<li><code>NI_DAQmxAcquisitionWorker.transition_to_manual</code> was returning <code>False</code> when there were no acquisitions, which means failure and caused a spurious crash. It now returns True.</li>\n<li>A fix for the waits issue. It was caused by calls to <code>transition_to_manual</code> for multiple workers of a single device being called in <em>serial</em>. So <code>NI_DAQmxAcquisitionWorker.transition_to_manual</code> was running before <code>NI_DAQmxWaitMonitorWorker.transition_to_manual</code>, but the former is waiting on the latter to process wait durations, so it is a deadlock. The order they are called is set by the order the workers were created in the BLACS tab <code>__init__</code> method. I can see that that order reversed when I re-wrote the code. It's a bit unappealing for this to be what it depends on, but I've just switched the order back again for now. Perhaps we can make BLACS call them in parallel in the future.</li>\n</ul>", "type": "rendered"}, "created_on": "2019-01-25T17:37:11.573085+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-01-25T17:58:48.900359+00:00", "type": "pullrequest_comment", "id": 89379618}