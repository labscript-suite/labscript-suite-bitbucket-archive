{"rendered": {"description": {"raw": "Device class for Tektronix oscilloscopes using [pyvisa](https://pyvisa.readthedocs.io).\r\n\r\nThis derives from bits and pieces of:\r\n\r\n* pytronix, a module I wrote years ago for grabbing data and screenshots from Tek scopes over ethernet and saving the waveforms to h5.\r\n* @{557058:940c20da-c736-4e3a-a30f-58224616fb0a} 's [telepythic](https://bitbucket.org/martijnj/telepythic), a module for communicating with instruments over VISA or telnet or other protocols \\(much functionality covered by pyvisa and not Python3 compatible\\).\r\n* Dimitrios Trypogeorgos\u2019s really clean and simple way to integrate Tek scopes into labscript; using a generic BLACS tab which communicates with a \u2018server\u2019 running on any host, sending it software triggers to transiton\\_to\\_manual and transition\\_to\\_static. This was based off of CameraServer.py. Nice, but:\r\n\r\n    * The actual scope control is not done by the blacs tab, but the server code which has to be launched separately from blacs, and re-launched separately if it crashes.\r\n    * There\u2019s no useful information in the blacs tab\u2019s terminal output.\r\n    \r\n\r\nThe aim here is to strip down a useful subset of the above three implementations and make a labscript device which:\r\n\r\n1. Works as device tab in blacs with no need to launch a server process independently;\r\n2. Works with multiple product lines of Tektronix scopes, which have different formatting of the waveform preamble;\r\n3. Does binary transfer of waveforms;\r\n4. Is Python 2 and 3 compatible;\r\n5. TODO: Configure the scope before each shot, including the ability to pass per-shot options like which channels to capture, other acquisition options, and the communications timeout.\r\n6. Writes the waveforms to a standard location in the h5 file at the end of the shot.\r\n7. Save them as a single compound dataset with named columns, e.g \u2018t\u2019, \u2018CH1\u2019, etc. with attributes of this data set the waveform preamble.\r\n\r\nTek scopes use one of two different commands to retrieve the waveform preamble, either `WFMO` or `WFMP`. The response format of the preamble is also dependent on the scope, so instead we'll just get the preamble attributes one at a time, or with a concatenated command, e.g. `WFMP:XUNIT?;:WFMP:YUNIT?;:` etc..., which takes a little longer, but beats having to write a per-scope dictionary of the preamble format.\r\n\r\nI have only tested this on a TDS2002B over USB, but this should translate to communicating with other scopes over ethernet, so long as they are VISA devices.\r\n\r\nI'm using the waveform preamble values to convert the 8- or 16-bit integers returned from the scope into floating point voltages. This is fine for for the 2500 points returned by TDS2000 series scopes, but might be unwieldy for the deep memory devices, and warrant saving waveforms as integer types, with the dataset attributes available to convert to floats when reading from the shot file.", "markup": "markdown", "html": "<p>Device class for Tektronix oscilloscopes using <a data-is-external-link=\"true\" href=\"https://pyvisa.readthedocs.io\" rel=\"nofollow\">pyvisa</a>.</p>\n<p>This derives from bits and pieces of:</p>\n<ul>\n<li>pytronix, a module I wrote years ago for grabbing data and screenshots from Tek scopes over ethernet and saving the waveforms to h5.</li>\n<li><span class=\"ap-mention\" data-atlassian-id=\"557058:940c20da-c736-4e3a-a30f-58224616fb0a\">@Martijn Jasperse</span> 's <a data-is-external-link=\"true\" href=\"https://bitbucket.org/martijnj/telepythic\" rel=\"nofollow\">telepythic</a>, a module for communicating with instruments over VISA or telnet or other protocols (much functionality covered by pyvisa and not Python3 compatible).</li>\n<li>\n<p>Dimitrios Trypogeorgos\u2019s really clean and simple way to integrate Tek scopes into labscript; using a generic BLACS tab which communicates with a \u2018server\u2019 running on any host, sending it software triggers to transiton_to_manual and transition_to_static. This was based off of CameraServer.py. Nice, but:</p>\n<ul>\n<li>The actual scope control is not done by the blacs tab, but the server code which has to be launched separately from blacs, and re-launched separately if it crashes.</li>\n<li>There\u2019s no useful information in the blacs tab\u2019s terminal output.</li>\n</ul>\n</li>\n</ul>\n<p>The aim here is to strip down a useful subset of the above three implementations and make a labscript device which:</p>\n<ol>\n<li>Works as device tab in blacs with no need to launch a server process independently;</li>\n<li>Works with multiple product lines of Tektronix scopes, which have different formatting of the waveform preamble;</li>\n<li>Does binary transfer of waveforms;</li>\n<li>Is Python 2 and 3 compatible;</li>\n<li>TODO: Configure the scope before each shot, including the ability to pass per-shot options like which channels to capture, other acquisition options, and the communications timeout.</li>\n<li>Writes the waveforms to a standard location in the h5 file at the end of the shot.</li>\n<li>Save them as a single compound dataset with named columns, e.g \u2018t\u2019, \u2018CH1\u2019, etc. with attributes of this data set the waveform preamble.</li>\n</ol>\n<p>Tek scopes use one of two different commands to retrieve the waveform preamble, either <code>WFMO</code> or <code>WFMP</code>. The response format of the preamble is also dependent on the scope, so instead we'll just get the preamble attributes one at a time, or with a concatenated command, e.g. <code>WFMP:XUNIT?;:WFMP:YUNIT?;:</code> etc..., which takes a little longer, but beats having to write a per-scope dictionary of the preamble format.</p>\n<p>I have only tested this on a TDS2002B over USB, but this should translate to communicating with other scopes over ethernet, so long as they are VISA devices.</p>\n<p>I'm using the waveform preamble values to convert the 8- or 16-bit integers returned from the scope into floating point voltages. This is fine for for the 2500 points returned by TDS2000 series scopes, but might be unwieldy for the deep memory devices, and warrant saving waveforms as integer types, with the dataset attributes available to convert to floats when reading from the shot file.</p>", "type": "rendered"}, "title": {"raw": "Tektronix oscilloscope", "markup": "markdown", "html": "<p>Tektronix oscilloscope</p>", "type": "rendered"}}, "type": "pullrequest", "description": "Device class for Tektronix oscilloscopes using [pyvisa](https://pyvisa.readthedocs.io).\r\n\r\nThis derives from bits and pieces of:\r\n\r\n* pytronix, a module I wrote years ago for grabbing data and screenshots from Tek scopes over ethernet and saving the waveforms to h5.\r\n* @{557058:940c20da-c736-4e3a-a30f-58224616fb0a} 's [telepythic](https://bitbucket.org/martijnj/telepythic), a module for communicating with instruments over VISA or telnet or other protocols \\(much functionality covered by pyvisa and not Python3 compatible\\).\r\n* Dimitrios Trypogeorgos\u2019s really clean and simple way to integrate Tek scopes into labscript; using a generic BLACS tab which communicates with a \u2018server\u2019 running on any host, sending it software triggers to transiton\\_to\\_manual and transition\\_to\\_static. This was based off of CameraServer.py. Nice, but:\r\n\r\n    * The actual scope control is not done by the blacs tab, but the server code which has to be launched separately from blacs, and re-launched separately if it crashes.\r\n    * There\u2019s no useful information in the blacs tab\u2019s terminal output.\r\n    \r\n\r\nThe aim here is to strip down a useful subset of the above three implementations and make a labscript device which:\r\n\r\n1. Works as device tab in blacs with no need to launch a server process independently;\r\n2. Works with multiple product lines of Tektronix scopes, which have different formatting of the waveform preamble;\r\n3. Does binary transfer of waveforms;\r\n4. Is Python 2 and 3 compatible;\r\n5. TODO: Configure the scope before each shot, including the ability to pass per-shot options like which channels to capture, other acquisition options, and the communications timeout.\r\n6. Writes the waveforms to a standard location in the h5 file at the end of the shot.\r\n7. Save them as a single compound dataset with named columns, e.g \u2018t\u2019, \u2018CH1\u2019, etc. with attributes of this data set the waveform preamble.\r\n\r\nTek scopes use one of two different commands to retrieve the waveform preamble, either `WFMO` or `WFMP`. The response format of the preamble is also dependent on the scope, so instead we'll just get the preamble attributes one at a time, or with a concatenated command, e.g. `WFMP:XUNIT?;:WFMP:YUNIT?;:` etc..., which takes a little longer, but beats having to write a per-scope dictionary of the preamble format.\r\n\r\nI have only tested this on a TDS2002B over USB, but this should translate to communicating with other scopes over ethernet, so long as they are VISA devices.\r\n\r\nI'm using the waveform preamble values to convert the 8- or 16-bit integers returned from the scope into floating point voltages. This is fine for for the 2500 points returned by TDS2000 series scopes, but might be unwieldy for the deep memory devices, and warrant saving waveforms as integer types, with the dataset attributes available to convert to floats when reading from the shot file.", "links": {"decline": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/pullrequests/61/decline"}, "diffstat": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/diffstat/labscript_suite/labscript_devices:e622c32d8b8c%0Decdd8ed52612?from_pullrequest_id=61"}, "commits": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/61/commits.json"}, "self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/61.json"}, "comments": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/61/comments_page=1.json"}, "merge": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/pullrequests/61/merge"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/61"}, "activity": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/61/activity.json"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/diff/labscript_suite/labscript_devices:e622c32d8b8c%0Decdd8ed52612?from_pullrequest_id=61"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/pullrequests/61/approve"}, "statuses": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/61/statuses_page=1.json"}}, "title": "Tektronix oscilloscope", "close_source_branch": true, "reviewers": [{"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}], "id": 61, "destination": {"commit": {"hash": "ecdd8ed52612", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/ecdd8ed52612.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/ecdd8ed52612"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "created_on": "2019-03-09T05:29:11.612424+00:00", "summary": {"raw": "Device class for Tektronix oscilloscopes using [pyvisa](https://pyvisa.readthedocs.io).\r\n\r\nThis derives from bits and pieces of:\r\n\r\n* pytronix, a module I wrote years ago for grabbing data and screenshots from Tek scopes over ethernet and saving the waveforms to h5.\r\n* @{557058:940c20da-c736-4e3a-a30f-58224616fb0a} 's [telepythic](https://bitbucket.org/martijnj/telepythic), a module for communicating with instruments over VISA or telnet or other protocols \\(much functionality covered by pyvisa and not Python3 compatible\\).\r\n* Dimitrios Trypogeorgos\u2019s really clean and simple way to integrate Tek scopes into labscript; using a generic BLACS tab which communicates with a \u2018server\u2019 running on any host, sending it software triggers to transiton\\_to\\_manual and transition\\_to\\_static. This was based off of CameraServer.py. Nice, but:\r\n\r\n    * The actual scope control is not done by the blacs tab, but the server code which has to be launched separately from blacs, and re-launched separately if it crashes.\r\n    * There\u2019s no useful information in the blacs tab\u2019s terminal output.\r\n    \r\n\r\nThe aim here is to strip down a useful subset of the above three implementations and make a labscript device which:\r\n\r\n1. Works as device tab in blacs with no need to launch a server process independently;\r\n2. Works with multiple product lines of Tektronix scopes, which have different formatting of the waveform preamble;\r\n3. Does binary transfer of waveforms;\r\n4. Is Python 2 and 3 compatible;\r\n5. TODO: Configure the scope before each shot, including the ability to pass per-shot options like which channels to capture, other acquisition options, and the communications timeout.\r\n6. Writes the waveforms to a standard location in the h5 file at the end of the shot.\r\n7. Save them as a single compound dataset with named columns, e.g \u2018t\u2019, \u2018CH1\u2019, etc. with attributes of this data set the waveform preamble.\r\n\r\nTek scopes use one of two different commands to retrieve the waveform preamble, either `WFMO` or `WFMP`. The response format of the preamble is also dependent on the scope, so instead we'll just get the preamble attributes one at a time, or with a concatenated command, e.g. `WFMP:XUNIT?;:WFMP:YUNIT?;:` etc..., which takes a little longer, but beats having to write a per-scope dictionary of the preamble format.\r\n\r\nI have only tested this on a TDS2002B over USB, but this should translate to communicating with other scopes over ethernet, so long as they are VISA devices.\r\n\r\nI'm using the waveform preamble values to convert the 8- or 16-bit integers returned from the scope into floating point voltages. This is fine for for the 2500 points returned by TDS2000 series scopes, but might be unwieldy for the deep memory devices, and warrant saving waveforms as integer types, with the dataset attributes available to convert to floats when reading from the shot file.", "markup": "markdown", "html": "<p>Device class for Tektronix oscilloscopes using <a data-is-external-link=\"true\" href=\"https://pyvisa.readthedocs.io\" rel=\"nofollow\">pyvisa</a>.</p>\n<p>This derives from bits and pieces of:</p>\n<ul>\n<li>pytronix, a module I wrote years ago for grabbing data and screenshots from Tek scopes over ethernet and saving the waveforms to h5.</li>\n<li><span class=\"ap-mention\" data-atlassian-id=\"557058:940c20da-c736-4e3a-a30f-58224616fb0a\">@Martijn Jasperse</span> 's <a data-is-external-link=\"true\" href=\"https://bitbucket.org/martijnj/telepythic\" rel=\"nofollow\">telepythic</a>, a module for communicating with instruments over VISA or telnet or other protocols (much functionality covered by pyvisa and not Python3 compatible).</li>\n<li>\n<p>Dimitrios Trypogeorgos\u2019s really clean and simple way to integrate Tek scopes into labscript; using a generic BLACS tab which communicates with a \u2018server\u2019 running on any host, sending it software triggers to transiton_to_manual and transition_to_static. This was based off of CameraServer.py. Nice, but:</p>\n<ul>\n<li>The actual scope control is not done by the blacs tab, but the server code which has to be launched separately from blacs, and re-launched separately if it crashes.</li>\n<li>There\u2019s no useful information in the blacs tab\u2019s terminal output.</li>\n</ul>\n</li>\n</ul>\n<p>The aim here is to strip down a useful subset of the above three implementations and make a labscript device which:</p>\n<ol>\n<li>Works as device tab in blacs with no need to launch a server process independently;</li>\n<li>Works with multiple product lines of Tektronix scopes, which have different formatting of the waveform preamble;</li>\n<li>Does binary transfer of waveforms;</li>\n<li>Is Python 2 and 3 compatible;</li>\n<li>TODO: Configure the scope before each shot, including the ability to pass per-shot options like which channels to capture, other acquisition options, and the communications timeout.</li>\n<li>Writes the waveforms to a standard location in the h5 file at the end of the shot.</li>\n<li>Save them as a single compound dataset with named columns, e.g \u2018t\u2019, \u2018CH1\u2019, etc. with attributes of this data set the waveform preamble.</li>\n</ol>\n<p>Tek scopes use one of two different commands to retrieve the waveform preamble, either <code>WFMO</code> or <code>WFMP</code>. The response format of the preamble is also dependent on the scope, so instead we'll just get the preamble attributes one at a time, or with a concatenated command, e.g. <code>WFMP:XUNIT?;:WFMP:YUNIT?;:</code> etc..., which takes a little longer, but beats having to write a per-scope dictionary of the preamble format.</p>\n<p>I have only tested this on a TDS2002B over USB, but this should translate to communicating with other scopes over ethernet, so long as they are VISA devices.</p>\n<p>I'm using the waveform preamble values to convert the 8- or 16-bit integers returned from the scope into floating point voltages. This is fine for for the 2500 points returned by TDS2000 series scopes, but might be unwieldy for the deep memory devices, and warrant saving waveforms as integer types, with the dataset attributes available to convert to floats when reading from the shot file.</p>", "type": "rendered"}, "source": {"commit": {"hash": "5754477217cc", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/quantum_gas_microscope/labscript_devices/commit/5754477217cc"}, "html": {"href": "https://bitbucket.org/quantum_gas_microscope/labscript_devices/commits/5754477217cc"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/quantum_gas_microscope/labscript_devices"}, "html": {"href": "https://bitbucket.org/quantum_gas_microscope/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{872a5cd6-f212-40ce-bd1d-03f667af7296}ts=1896666"}}, "type": "repository", "name": "labscript_devices", "full_name": "quantum_gas_microscope/labscript_devices", "uuid": "{872a5cd6-f212-40ce-bd1d-03f667af7296}"}, "branch": {"name": "TekScope"}}, "comment_count": 4, "state": "MERGED", "task_count": 0, "participants": [{"role": "PARTICIPANT", "participated_on": "2019-06-02T00:09:24.799434+00:00", "type": "participant", "approved": false, "user": {"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}}, {"role": "REVIEWER", "participated_on": "2019-06-03T15:30:45.310804+00:00", "type": "participant", "approved": false, "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}}, {"role": "REVIEWER", "participated_on": null, "type": "participant", "approved": false, "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}}], "reason": "", "updated_on": "2019-06-03T15:30:45.329626+00:00", "author": {"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}, "merge_commit": {"hash": "e622c32d8b8c", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/e622c32d8b8c.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/e622c32d8b8c"}}}, "closed_by": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}}