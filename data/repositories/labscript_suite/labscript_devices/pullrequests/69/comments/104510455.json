{"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/69/comments/104510455.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/69/_/diff#comment-104510455"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 69, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/69.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/69"}}, "title": "Pylon Backend for IMAQdxCamera class"}, "content": {"raw": "Hi David,\n\n> Before I settled on the current method for getting continuous frames (which works fine), I tried another grab strategy where the camera produces frames as fast as possible and just updates the same output buffer which can be read or ignored depending on processing speed. This seemed fine in principle, but when the rate exceeded ~20fps the BLACS tab would completely lock up. Further testing seems to show the tab blocks all signals (including stopping continuous) while the continuous_loop() method proceeds to grab and send images to parent at high speed. The docstring for _send_image_to_parent claims it is blocking, but that doesn\u2019t seem to be the case. Am I missing something? Which thread is it supposed to be blocking?\n\n\nin the worker, `_send_image_to_parent()` waits for a response from the parent before returning, so that bit is blocking from its perspective (as opposed to just putting the image in the zeromq queue and continuing):\n\n```python\n        self.image_socket.send(image, copy=False)\n        response = self.image_socket.recv()\n        assert response == b'ok', response\n```\nIn the parent process, in `ImageReceiver.handler()`, the code that receives the image processes it and queues up a GUI callback (`ImageReceiver.update()`) to display it. That is nonblocking in that it calls `inmain_later()`, which does not wait for the GUI to run the callback before continuing. However, it only allows one unprocessed call to `ImageReceiver.update()` to be waiting to run at any one time:\n```python\n# Wait for the previous update to compete so we don't accumulate a backlog:\nif self.update_event is not None:\n    self.update_event.get()\n```\n\nSo if the child process calls `_send_image_to_parent()`, that should block such that the GUI is at most one frame behind and neither the zeromq queues or the GUI event loop accumulates a backlog of undisplayed frames.\n\nIf you had one thread writing to a buffer as fast as possible and another thread reading from the buffer and calling  `_send_image_to_parent()` in a loop, I am not sure why that would have locked BLACS up. It's possible the mechanism I've described has a bug, but there is not much code to look at and I don't see where I might have gone wrong. This mechanism does limit the frame rate for me - previously I could stop continuous acquisition and frames would continue to display for several seconds while it cleared the queue (zeromq would eventually block at about ~1000 messages, so the backlog was limited to about 1000 frames). But this would still not freeze BLACS. So it's a mystery to me what issue you were seeing there.\n\n\n> During testing, I obviously forgot to connect the trigger line for the first buffered shot and transition_to_manual timed out. This results in a seemingly unrelated error pop-up, the correct error shown in the tab, and BLACS getting stuck in \u201cError in transition to manual, Queue Paused\u201d mode where clearing the error and un-pausing does NOT resume shot execution. I\u2019m fairly certain it is not a bug with the present code, but I\u2019m not sure where the issue lies.\n\nThis sounds like a bug in the queue manager. After a failed shot, BLACS 'cleans' the HDF5 file, by making a copy without acquistiion data from the failed shot. Here you're seeing that the newly cleaned shot file, which is to be renamed over the top of the previous shot file,  apparently doesn't exist. Looking at the code,  it looks like if cleaning the HDF5 file fails, it just logs an error and continues (which is silly, there's no point suppressing the error if we have no way to recover from it). The code that cleans the shot file is:\n\n```python\n    def clean_h5_file(self, h5file, new_h5_file, repeat_number=0):\n        try:\n            with h5py.File(h5file,'r') as old_file:\n                with h5py.File(new_h5_file,'w') as new_file:\n                    groups_to_copy = ['devices', 'calibrations', 'script', 'globals', 'connection table', \n                                      'labscriptlib', 'waits', 'time_markers']\n                    for group in groups_to_copy:\n                        if group in old_file:\n                            new_file.copy(old_file[group], group)\n                    for name in old_file.attrs:\n                        new_file.attrs[name] = old_file.attrs[name]\n                    new_file.attrs['run repeat'] = repeat_number\n        except Exception as e:\n            #raise\n            self._logger.exception('Clean H5 File Error.')\n            return False\n```\n\nSo I would say something failed here. Either the old shot file didn't exist, or it raised an error upon being opened, or something like that. There aren't many things that could have gone wrong here by the looks of it. But if you can reproduce the problem reliably, if you uncomment that `raise` statement, then we will see what the actual error was.", "markup": "markdown", "html": "<p>Hi David,</p>\n<blockquote>\n<p>Before I settled on the current method for getting continuous frames (which works fine), I tried another grab strategy where the camera produces frames as fast as possible and just updates the same output buffer which can be read or ignored depending on processing speed. This seemed fine in principle, but when the rate exceeded ~20fps the BLACS tab would completely lock up. Further testing seems to show the tab blocks all signals (including stopping continuous) while the continuous_loop() method proceeds to grab and send images to parent at high speed. The docstring for _send_image_to_parent claims it is blocking, but that doesn\u2019t seem to be the case. Am I missing something? Which thread is it supposed to be blocking?</p>\n</blockquote>\n<p>in the worker, <code>_send_image_to_parent()</code> waits for a response from the parent before returning, so that bit is blocking from its perspective (as opposed to just putting the image in the zeromq queue and continuing):</p>\n<div class=\"codehilite language-python\"><pre><span></span>        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">image_socket</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"n\">image</span><span class=\"p\">,</span> <span class=\"n\">copy</span><span class=\"o\">=</span><span class=\"bp\">False</span><span class=\"p\">)</span>\n        <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">image_socket</span><span class=\"o\">.</span><span class=\"n\">recv</span><span class=\"p\">()</span>\n        <span class=\"k\">assert</span> <span class=\"n\">response</span> <span class=\"o\">==</span> <span class=\"sa\">b</span><span class=\"s1\">&#39;ok&#39;</span><span class=\"p\">,</span> <span class=\"n\">response</span>\n</pre></div>\n\n\n<p>In the parent process, in <code>ImageReceiver.handler()</code>, the code that receives the image processes it and queues up a GUI callback (<code>ImageReceiver.update()</code>) to display it. That is nonblocking in that it calls <code>inmain_later()</code>, which does not wait for the GUI to run the callback before continuing. However, it only allows one unprocessed call to <code>ImageReceiver.update()</code> to be waiting to run at any one time:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"c1\"># Wait for the previous update to compete so we don&#39;t accumulate a backlog:</span>\n<span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">update_event</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">update_event</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">()</span>\n</pre></div>\n\n\n<p>So if the child process calls <code>_send_image_to_parent()</code>, that should block such that the GUI is at most one frame behind and neither the zeromq queues or the GUI event loop accumulates a backlog of undisplayed frames.</p>\n<p>If you had one thread writing to a buffer as fast as possible and another thread reading from the buffer and calling  <code>_send_image_to_parent()</code> in a loop, I am not sure why that would have locked BLACS up. It's possible the mechanism I've described has a bug, but there is not much code to look at and I don't see where I might have gone wrong. This mechanism does limit the frame rate for me - previously I could stop continuous acquisition and frames would continue to display for several seconds while it cleared the queue (zeromq would eventually block at about ~1000 messages, so the backlog was limited to about 1000 frames). But this would still not freeze BLACS. So it's a mystery to me what issue you were seeing there.</p>\n<blockquote>\n<p>During testing, I obviously forgot to connect the trigger line for the first buffered shot and transition_to_manual timed out. This results in a seemingly unrelated error pop-up, the correct error shown in the tab, and BLACS getting stuck in \u201cError in transition to manual, Queue Paused\u201d mode where clearing the error and un-pausing does NOT resume shot execution. I\u2019m fairly certain it is not a bug with the present code, but I\u2019m not sure where the issue lies.</p>\n</blockquote>\n<p>This sounds like a bug in the queue manager. After a failed shot, BLACS 'cleans' the HDF5 file, by making a copy without acquistiion data from the failed shot. Here you're seeing that the newly cleaned shot file, which is to be renamed over the top of the previous shot file,  apparently doesn't exist. Looking at the code,  it looks like if cleaning the HDF5 file fails, it just logs an error and continues (which is silly, there's no point suppressing the error if we have no way to recover from it). The code that cleans the shot file is:</p>\n<div class=\"codehilite language-python\"><pre><span></span>    <span class=\"k\">def</span> <span class=\"nf\">clean_h5_file</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">h5file</span><span class=\"p\">,</span> <span class=\"n\">new_h5_file</span><span class=\"p\">,</span> <span class=\"n\">repeat_number</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">):</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"k\">with</span> <span class=\"n\">h5py</span><span class=\"o\">.</span><span class=\"n\">File</span><span class=\"p\">(</span><span class=\"n\">h5file</span><span class=\"p\">,</span><span class=\"s1\">&#39;r&#39;</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">old_file</span><span class=\"p\">:</span>\n                <span class=\"k\">with</span> <span class=\"n\">h5py</span><span class=\"o\">.</span><span class=\"n\">File</span><span class=\"p\">(</span><span class=\"n\">new_h5_file</span><span class=\"p\">,</span><span class=\"s1\">&#39;w&#39;</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">new_file</span><span class=\"p\">:</span>\n                    <span class=\"n\">groups_to_copy</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;devices&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;calibrations&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;script&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;globals&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;connection table&#39;</span><span class=\"p\">,</span> \n                                      <span class=\"s1\">&#39;labscriptlib&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;waits&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;time_markers&#39;</span><span class=\"p\">]</span>\n                    <span class=\"k\">for</span> <span class=\"n\">group</span> <span class=\"ow\">in</span> <span class=\"n\">groups_to_copy</span><span class=\"p\">:</span>\n                        <span class=\"k\">if</span> <span class=\"n\">group</span> <span class=\"ow\">in</span> <span class=\"n\">old_file</span><span class=\"p\">:</span>\n                            <span class=\"n\">new_file</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">(</span><span class=\"n\">old_file</span><span class=\"p\">[</span><span class=\"n\">group</span><span class=\"p\">],</span> <span class=\"n\">group</span><span class=\"p\">)</span>\n                    <span class=\"k\">for</span> <span class=\"n\">name</span> <span class=\"ow\">in</span> <span class=\"n\">old_file</span><span class=\"o\">.</span><span class=\"n\">attrs</span><span class=\"p\">:</span>\n                        <span class=\"n\">new_file</span><span class=\"o\">.</span><span class=\"n\">attrs</span><span class=\"p\">[</span><span class=\"n\">name</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">old_file</span><span class=\"o\">.</span><span class=\"n\">attrs</span><span class=\"p\">[</span><span class=\"n\">name</span><span class=\"p\">]</span>\n                    <span class=\"n\">new_file</span><span class=\"o\">.</span><span class=\"n\">attrs</span><span class=\"p\">[</span><span class=\"s1\">&#39;run repeat&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">repeat_number</span>\n        <span class=\"k\">except</span> <span class=\"ne\">Exception</span> <span class=\"k\">as</span> <span class=\"n\">e</span><span class=\"p\">:</span>\n            <span class=\"c1\">#raise</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_logger</span><span class=\"o\">.</span><span class=\"n\">exception</span><span class=\"p\">(</span><span class=\"s1\">&#39;Clean H5 File Error.&#39;</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"bp\">False</span>\n</pre></div>\n\n\n<p>So I would say something failed here. Either the old shot file didn't exist, or it raised an error upon being opened, or something like that. There aren't many things that could have gone wrong here by the looks of it. But if you can reproduce the problem reliably, if you uncomment that <code>raise</code> statement, then we will see what the actual error was.</p>", "type": "rendered"}, "created_on": "2019-06-04T19:55:38.027362+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-06-04T19:56:37.558241+00:00", "type": "pullrequest_comment", "id": 104510455}