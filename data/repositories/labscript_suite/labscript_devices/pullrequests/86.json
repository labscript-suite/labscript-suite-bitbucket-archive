{"rendered": {"description": {"raw": "Added a labscript device called `SoftwareDevice`, that you attach functions to\r\nto run during `transition_to_buffered` or `transition_to_static`\r\n\r\nSyntax is such that the device can in future be extended to run functions\r\nin the middle of the experiment in software time, but that is not yet\r\nimplemented.\r\n\r\nAlso still possibly todo is to save results of the functions, including whether they raise\r\nexceptions or not. An option for whether to stop on exception or not should\r\nalso be able to be set as a device property, so that failing functions don't\r\nstop the experiment from cycling if you don't want them to.\r\n\r\nThe use case for implementing this is that we want to have some important analysis results influence the very next shot, specifically, a measurement of how out of resonance we are for a microwave transition to feed forward to magnetic field cancellation in the next shot. This is important as the field drifts throughout the day. Allowing lyse to do the analysis is not ideal since we don't want the experiment to stop cycling because we are messing around with lyse - lyse analysis should be asynchronous with the experiment most of the time.\r\n\r\nTo that end a function attached to a \"software device\" will do some image analysis at the end of each shot, and update runmanager globals using the `runmanager.remote` API. Yet to come is a \"just in time\" compilation mode for runmanager, where it does not compile shots until BLACS is ready to run them. This will ensure the new globals are used in the very next shot.\r\n\r\nThere is nothing stopping a function run by the SoftwareDevice from instantiating a `lyse.Run` and saving its results under some group name (which will have to be set manually via `Run.set_group()`), such that lyse routines can use the results later.\r\n\r\nHere's what it looks like in labscript code:\r\n\r\n```python\r\nfrom labscript import *\r\nfrom labscript_devices.DummyPseudoclock.labscript_devices import DummyPseudoclock\r\nfrom labscript_devices.SoftwareDevice.labscript_devices import SoftwareDevice\r\n\r\nDummyPseudoclock('pseudoclock')\r\nSoftwareDevice('software_device')\r\n\r\n\r\ndef foo(shot_context, t, arg):\r\n    print(f\"hello, {arg}!\")\r\n\r\n\r\nsoftware_device.add_function('start', foo, 'world')\r\n\r\nstart()\r\nstop(1)\r\n```\r\n\r\nAnd here's the result in BLACS:\r\n\r\n![software_device.png](data/bitbucket.org/repo/7EEj84e/images/3545842253-software_device.png)", "markup": "markdown", "html": "<p>Added a labscript device called <code>SoftwareDevice</code>, that you attach functions to\nto run during <code>transition_to_buffered</code> or <code>transition_to_static</code></p>\n<p>Syntax is such that the device can in future be extended to run functions\nin the middle of the experiment in software time, but that is not yet\nimplemented.</p>\n<p>Also still possibly todo is to save results of the functions, including whether they raise\nexceptions or not. An option for whether to stop on exception or not should\nalso be able to be set as a device property, so that failing functions don't\nstop the experiment from cycling if you don't want them to.</p>\n<p>The use case for implementing this is that we want to have some important analysis results influence the very next shot, specifically, a measurement of how out of resonance we are for a microwave transition to feed forward to magnetic field cancellation in the next shot. This is important as the field drifts throughout the day. Allowing lyse to do the analysis is not ideal since we don't want the experiment to stop cycling because we are messing around with lyse - lyse analysis should be asynchronous with the experiment most of the time.</p>\n<p>To that end a function attached to a \"software device\" will do some image analysis at the end of each shot, and update runmanager globals using the <code>runmanager.remote</code> API. Yet to come is a \"just in time\" compilation mode for runmanager, where it does not compile shots until BLACS is ready to run them. This will ensure the new globals are used in the very next shot.</p>\n<p>There is nothing stopping a function run by the SoftwareDevice from instantiating a <code>lyse.Run</code> and saving its results under some group name (which will have to be set manually via <code>Run.set_group()</code>), such that lyse routines can use the results later.</p>\n<p>Here's what it looks like in labscript code:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">labscript</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n<span class=\"kn\">from</span> <span class=\"nn\">labscript_devices.DummyPseudoclock.labscript_devices</span> <span class=\"kn\">import</span> <span class=\"n\">DummyPseudoclock</span>\n<span class=\"kn\">from</span> <span class=\"nn\">labscript_devices.SoftwareDevice.labscript_devices</span> <span class=\"kn\">import</span> <span class=\"n\">SoftwareDevice</span>\n\n<span class=\"n\">DummyPseudoclock</span><span class=\"p\">(</span><span class=\"s1\">&#39;pseudoclock&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">SoftwareDevice</span><span class=\"p\">(</span><span class=\"s1\">&#39;software_device&#39;</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">shot_context</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">arg</span><span class=\"p\">):</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"s2\">&quot;hello, {arg}!&quot;</span><span class=\"p\">)</span>\n\n\n<span class=\"n\">software_device</span><span class=\"o\">.</span><span class=\"n\">add_function</span><span class=\"p\">(</span><span class=\"s1\">&#39;start&#39;</span><span class=\"p\">,</span> <span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"s1\">&#39;world&#39;</span><span class=\"p\">)</span>\n\n<span class=\"n\">start</span><span class=\"p\">()</span>\n<span class=\"n\">stop</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>And here's the result in BLACS:</p>\n<p><img alt=\"software_device.png\" src=\"data/bitbucket.org/repo/7EEj84e/images/3545842253-software_device.png\" /></p>", "type": "rendered"}, "title": {"raw": "Added a 'device' that runs arbitrary functions before/after the experiment.", "markup": "markdown", "html": "<p>Added a 'device' that runs arbitrary functions before/after the experiment.</p>", "type": "rendered"}}, "type": "pullrequest", "description": "Added a labscript device called `SoftwareDevice`, that you attach functions to\r\nto run during `transition_to_buffered` or `transition_to_static`\r\n\r\nSyntax is such that the device can in future be extended to run functions\r\nin the middle of the experiment in software time, but that is not yet\r\nimplemented.\r\n\r\nAlso still possibly todo is to save results of the functions, including whether they raise\r\nexceptions or not. An option for whether to stop on exception or not should\r\nalso be able to be set as a device property, so that failing functions don't\r\nstop the experiment from cycling if you don't want them to.\r\n\r\nThe use case for implementing this is that we want to have some important analysis results influence the very next shot, specifically, a measurement of how out of resonance we are for a microwave transition to feed forward to magnetic field cancellation in the next shot. This is important as the field drifts throughout the day. Allowing lyse to do the analysis is not ideal since we don't want the experiment to stop cycling because we are messing around with lyse - lyse analysis should be asynchronous with the experiment most of the time.\r\n\r\nTo that end a function attached to a \"software device\" will do some image analysis at the end of each shot, and update runmanager globals using the `runmanager.remote` API. Yet to come is a \"just in time\" compilation mode for runmanager, where it does not compile shots until BLACS is ready to run them. This will ensure the new globals are used in the very next shot.\r\n\r\nThere is nothing stopping a function run by the SoftwareDevice from instantiating a `lyse.Run` and saving its results under some group name (which will have to be set manually via `Run.set_group()`), such that lyse routines can use the results later.\r\n\r\nHere's what it looks like in labscript code:\r\n\r\n```python\r\nfrom labscript import *\r\nfrom labscript_devices.DummyPseudoclock.labscript_devices import DummyPseudoclock\r\nfrom labscript_devices.SoftwareDevice.labscript_devices import SoftwareDevice\r\n\r\nDummyPseudoclock('pseudoclock')\r\nSoftwareDevice('software_device')\r\n\r\n\r\ndef foo(shot_context, t, arg):\r\n    print(f\"hello, {arg}!\")\r\n\r\n\r\nsoftware_device.add_function('start', foo, 'world')\r\n\r\nstart()\r\nstop(1)\r\n```\r\n\r\nAnd here's the result in BLACS:\r\n\r\n![software_device.png](data/bitbucket.org/repo/7EEj84e/images/3545842253-software_device.png)", "links": {"decline": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/pullrequests/86/decline"}, "diffstat": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/diffstat/labscript_suite/labscript_devices:537cc3780c54%0D625926f151be?from_pullrequest_id=86"}, "commits": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86/commits.json"}, "self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86.json"}, "comments": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86/comments_page=1.json"}, "merge": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/pullrequests/86/merge"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/86"}, "activity": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86/activity.json"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/diff/labscript_suite/labscript_devices:537cc3780c54%0D625926f151be?from_pullrequest_id=86"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_devices/pullrequests/86/approve"}, "statuses": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86/statuses_page=1.json"}}, "title": "Added a 'device' that runs arbitrary functions before/after the experiment.", "close_source_branch": true, "reviewers": [{"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}, {"display_name": "Philip Starkey", "uuid": "{0147401a-13ed-4e39-a0d0-63108c18738b}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D"}, "html": {"href": "https://bitbucket.org/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/fa0698c306b3470c00717c146b5296e9d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "philipstarkey", "type": "user", "account_id": "557058:2f99420c-1dbd-4837-952c-82c421b8fbdd"}], "id": 86, "destination": {"commit": {"hash": "625926f151be", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/625926f151be.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/625926f151be"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "created_on": "2019-11-15T02:36:28.097284+00:00", "summary": {"raw": "Added a labscript device called `SoftwareDevice`, that you attach functions to\r\nto run during `transition_to_buffered` or `transition_to_static`\r\n\r\nSyntax is such that the device can in future be extended to run functions\r\nin the middle of the experiment in software time, but that is not yet\r\nimplemented.\r\n\r\nAlso still possibly todo is to save results of the functions, including whether they raise\r\nexceptions or not. An option for whether to stop on exception or not should\r\nalso be able to be set as a device property, so that failing functions don't\r\nstop the experiment from cycling if you don't want them to.\r\n\r\nThe use case for implementing this is that we want to have some important analysis results influence the very next shot, specifically, a measurement of how out of resonance we are for a microwave transition to feed forward to magnetic field cancellation in the next shot. This is important as the field drifts throughout the day. Allowing lyse to do the analysis is not ideal since we don't want the experiment to stop cycling because we are messing around with lyse - lyse analysis should be asynchronous with the experiment most of the time.\r\n\r\nTo that end a function attached to a \"software device\" will do some image analysis at the end of each shot, and update runmanager globals using the `runmanager.remote` API. Yet to come is a \"just in time\" compilation mode for runmanager, where it does not compile shots until BLACS is ready to run them. This will ensure the new globals are used in the very next shot.\r\n\r\nThere is nothing stopping a function run by the SoftwareDevice from instantiating a `lyse.Run` and saving its results under some group name (which will have to be set manually via `Run.set_group()`), such that lyse routines can use the results later.\r\n\r\nHere's what it looks like in labscript code:\r\n\r\n```python\r\nfrom labscript import *\r\nfrom labscript_devices.DummyPseudoclock.labscript_devices import DummyPseudoclock\r\nfrom labscript_devices.SoftwareDevice.labscript_devices import SoftwareDevice\r\n\r\nDummyPseudoclock('pseudoclock')\r\nSoftwareDevice('software_device')\r\n\r\n\r\ndef foo(shot_context, t, arg):\r\n    print(f\"hello, {arg}!\")\r\n\r\n\r\nsoftware_device.add_function('start', foo, 'world')\r\n\r\nstart()\r\nstop(1)\r\n```\r\n\r\nAnd here's the result in BLACS:\r\n\r\n![software_device.png](data/bitbucket.org/repo/7EEj84e/images/3545842253-software_device.png)", "markup": "markdown", "html": "<p>Added a labscript device called <code>SoftwareDevice</code>, that you attach functions to\nto run during <code>transition_to_buffered</code> or <code>transition_to_static</code></p>\n<p>Syntax is such that the device can in future be extended to run functions\nin the middle of the experiment in software time, but that is not yet\nimplemented.</p>\n<p>Also still possibly todo is to save results of the functions, including whether they raise\nexceptions or not. An option for whether to stop on exception or not should\nalso be able to be set as a device property, so that failing functions don't\nstop the experiment from cycling if you don't want them to.</p>\n<p>The use case for implementing this is that we want to have some important analysis results influence the very next shot, specifically, a measurement of how out of resonance we are for a microwave transition to feed forward to magnetic field cancellation in the next shot. This is important as the field drifts throughout the day. Allowing lyse to do the analysis is not ideal since we don't want the experiment to stop cycling because we are messing around with lyse - lyse analysis should be asynchronous with the experiment most of the time.</p>\n<p>To that end a function attached to a \"software device\" will do some image analysis at the end of each shot, and update runmanager globals using the <code>runmanager.remote</code> API. Yet to come is a \"just in time\" compilation mode for runmanager, where it does not compile shots until BLACS is ready to run them. This will ensure the new globals are used in the very next shot.</p>\n<p>There is nothing stopping a function run by the SoftwareDevice from instantiating a <code>lyse.Run</code> and saving its results under some group name (which will have to be set manually via <code>Run.set_group()</code>), such that lyse routines can use the results later.</p>\n<p>Here's what it looks like in labscript code:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">labscript</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n<span class=\"kn\">from</span> <span class=\"nn\">labscript_devices.DummyPseudoclock.labscript_devices</span> <span class=\"kn\">import</span> <span class=\"n\">DummyPseudoclock</span>\n<span class=\"kn\">from</span> <span class=\"nn\">labscript_devices.SoftwareDevice.labscript_devices</span> <span class=\"kn\">import</span> <span class=\"n\">SoftwareDevice</span>\n\n<span class=\"n\">DummyPseudoclock</span><span class=\"p\">(</span><span class=\"s1\">&#39;pseudoclock&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">SoftwareDevice</span><span class=\"p\">(</span><span class=\"s1\">&#39;software_device&#39;</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">shot_context</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">arg</span><span class=\"p\">):</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"s2\">&quot;hello, {arg}!&quot;</span><span class=\"p\">)</span>\n\n\n<span class=\"n\">software_device</span><span class=\"o\">.</span><span class=\"n\">add_function</span><span class=\"p\">(</span><span class=\"s1\">&#39;start&#39;</span><span class=\"p\">,</span> <span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"s1\">&#39;world&#39;</span><span class=\"p\">)</span>\n\n<span class=\"n\">start</span><span class=\"p\">()</span>\n<span class=\"n\">stop</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>And here's the result in BLACS:</p>\n<p><img alt=\"software_device.png\" src=\"data/bitbucket.org/repo/7EEj84e/images/3545842253-software_device.png\" /></p>", "type": "rendered"}, "source": {"commit": {"hash": "0022ad6588f5", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/0022ad6588f5"}, "html": {"href": "#!/cbillington/labscript_devices/commits/0022ad6588f5"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "SoftwareDevice"}}, "comment_count": 2, "state": "MERGED", "task_count": 0, "participants": [{"role": "REVIEWER", "participated_on": null, "type": "participant", "approved": false, "user": {"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}}, {"role": "PARTICIPANT", "participated_on": "2019-11-15T03:45:31.869010+00:00", "type": "participant", "approved": false, "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}}, {"role": "REVIEWER", "participated_on": "2020-01-16T09:52:56.810136+00:00", "type": "participant", "approved": true, "user": {"display_name": "Philip Starkey", "uuid": "{0147401a-13ed-4e39-a0d0-63108c18738b}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D"}, "html": {"href": "https://bitbucket.org/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/fa0698c306b3470c00717c146b5296e9d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "philipstarkey", "type": "user", "account_id": "557058:2f99420c-1dbd-4837-952c-82c421b8fbdd"}}], "reason": "", "updated_on": "2020-01-16T10:23:30.042478+00:00", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "merge_commit": {"hash": "537cc3780c54", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/537cc3780c54.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/537cc3780c54"}}}, "closed_by": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}}