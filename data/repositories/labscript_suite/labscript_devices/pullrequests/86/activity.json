{"pagelen": 50, "values": [{"update": {"description": "Added a labscript device called `SoftwareDevice`, that you attach functions to\r\nto run during `transition_to_buffered` or `transition_to_static`\r\n\r\nSyntax is such that the device can in future be extended to run functions\r\nin the middle of the experiment in software time, but that is not yet\r\nimplemented.\r\n\r\nAlso still possibly todo is to save results of the functions, including whether they raise\r\nexceptions or not. An option for whether to stop on exception or not should\r\nalso be able to be set as a device property, so that failing functions don't\r\nstop the experiment from cycling if you don't want them to.\r\n\r\nThe use case for implementing this is that we want to have some important analysis results influence the very next shot, specifically, a measurement of how out of resonance we are for a microwave transition to feed forward to magnetic field cancellation in the next shot. This is important as the field drifts throughout the day. Allowing lyse to do the analysis is not ideal since we don't want the experiment to stop cycling because we are messing around with lyse - lyse analysis should be asynchronous with the experiment most of the time.\r\n\r\nTo that end a function attached to a \"software device\" will do some image analysis at the end of each shot, and update runmanager globals using the `runmanager.remote` API. Yet to come is a \"just in time\" compilation mode for runmanager, where it does not compile shots until BLACS is ready to run them. This will ensure the new globals are used in the very next shot.\r\n\r\nThere is nothing stopping a function run by the SoftwareDevice from instantiating a `lyse.Run` and saving its results under some group name (which will have to be set manually via `Run.set_group()`), such that lyse routines can use the results later.\r\n\r\nHere's what it looks like in labscript code:\r\n\r\n```python\r\nfrom labscript import *\r\nfrom labscript_devices.DummyPseudoclock.labscript_devices import DummyPseudoclock\r\nfrom labscript_devices.SoftwareDevice.labscript_devices import SoftwareDevice\r\n\r\nDummyPseudoclock('pseudoclock')\r\nSoftwareDevice('software_device')\r\n\r\n\r\ndef foo(shot_context, t, arg):\r\n    print(f\"hello, {arg}!\")\r\n\r\n\r\nsoftware_device.add_function('start', foo, 'world')\r\n\r\nstart()\r\nstop(1)\r\n```\r\n\r\nAnd here's the result in BLACS:\r\n\r\n![software_device.png](https://bitbucket.org/repo/7EEj84e/images/3545842253-software_device.png)", "title": "Added a 'device' that runs arbitrary functions before/after the experiment.", "destination": {"commit": {"hash": "625926f151be", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/625926f151be.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/625926f151be"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "0022ad6588f5", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/0022ad6588f5"}, "html": {"href": "#!/cbillington/labscript_devices/commits/0022ad6588f5"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "SoftwareDevice"}}, "state": "MERGED", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2020-01-16T10:23:30.058665+00:00"}, "pull_request": {"type": "pullrequest", "id": 86, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/86"}}, "title": "Added a 'device' that runs arbitrary functions before/after the experiment."}}, {"update": {"description": "Added a labscript device called `SoftwareDevice`, that you attach functions to\r\nto run during `transition_to_buffered` or `transition_to_static`\r\n\r\nSyntax is such that the device can in future be extended to run functions\r\nin the middle of the experiment in software time, but that is not yet\r\nimplemented.\r\n\r\nAlso still possibly todo is to save results of the functions, including whether they raise\r\nexceptions or not. An option for whether to stop on exception or not should\r\nalso be able to be set as a device property, so that failing functions don't\r\nstop the experiment from cycling if you don't want them to.\r\n\r\nThe use case for implementing this is that we want to have some important analysis results influence the very next shot, specifically, a measurement of how out of resonance we are for a microwave transition to feed forward to magnetic field cancellation in the next shot. This is important as the field drifts throughout the day. Allowing lyse to do the analysis is not ideal since we don't want the experiment to stop cycling because we are messing around with lyse - lyse analysis should be asynchronous with the experiment most of the time.\r\n\r\nTo that end a function attached to a \"software device\" will do some image analysis at the end of each shot, and update runmanager globals using the `runmanager.remote` API. Yet to come is a \"just in time\" compilation mode for runmanager, where it does not compile shots until BLACS is ready to run them. This will ensure the new globals are used in the very next shot.\r\n\r\nThere is nothing stopping a function run by the SoftwareDevice from instantiating a `lyse.Run` and saving its results under some group name (which will have to be set manually via `Run.set_group()`), such that lyse routines can use the results later.\r\n\r\nHere's what it looks like in labscript code:\r\n\r\n```python\r\nfrom labscript import *\r\nfrom labscript_devices.DummyPseudoclock.labscript_devices import DummyPseudoclock\r\nfrom labscript_devices.SoftwareDevice.labscript_devices import SoftwareDevice\r\n\r\nDummyPseudoclock('pseudoclock')\r\nSoftwareDevice('software_device')\r\n\r\n\r\ndef foo(shot_context, t, arg):\r\n    print(f\"hello, {arg}!\")\r\n\r\n\r\nsoftware_device.add_function('start', foo, 'world')\r\n\r\nstart()\r\nstop(1)\r\n```\r\n\r\nAnd here's the result in BLACS:\r\n\r\n![software_device.png](https://bitbucket.org/repo/7EEj84e/images/3545842253-software_device.png)", "title": "Added a 'device' that runs arbitrary functions before/after the experiment.", "destination": {"commit": {"hash": "625926f151be", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/625926f151be.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/625926f151be"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "0022ad6588f5", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/0022ad6588f5"}, "html": {"href": "#!/cbillington/labscript_devices/commits/0022ad6588f5"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "SoftwareDevice"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2020-01-16T10:23:28.344723+00:00"}, "pull_request": {"type": "pullrequest", "id": 86, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/86"}}, "title": "Added a 'device' that runs arbitrary functions before/after the experiment."}}, {"approval": {"date": "2020-01-16T09:52:56.810136+00:00", "pullrequest": {"type": "pullrequest", "id": 86, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/86"}}, "title": "Added a 'device' that runs arbitrary functions before/after the experiment."}, "user": {"display_name": "Philip Starkey", "uuid": "{0147401a-13ed-4e39-a0d0-63108c18738b}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D"}, "html": {"href": "https://bitbucket.org/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/fa0698c306b3470c00717c146b5296e9d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "philipstarkey", "type": "user", "account_id": "557058:2f99420c-1dbd-4837-952c-82c421b8fbdd"}}, "pull_request": {"type": "pullrequest", "id": 86, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/86"}}, "title": "Added a 'device' that runs arbitrary functions before/after the experiment."}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86/comments/131895546.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/86/_/diff#comment-131895546"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 86, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/86"}}, "title": "Added a 'device' that runs arbitrary functions before/after the experiment."}, "content": {"raw": "Given this is entirely new code I think it should be merged.", "markup": "markdown", "html": "<p>Given this is entirely new code I think it should be merged.</p>", "type": "rendered"}, "created_on": "2020-01-16T09:52:52.924669+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{0147401a-13ed-4e39-a0d0-63108c18738b}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D"}, "html": {"href": "https://bitbucket.org/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/fa0698c306b3470c00717c146b5296e9d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "philipstarkey", "type": "user", "account_id": "557058:2f99420c-1dbd-4837-952c-82c421b8fbdd"}, "updated_on": "2020-01-16T09:52:52.932237+00:00", "type": "pullrequest_comment", "id": 131895546}, "pull_request": {"type": "pullrequest", "id": 86, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/86"}}, "title": "Added a 'device' that runs arbitrary functions before/after the experiment."}}, {"update": {"description": "Added a labscript device called `SoftwareDevice`, that you attach functions to\r\nto run during `transition_to_buffered` or `transition_to_static`\r\n\r\nSyntax is such that the device can in future be extended to run functions\r\nin the middle of the experiment in software time, but that is not yet\r\nimplemented.\r\n\r\nAlso still possibly todo is to save results of the functions, including whether they raise\r\nexceptions or not. An option for whether to stop on exception or not should\r\nalso be able to be set as a device property, so that failing functions don't\r\nstop the experiment from cycling if you don't want them to.\r\n\r\nThe use case for implementing this is that we want to have some important analysis results influence the very next shot, specifically, a measurement of how out of resonance we are for a microwave transition to feed forward to magnetic field cancellation in the next shot. This is important as the field drifts throughout the day. Allowing lyse to do the analysis is not ideal since we don't want the experiment to stop cycling because we are messing around with lyse - lyse analysis should be asynchronous with the experiment most of the time.\r\n\r\nTo that end a function attached to a \"software device\" will do some image analysis at the end of each shot, and update runmanager globals using the `runmanager.remote` API. Yet to come is a \"just in time\" compilation mode for runmanager, where it does not compile shots until BLACS is ready to run them. This will ensure the new globals are used in the very next shot.\r\n\r\nThere is nothing stopping a function run by the SoftwareDevice from instantiating a `lyse.Run` and saving its results under some group name (which will have to be set manually via `Run.set_group()`), such that lyse routines can use the results later.\r\n\r\nHere's what it looks like in labscript code:\r\n\r\n```python\r\nfrom labscript import *\r\nfrom labscript_devices.DummyPseudoclock.labscript_devices import DummyPseudoclock\r\nfrom labscript_devices.SoftwareDevice.labscript_devices import SoftwareDevice\r\n\r\nDummyPseudoclock('pseudoclock')\r\nSoftwareDevice('software_device')\r\n\r\n\r\ndef foo(shot_context, t, arg):\r\n    print(f\"hello, {arg}!\")\r\n\r\n\r\nsoftware_device.add_function('start', foo, 'world')\r\n\r\nstart()\r\nstop(1)\r\n```\r\n\r\nAnd here's the result in BLACS:\r\n\r\n![software_device.png](https://bitbucket.org/repo/7EEj84e/images/3545842253-software_device.png)", "title": "Added a 'device' that runs arbitrary functions before/after the experiment.", "destination": {"commit": {"hash": "625926f151be", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/625926f151be.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/625926f151be"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "0022ad6588f5", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/0022ad6588f5"}, "html": {"href": "#!/cbillington/labscript_devices/commits/0022ad6588f5"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "SoftwareDevice"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-12-13T21:12:04.170882+00:00"}, "pull_request": {"type": "pullrequest", "id": 86, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/86"}}, "title": "Added a 'device' that runs arbitrary functions before/after the experiment."}}, {"comment": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86/comments/124929113.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/86/_/diff#comment-124929113"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 86, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/86"}}, "title": "Added a 'device' that runs arbitrary functions before/after the experiment."}, "content": {"raw": "For a bit more explanation about what\u2019s going on, the functions are serialised and saved to the HDF5 file in the form of their source code, and the arguments and keyword arguments are serialised using `labscript_utils.properties.(de)serialise`. Nothing else is serialised with them, if they use globals or imports from outside their own function bodies they will not work. So the way they are serialised is very portable, and not too magical - trying to pull in used modules and global variables etc automatically would be going a bit too far I think.\n\nAlso, I\u2019ve changed it so that the deserialised functions find themselves in a namespace with `__file__` set to the name of the software device. This means that if the function creates a `lyse.Run`, it will \\(after [lyse PR #72](#!/labscript_suite/lyse/pull-requests/72)\\) set the results group name to the device name.", "markup": "markdown", "html": "<p>For a bit more explanation about what\u2019s going on, the functions are serialised and saved to the HDF5 file in the form of their source code, and the arguments and keyword arguments are serialised using <code>labscript_utils.properties.(de)serialise</code>. Nothing else is serialised with them, if they use globals or imports from outside their own function bodies they will not work. So the way they are serialised is very portable, and not too magical - trying to pull in used modules and global variables etc automatically would be going a bit too far I think.</p>\n<p>Also, I\u2019ve changed it so that the deserialised functions find themselves in a namespace with <code>__file__</code> set to the name of the software device. This means that if the function creates a <code>lyse.Run</code>, it will (after <a data-is-external-link=\"true\" href=\"#!/labscript_suite/lyse/pull-requests/72\" rel=\"nofollow\">lyse PR #72</a>) set the results group name to the device name.</p>", "type": "rendered"}, "created_on": "2019-11-15T03:45:31.862742+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-11-15T03:45:31.869010+00:00", "type": "pullrequest_comment", "id": 124929113}, "pull_request": {"type": "pullrequest", "id": 86, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/86"}}, "title": "Added a 'device' that runs arbitrary functions before/after the experiment."}}, {"update": {"description": "Added a labscript device called `SoftwareDevice`, that you attach functions to\r\nto run during `transition_to_buffered` or `transition_to_static`\r\n\r\nSyntax is such that the device can in future be extended to run functions\r\nin the middle of the experiment in software time, but that is not yet\r\nimplemented.\r\n\r\nAlso still possibly todo is to save results of the functions, including whether they raise\r\nexceptions or not. An option for whether to stop on exception or not should\r\nalso be able to be set as a device property, so that failing functions don't\r\nstop the experiment from cycling if you don't want them to.\r\n\r\nThe use case for implementing this is that we want to have some important analysis results influence the very next shot, specifically, a measurement of how out of resonance we are for a microwave transition to feed forward to magnetic field cancellation in the next shot. This is important as the field drifts throughout the day. Allowing lyse to do the analysis is not ideal since we don't want the experiment to stop cycling because we are messing around with lyse - lyse analysis should be asynchronous with the experiment most of the time.\r\n\r\nTo that end a function attached to a \"software device\" will do some image analysis at the end of each shot, and update runmanager globals using the `runmanager.remote` API. Yet to come is a \"just in time\" compilation mode for runmanager, where it does not compile shots until BLACS is ready to run them. This will ensure the new globals are used in the very next shot.\r\n\r\nThere is nothing stopping a function run by the SoftwareDevice from instantiating a `lyse.Run` and saving its results under some group name (which will have to be set manually via `Run.set_group()`), such that lyse routines can use the results later.\r\n\r\nHere's what it looks like in labscript code:\r\n\r\n```python\r\nfrom labscript import *\r\nfrom labscript_devices.DummyPseudoclock.labscript_devices import DummyPseudoclock\r\nfrom labscript_devices.SoftwareDevice.labscript_devices import SoftwareDevice\r\n\r\nDummyPseudoclock('pseudoclock')\r\nSoftwareDevice('software_device')\r\n\r\n\r\ndef foo(shot_context, t, arg):\r\n    print(f\"hello, {arg}!\")\r\n\r\n\r\nsoftware_device.add_function('start', foo, 'world')\r\n\r\nstart()\r\nstop(1)\r\n```\r\n\r\nAnd here's the result in BLACS:\r\n\r\n![software_device.png](https://bitbucket.org/repo/7EEj84e/images/3545842253-software_device.png)", "title": "Added a 'device' that runs arbitrary functions before/after the experiment.", "destination": {"commit": {"hash": "8c9f9c881048", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/8c9f9c881048.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/8c9f9c881048"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "122a8255d024", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/122a8255d024"}, "html": {"href": "#!/cbillington/labscript_devices/commits/122a8255d024"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "SoftwareDevice"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-11-15T03:42:53.540433+00:00"}, "pull_request": {"type": "pullrequest", "id": 86, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/86"}}, "title": "Added a 'device' that runs arbitrary functions before/after the experiment."}}, {"update": {"description": "Added a labscript device called `SoftwareDevice`, that you attach functions to\r\nto run during `transition_to_buffered` or `transition_to_static`\r\n\r\nSyntax is such that the device can in future be extended to run functions\r\nin the middle of the experiment in software time, but that is not yet\r\nimplemented.\r\n\r\nAlso still possibly todo is to save results of the functions, including whether they raise\r\nexceptions or not. An option for whether to stop on exception or not should\r\nalso be able to be set as a device property, so that failing functions don't\r\nstop the experiment from cycling if you don't want them to.\r\n\r\nThe use case for implementing this is that we want to have some important analysis results influence the very next shot, specifically, a measurement of how out of resonance we are for a microwave transition to feed forward to magnetic field cancellation in the next shot. This is important as the field drifts throughout the day. Allowing lyse to do the analysis is not ideal since we don't want the experiment to stop cycling because we are messing around with lyse - lyse analysis should be asynchronous with the experiment most of the time.\r\n\r\nTo that end a function attached to a \"software device\" will do some image analysis at the end of each shot, and update runmanager globals using the `runmanager.remote` API. Yet to come is a \"just in time\" compilation mode for runmanager, where it does not compile shots until BLACS is ready to run them. This will ensure the new globals are used in the very next shot.\r\n\r\nThere is nothing stopping a function run by the SoftwareDevice from instantiating a `lyse.Run` and saving its results under some group name (which will have to be set manually via `Run.set_group()`), such that lyse routines can use the results later.\r\n\r\nHere's what it looks like in labscript code:\r\n\r\n```python\r\nfrom labscript import *\r\nfrom labscript_devices.DummyPseudoclock.labscript_devices import DummyPseudoclock\r\nfrom labscript_devices.SoftwareDevice.labscript_devices import SoftwareDevice\r\n\r\nDummyPseudoclock('pseudoclock')\r\nSoftwareDevice('software_device')\r\n\r\n\r\ndef foo(shot_context, t, arg):\r\n    print(f\"hello, {arg}!\")\r\n\r\n\r\nsoftware_device.add_function('start', foo, 'world')\r\n\r\nstart()\r\nstop(1)\r\n```\r\n\r\nAnd here's the result in BLACS:\r\n\r\n![software_device.png](https://bitbucket.org/repo/7EEj84e/images/3545842253-software_device.png)", "title": "Added a 'device' that runs arbitrary functions before/after the experiment.", "destination": {"commit": {"hash": "8c9f9c881048", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/8c9f9c881048.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/8c9f9c881048"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "63e2b0702d55", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/63e2b0702d55"}, "html": {"href": "#!/cbillington/labscript_devices/commits/63e2b0702d55"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "SoftwareDevice"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-11-15T02:55:02.295326+00:00"}, "pull_request": {"type": "pullrequest", "id": 86, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/86"}}, "title": "Added a 'device' that runs arbitrary functions before/after the experiment."}}, {"update": {"description": "Added a labscript device called `SoftwareDevice`, that you attach functions to\r\nto run during `transition_to_buffered` or `transition_to_static`\r\n\r\nSyntax is such that the device can in future be extended to run functions\r\nin the middle of the experiment in software time, but that is not yet\r\nimplemented.\r\n\r\nAlso still possibly todo is to save results of the functions, including whether they raise\r\nexceptions or not. An option for whether to stop on exception or not should\r\nalso be able to be set as a device property, so that failing functions don't\r\nstop the experiment from cycling if you don't want them to.\r\n\r\nThe use case for implementing this is that we want to have some important analysis results influence the very next shot, specifically, a measurement of how out of resonance we are for a microwave transition to feed forward to magnetic field cancellation in the next shot. This is important as the field drifts throughout the day. Allowing lyse to do the analysis is not ideal since we don't want the experiment to stop cycling because we are messing around with lyse - lyse analysis should be asynchronous with the experiment most of the time.\r\n\r\nTo that end a function attached to a \"software device\" will do some image analysis at the end of each shot, and update runmanager globals using the `runmanager.remote` API. Yet to come is a \"just in time\" compilation mode for runmanager, where it does not compile shots until BLACS is ready to run them. This will ensure the new globals are used in the very next shot.\r\n\r\nThere is nothing stopping a function run by the SoftwareDevice from instantiating a `lyse.Run` and saving its results under some group name (which will have to be set manually via `Run.set_group()`), such that lyse routines can use the results later.\r\n\r\nHere's what it looks like in labscript code:\r\n\r\n```python\r\nfrom labscript import *\r\nfrom labscript_devices.DummyPseudoclock.labscript_devices import DummyPseudoclock\r\nfrom labscript_devices.SoftwareDevice.labscript_devices import SoftwareDevice\r\n\r\nDummyPseudoclock('pseudoclock')\r\nSoftwareDevice('software_device')\r\n\r\n\r\ndef foo(shot_context, t, arg):\r\n    print(f\"hello, {arg}!\")\r\n\r\n\r\nsoftware_device.add_function('start', foo, 'world')\r\n\r\nstart()\r\nstop(1)\r\n```\r\n\r\nAnd here's the result in BLACS:\r\n\r\n![software_device.png](https://bitbucket.org/repo/7EEj84e/images/3545842253-software_device.png)", "title": "Added a 'device' that runs arbitrary functions before/after the experiment.", "destination": {"commit": {"hash": "8c9f9c881048", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/8c9f9c881048.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/8c9f9c881048"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "329a5506e519", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/329a5506e519"}, "html": {"href": "#!/cbillington/labscript_devices/commits/329a5506e519"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "SoftwareDevice"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-11-15T02:45:45.318365+00:00"}, "pull_request": {"type": "pullrequest", "id": 86, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/86"}}, "title": "Added a 'device' that runs arbitrary functions before/after the experiment."}}, {"update": {"description": "Added a labscript device called `SoftwareDevice`, that you attach functions to\r\nto run during `transition_to_buffered` or `transition_to_static`\r\n\r\nSyntax is such that the device can in future be extended to run functions\r\nin the middle of the experiment in software time, but that is not yet\r\nimplemented.\r\n\r\nAlso still possibly todo is to save results of the functions, including whether they raise\r\nexceptions or not. An option for whether to stop on exception or not should\r\nalso be able to be set as a device property, so that failing functions don't\r\nstop the experiment from cycling if you don't want them to.\r\n\r\nThe use case for implementing this is that we want to have some important analysis results influence the very next shot, specifically, a measurement of how out of resonance we are for a microwave transition to feed forward to magnetic field cancellation in the next shot. This is important as the field drifts throughout the day. Allowing lyse to do the analysis is not ideal since we don't want the experiment to stop cycling because we are messing around with lyse - lyse analysis should be asynchronous with the experiment most of the time.\r\n\r\nTo that end a function attached to a \"software device\" will do some image analysis at the end of each shot, and update runmanager globals using the `runmanager.remote` API. Yet to come is a \"just in time\" compilation mode for runmanager, where it does not compile shots until BLACS is ready to run them. This will ensure the new globals are used in the very next shot.\r\n\r\nThere is nothing stopping a function run by the SoftwareDevice from instantiating a `lyse.Run` and saving its results under some group name (which will have to be set manually via `Run.set_group()`), such that lyse routines can use the results later.\r\n\r\nHere's what it looks like in labscript code:\r\n\r\n```python\r\nfrom labscript import *\r\nfrom labscript_devices.DummyPseudoclock.labscript_devices import DummyPseudoclock\r\nfrom labscript_devices.SoftwareDevice.labscript_devices import SoftwareDevice\r\n\r\nDummyPseudoclock('pseudoclock')\r\nSoftwareDevice('software_device')\r\n\r\n\r\ndef foo(shot_context, t, arg):\r\n    print(f\"hello, {arg}!\")\r\n\r\n\r\nsoftware_device.add_function('start', foo, 'world')\r\n\r\nstart()\r\nstop(1)\r\n```\r\n\r\nAnd here's the result in BLACS:\r\n\r\n![software_device.png](https://bitbucket.org/repo/7EEj84e/images/3545842253-software_device.png)", "title": "Added a 'device' that runs arbitrary functions before/after the experiment.", "destination": {"commit": {"hash": "8c9f9c881048", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/8c9f9c881048.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/8c9f9c881048"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "b8467733be9b", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/b8467733be9b"}, "html": {"href": "#!/cbillington/labscript_devices/commits/b8467733be9b"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "SoftwareDevice"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-11-15T02:36:28.156893+00:00"}, "pull_request": {"type": "pullrequest", "id": 86, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/86"}}, "title": "Added a 'device' that runs arbitrary functions before/after the experiment."}}, {"update": {"description": "Added a labscript device called `SoftwareDevice`, that you attach functions to\r\nto run during `transition_to_buffered` or `transition_to_static`\r\n\r\nSyntax is such that the device can in future be extended to run functions\r\nin the middle of the experiment in software time, but that is not yet\r\nimplemented.\r\n\r\nAlso still possibly todo is to save results of the functions, including whether they raise\r\nexceptions or not. An option for whether to stop on exception or not should\r\nalso be able to be set as a device property, so that failing functions don't\r\nstop the experiment from cycling if you don't want them to.\r\n\r\nThe use case for implementing this is that we want to have some important analysis results influence the very next shot, specifically, a measurement of how out of resonance we are for a microwave transition to feed forward to magnetic field cancellation in the next shot. This is important as the field drifts throughout the day. Allowing lyse to do the analysis is not ideal since we don't want the experiment to stop cycling because we are messing around with lyse - lyse analysis should be asynchronous with the experiment most of the time.\r\n\r\nTo that end a function attached to a \"software device\" will do some image analysis at the end of each shot, and update runmanager globals using the `runmanager.remote` API. Yet to come is a \"just in time\" compilation mode for runmanager, where it does not compile shots until BLACS is ready to run them. This will ensure the new globals are used in the very next shot.\r\n\r\nThere is nothing stopping a function run by the SoftwareDevice from instantiating a `lyse.Run` and saving its results under some group name (which will have to be set manually via `Run.set_group()`), such that lyse routines can use the results later.\r\n\r\nHere's what it looks like in labscript code:\r\n\r\n```python\r\nfrom labscript import *\r\nfrom labscript_devices.DummyPseudoclock.labscript_devices import DummyPseudoclock\r\nfrom labscript_devices.SoftwareDevice.labscript_devices import SoftwareDevice\r\n\r\nDummyPseudoclock('pseudoclock')\r\nSoftwareDevice('software_device')\r\n\r\n\r\ndef foo(shot_context, t, arg):\r\n    print(f\"hello, {arg}!\")\r\n\r\n\r\nsoftware_device.add_function('start', foo, 'world')\r\n\r\nstart()\r\nstop(1)\r\n```\r\n\r\nAnd here's the result in BLACS:\r\n\r\n![software_device.png](https://bitbucket.org/repo/7EEj84e/images/3545842253-software_device.png)", "title": "Added a 'device' that runs arbitrary functions before/after the experiment.", "destination": {"commit": {"hash": "8c9f9c881048", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/commit/8c9f9c881048.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/commits/8c9f9c881048"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices.json"}, "html": {"href": "#!/labscript_suite/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{30c94cb1-feec-4534-8885-92452023c9c9}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "labscript_suite/labscript_devices", "uuid": "{30c94cb1-feec-4534-8885-92452023c9c9}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "b8467733be9b", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices/commit/b8467733be9b"}, "html": {"href": "#!/cbillington/labscript_devices/commits/b8467733be9b"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_devices"}, "html": {"href": "#!/cbillington/labscript_devices"}, "avatar": {"href": "data/bytebucket.org/ravatar/{a2db461e-24e6-495e-a15d-8b80435f721e}ts=python"}}, "type": "repository", "name": "labscript_devices", "full_name": "cbillington/labscript_devices", "uuid": "{a2db461e-24e6-495e-a15d-8b80435f721e}"}, "branch": {"name": "SoftwareDevice"}}, "state": "OPEN", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "date": "2019-11-15T02:36:28.107812+00:00"}, "pull_request": {"type": "pullrequest", "id": 86, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_devices/pullrequests/86.json"}, "html": {"href": "#!/labscript_suite/labscript_devices/pull-requests/86"}}, "title": "Added a 'device' that runs arbitrary functions before/after the experiment."}}]}