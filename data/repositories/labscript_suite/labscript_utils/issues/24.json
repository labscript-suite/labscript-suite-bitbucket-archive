{"priority": "major", "kind": "bug", "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils.json"}, "html": {"href": "#!/labscript_suite/labscript_utils"}, "avatar": {"href": "data/bytebucket.org/ravatar/{68347210-fb1e-4b58-86c0-bd2c04396e63}ts=249922"}}, "type": "repository", "name": "labscript_utils", "full_name": "labscript_suite/labscript_utils", "uuid": "{68347210-fb1e-4b58-86c0-bd2c04396e63}"}, "links": {"attachments": {"href": "data/repositories/labscript_suite/labscript_utils/issues/24/attachments_page=1.json"}, "self": {"href": "data/repositories/labscript_suite/labscript_utils/issues/24.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_utils/issues/24/watch"}, "comments": {"href": "data/repositories/labscript_suite/labscript_utils/issues/24/comments_page=1.json"}, "html": {"href": "#!/labscript_suite/labscript_utils/issues/24/cant-save-integer-connection-table"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_utils/issues/24/vote"}}, "reporter": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "title": "Can't save integer connection table properties that come from globals", "component": null, "votes": 0, "watches": 1, "content": {"raw": "In Python 3.7 with latest numpy (observed on numpy 1.16.3), one cannot save a connection table attribute or unit calibration parameter that is an integer, and that has been through a HDF5 file as a global. JSON serialisation chokes on the integer, saying it can't serialise it. Here is a minimal breaking example:\r\n\r\n```python\r\nimport json\r\nimport h5py\r\nwith h5py.File('test.h5', 'w') as f:\r\n    f.attrs['x'] = 5\r\n    json.dumps(dict(f.attrs))\r\n```\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"260.py\", line 5, in <module>\r\n    print(json.dumps(dict(f.attrs)))\r\n  File \"/usr/lib/python3.7/json/__init__.py\", line 231, in dumps\r\n    return _default_encoder.encode(obj)\r\n  File \"/usr/lib/python3.7/json/encoder.py\", line 199, in encode\r\n    chunks = self.iterencode(o, _one_shot=True)\r\n  File \"/usr/lib/python3.7/json/encoder.py\", line 257, in iterencode\r\n    return _iterencode(o, 0)\r\n  File \"/usr/lib/python3.7/json/encoder.py\", line 179, in default\r\n    raise TypeError(f'Object of type {o.__class__.__name__} '\r\nTypeError: Object of type int64 is not JSON serializable\r\n```\r\n\r\nOf course JSON can serialise normal Python integers, but having been through the HDF5 file, the integer became a np.int32. So an even more minimal breaking example might be:\r\n\r\n```python\r\nimport json\r\nimport numpy as np\r\njson.dumps([np.int32(5)])\r\n```\r\n\r\nAnd it doesn't matter if it is a np.int32 or np.int64, both break .\r\n\r\nThis works fine in Python 2 with the same numpy version and works if you convert the integer to a float instead. Looks like a regression in either Python or numpy, I'm not sure which. But I'll see if I can figure out which to report a bug to. We could work around it in labscript suite code, but should not bother if it is to be imminently fixed upstream.", "markup": "markdown", "html": "<p>In Python 3.7 with latest numpy (observed on numpy 1.16.3), one cannot save a connection table attribute or unit calibration parameter that is an integer, and that has been through a HDF5 file as a global. JSON serialisation chokes on the integer, saying it can't serialise it. Here is a minimal breaking example:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">json</span>\n<span class=\"kn\">import</span> <span class=\"nn\">h5py</span>\n<span class=\"k\">with</span> <span class=\"n\">h5py</span><span class=\"o\">.</span><span class=\"n\">File</span><span class=\"p\">(</span><span class=\"s1\">&#39;test.h5&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;w&#39;</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">f</span><span class=\"p\">:</span>\n    <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">attrs</span><span class=\"p\">[</span><span class=\"s1\">&#39;x&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>\n    <span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">dumps</span><span class=\"p\">(</span><span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">attrs</span><span class=\"p\">))</span>\n</pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span>Traceback (most recent call last):\n  File &quot;260.py&quot;, line 5, in &lt;module&gt;\n    print(json.dumps(dict(f.attrs)))\n  File &quot;/usr/lib/python3.7/json/__init__.py&quot;, line 231, in dumps\n    return _default_encoder.encode(obj)\n  File &quot;/usr/lib/python3.7/json/encoder.py&quot;, line 199, in encode\n    chunks = self.iterencode(o, _one_shot=True)\n  File &quot;/usr/lib/python3.7/json/encoder.py&quot;, line 257, in iterencode\n    return _iterencode(o, 0)\n  File &quot;/usr/lib/python3.7/json/encoder.py&quot;, line 179, in default\n    raise TypeError(f&#39;Object of type {o.__class__.__name__} &#39;\nTypeError: Object of type int64 is not JSON serializable\n</pre></div>\n\n\n<p>Of course JSON can serialise normal Python integers, but having been through the HDF5 file, the integer became a np.int32. So an even more minimal breaking example might be:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">json</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"kn\">as</span> <span class=\"nn\">np</span>\n<span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">dumps</span><span class=\"p\">([</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">int32</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">)])</span>\n</pre></div>\n\n\n<p>And it doesn't matter if it is a np.int32 or np.int64, both break .</p>\n<p>This works fine in Python 2 with the same numpy version and works if you convert the integer to a float instead. Looks like a regression in either Python or numpy, I'm not sure which. But I'll see if I can figure out which to report a bug to. We could work around it in labscript suite code, but should not bother if it is to be imminently fixed upstream.</p>", "type": "rendered"}, "assignee": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "state": "resolved", "version": null, "edited_on": null, "created_on": "2019-05-14T14:41:35.093619+00:00", "milestone": null, "updated_on": "2019-05-20T14:55:57.014843+00:00", "type": "issue", "id": 24}