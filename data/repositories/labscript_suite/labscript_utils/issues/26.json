{"priority": "minor", "kind": "enhancement", "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils.json"}, "html": {"href": "#!/labscript_suite/labscript_utils"}, "avatar": {"href": "data/bytebucket.org/ravatar/{68347210-fb1e-4b58-86c0-bd2c04396e63}ts=249922"}}, "type": "repository", "name": "labscript_utils", "full_name": "labscript_suite/labscript_utils", "uuid": "{68347210-fb1e-4b58-86c0-bd2c04396e63}"}, "links": {"attachments": {"href": "data/repositories/labscript_suite/labscript_utils/issues/26/attachments_page=1.json"}, "self": {"href": "data/repositories/labscript_suite/labscript_utils/issues/26.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_utils/issues/26/watch"}, "comments": {"href": "data/repositories/labscript_suite/labscript_utils/issues/26/comments_page=1.json"}, "html": {"href": "#!/labscript_suite/labscript_utils/issues/26/add-enum-control-widget"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_utils/issues/26/vote"}}, "reporter": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "title": "Add enum control widget", "component": null, "votes": 0, "watches": 1, "content": {"raw": "When programming devices with physical front panels, it is often the case that a control I\u2019d like to manipulate with labscript \\(at a static level\\) is best described as an enum \\(looking at you SRS\\). I propose we add a basic combobox based widget \\(like AnalogOutput or DigitalOutput\\) that can be stuffed with a dictionary of labels and programming values at runtime from the device blacs tab. These controls do not always have an associated output or input class associated with them, rather being a device level setting that influences general operation.\r\n\r\nI\u2019m happy to work on this one since we have a current need, but I\u2019d like a bit of guidance on how to integrate with the rest of the BLACS auto-creation of widgets magic. If I have understood correctly, the current paradigm for an AnalogOutput widget is to have the device\\_tab call a widget auto-populating function which creates AnalogOutput widgets which in turn links to the labscript AO class. This ensures settings from the connection table and blacs tab can configure each output correctly. What is the best way to modify this paradigm?\r\n\r\nMy initial thought is to drop auto-populating in the blacs\\_tab in favor writing something akin to ddsoutput.py for any \\(often conglomerate\\) control that would be device specific and kept in the device folder. I\u2019m a little less clear on how to handle enum settings at the AO class level. Should I create a commensurate class that behaves as a StaticAO with discrete values set by dictionary?\r\n\r\nAnyway, this is starting to get long and likely confusing since I don\u2019t really know what I\u2019m talking about. So I\u2019ll end by describing what our need is and what I would like to see.\r\n\r\nWe have an RF Signal Generator \\(SRS SG386\\) that has modulation controls. The controllable options include: Enable \\(on/off\\), Type \\(AM/FM/PM/Sweep\\), Function \\(Sine, Triangle, Square, External\\), Deviation \\(float\\), Depth \\(float\\), and External Coupling \\(AC/DC\\). Since all of these controls are inter-related and operate on the same function, it would be nice to create a monolithic control widget that groups them together in the BLACS tab and allows user control while enforcing allowable settings. Slightly beyond the scope of this discussion, when writing an experiment script; having corresponding SG386.mod\\(Enable\\) and/or SG386.mod.Depth\\(1MHz\\) commands would be great. Getting started, StaticAO/DO covers the boolean and float options just fine. But I need an enum for everything else.", "markup": "markdown", "html": "<p>When programming devices with physical front panels, it is often the case that a control I\u2019d like to manipulate with labscript (at a static level) is best described as an enum (looking at you SRS). I propose we add a basic combobox based widget (like AnalogOutput or DigitalOutput) that can be stuffed with a dictionary of labels and programming values at runtime from the device blacs tab. These controls do not always have an associated output or input class associated with them, rather being a device level setting that influences general operation.</p>\n<p>I\u2019m happy to work on this one since we have a current need, but I\u2019d like a bit of guidance on how to integrate with the rest of the BLACS auto-creation of widgets magic. If I have understood correctly, the current paradigm for an AnalogOutput widget is to have the device_tab call a widget auto-populating function which creates AnalogOutput widgets which in turn links to the labscript AO class. This ensures settings from the connection table and blacs tab can configure each output correctly. What is the best way to modify this paradigm?</p>\n<p>My initial thought is to drop auto-populating in the blacs_tab in favor writing something akin to ddsoutput.py for any (often conglomerate) control that would be device specific and kept in the device folder. I\u2019m a little less clear on how to handle enum settings at the AO class level. Should I create a commensurate class that behaves as a StaticAO with discrete values set by dictionary?</p>\n<p>Anyway, this is starting to get long and likely confusing since I don\u2019t really know what I\u2019m talking about. So I\u2019ll end by describing what our need is and what I would like to see.</p>\n<p>We have an RF Signal Generator (SRS SG386) that has modulation controls. The controllable options include: Enable (on/off), Type (AM/FM/PM/Sweep), Function (Sine, Triangle, Square, External), Deviation (float), Depth (float), and External Coupling (AC/DC). Since all of these controls are inter-related and operate on the same function, it would be nice to create a monolithic control widget that groups them together in the BLACS tab and allows user control while enforcing allowable settings. Slightly beyond the scope of this discussion, when writing an experiment script; having corresponding SG386.mod(Enable) and/or SG386.mod.Depth(1MHz) commands would be great. Getting started, StaticAO/DO covers the boolean and float options just fine. But I need an enum for everything else.</p>", "type": "rendered"}, "assignee": null, "state": "new", "version": null, "edited_on": null, "created_on": "2019-09-24T14:39:17.592079+00:00", "milestone": null, "updated_on": "2019-10-03T16:22:41.623248+00:00", "type": "issue", "id": 26}