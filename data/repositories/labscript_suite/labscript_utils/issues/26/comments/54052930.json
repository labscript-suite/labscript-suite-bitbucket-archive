{"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/issues/26/comments/54052930.json"}, "html": {"href": "#!/labscript_suite/labscript_utils/issues/26#comment-54052930"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/issues/26.json"}}, "type": "issue", "id": 26, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils.json"}, "html": {"href": "#!/labscript_suite/labscript_utils"}, "avatar": {"href": "data/bytebucket.org/ravatar/{68347210-fb1e-4b58-86c0-bd2c04396e63}ts=249922"}}, "type": "repository", "name": "labscript_utils", "full_name": "labscript_suite/labscript_utils", "uuid": "{68347210-fb1e-4b58-86c0-bd2c04396e63}"}, "title": "Add enum control widget"}, "content": {"raw": "Hi David,\n\nI think in general adding a enum output type makes sense \\(but not sure if it is what you want for this device or not\\)\n\nHowever, if these are just configuration settings, they probably shouldn\u2019t be integrated with the output types of BLACS and labscript. In such a case I would probably suggest just adding additional widgets to your device\u2019s BLACS tab as, for example, the PulseBlaster does for status widgets.\n\nBut, assuming it makes sense to go down the route of integrating it as an \u201coutput type\u201d, here is the information you need to know!\n\n**BLACS**  \nThe fundamental level is the AO/DO/DDS/Image output classes. Instances of these we call \u201coutput objects\u201d and are ultimately what store the front panel value, interact with saving/restoring settings and trigger events to reprogram the device via the statemachine and worker process. Think of these as a datastore \\(one per output channel\\). They are created by the `DeviceTab.create_XX_outputs` methods.\n\nWidgets can then be created and linked to the output object. We provide the `DeviceTab.auto_create_widgets` and `AO.create_widget` \\(and equivalent for the other classes\\) methods to streamline this, but actually any appropriate widget can be connected in to the output object \\(datastore\\), see the `add_widget` method of each output class. A BLACS tab can use whatever method it likes to create the widget, it just needs to call appropriate methods to link the widget to the output object. Each output object can have an arbitrary number of widgets connected to it, and they\u2019ll all update together when one changes. \n\nWe then have a method to automatically place widgets in collapsible groups \\(`DeviceTab.auto_place_widgets`\\). This is completely optional as you can place widgets in the tab however you like \\(or do both like the PulseBlaster\\).\n\nSo for your situation, you probably want to create an `Enum` output class in [output\\_classes.py](#!/labscript_suite/blacs/src/default/output_classes.py), update `DeviceTab` to handle the new output type. You can then opt to create widgets manually, or using the newly created automatic methods, and place them in a custom layout of your choosing for a particular device by bypassing `auto_place_widgets`.\n\n**labscript**  \nOn the labscript side you will want to subclass `Output` and create an `EnumOut` and `StaticEnumOut` classes. These would be similar to `DigitalOut` I guess, but have more states.\n\n\u200c\n\nTo be honest I\u2019m not sure if it makes sense to treat them as output types or not\u2026it almost seems like not \\(they seem more like labscript device instantiation arguments?\\), but in that case BLACS has no machinery for allowing device configuration to be modified in manual mode. It all has to be implemented separately in each device tab, which doesn\u2019t seem ideal.", "markup": "markdown", "html": "<p>Hi David,</p>\n<p>I think in general adding a enum output type makes sense (but not sure if it is what you want for this device or not)</p>\n<p>However, if these are just configuration settings, they probably shouldn\u2019t be integrated with the output types of BLACS and labscript. In such a case I would probably suggest just adding additional widgets to your device\u2019s BLACS tab as, for example, the PulseBlaster does for status widgets.</p>\n<p>But, assuming it makes sense to go down the route of integrating it as an \u201coutput type\u201d, here is the information you need to know!</p>\n<p><strong>BLACS</strong><br />\nThe fundamental level is the AO/DO/DDS/Image output classes. Instances of these we call \u201coutput objects\u201d and are ultimately what store the front panel value, interact with saving/restoring settings and trigger events to reprogram the device via the statemachine and worker process. Think of these as a datastore (one per output channel). They are created by the <code>DeviceTab.create_XX_outputs</code> methods.</p>\n<p>Widgets can then be created and linked to the output object. We provide the <code>DeviceTab.auto_create_widgets</code> and <code>AO.create_widget</code> (and equivalent for the other classes) methods to streamline this, but actually any appropriate widget can be connected in to the output object (datastore), see the <code>add_widget</code> method of each output class. A BLACS tab can use whatever method it likes to create the widget, it just needs to call appropriate methods to link the widget to the output object. Each output object can have an arbitrary number of widgets connected to it, and they\u2019ll all update together when one changes. </p>\n<p>We then have a method to automatically place widgets in collapsible groups (<code>DeviceTab.auto_place_widgets</code>). This is completely optional as you can place widgets in the tab however you like (or do both like the PulseBlaster).</p>\n<p>So for your situation, you probably want to create an <code>Enum</code> output class in <a data-is-external-link=\"true\" href=\"#!/labscript_suite/blacs/src/default/output_classes.py\" rel=\"nofollow\">output_classes.py</a>, update <code>DeviceTab</code> to handle the new output type. You can then opt to create widgets manually, or using the newly created automatic methods, and place them in a custom layout of your choosing for a particular device by bypassing <code>auto_place_widgets</code>.</p>\n<p><strong>labscript</strong><br />\nOn the labscript side you will want to subclass <code>Output</code> and create an <code>EnumOut</code> and <code>StaticEnumOut</code> classes. These would be similar to <code>DigitalOut</code> I guess, but have more states.</p>\n<p>\u200c</p>\n<p>To be honest I\u2019m not sure if it makes sense to treat them as output types or not\u2026it almost seems like not (they seem more like labscript device instantiation arguments?), but in that case BLACS has no machinery for allowing device configuration to be modified in manual mode. It all has to be implemented separately in each device tab, which doesn\u2019t seem ideal.</p>", "type": "rendered"}, "created_on": "2019-09-24T15:27:36.557127+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{0147401a-13ed-4e39-a0d0-63108c18738b}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D"}, "html": {"href": "https://bitbucket.org/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/fa0698c306b3470c00717c146b5296e9d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "philipstarkey", "type": "user", "account_id": "557058:2f99420c-1dbd-4837-952c-82c421b8fbdd"}, "updated_on": null, "type": "issue_comment", "id": 54052930}