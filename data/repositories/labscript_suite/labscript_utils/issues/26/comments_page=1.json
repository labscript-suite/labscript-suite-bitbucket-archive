{"pagelen": 100, "values": [{"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/issues/26/comments/54052930.json"}, "html": {"href": "#!/labscript_suite/labscript_utils/issues/26#comment-54052930"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/issues/26.json"}}, "type": "issue", "id": 26, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils.json"}, "html": {"href": "#!/labscript_suite/labscript_utils"}, "avatar": {"href": "data/bytebucket.org/ravatar/{68347210-fb1e-4b58-86c0-bd2c04396e63}ts=249922"}}, "type": "repository", "name": "labscript_utils", "full_name": "labscript_suite/labscript_utils", "uuid": "{68347210-fb1e-4b58-86c0-bd2c04396e63}"}, "title": "Add enum control widget"}, "content": {"raw": "Hi David,\n\nI think in general adding a enum output type makes sense \\(but not sure if it is what you want for this device or not\\)\n\nHowever, if these are just configuration settings, they probably shouldn\u2019t be integrated with the output types of BLACS and labscript. In such a case I would probably suggest just adding additional widgets to your device\u2019s BLACS tab as, for example, the PulseBlaster does for status widgets.\n\nBut, assuming it makes sense to go down the route of integrating it as an \u201coutput type\u201d, here is the information you need to know!\n\n**BLACS**  \nThe fundamental level is the AO/DO/DDS/Image output classes. Instances of these we call \u201coutput objects\u201d and are ultimately what store the front panel value, interact with saving/restoring settings and trigger events to reprogram the device via the statemachine and worker process. Think of these as a datastore \\(one per output channel\\). They are created by the `DeviceTab.create_XX_outputs` methods.\n\nWidgets can then be created and linked to the output object. We provide the `DeviceTab.auto_create_widgets` and `AO.create_widget` \\(and equivalent for the other classes\\) methods to streamline this, but actually any appropriate widget can be connected in to the output object \\(datastore\\), see the `add_widget` method of each output class. A BLACS tab can use whatever method it likes to create the widget, it just needs to call appropriate methods to link the widget to the output object. Each output object can have an arbitrary number of widgets connected to it, and they\u2019ll all update together when one changes. \n\nWe then have a method to automatically place widgets in collapsible groups \\(`DeviceTab.auto_place_widgets`\\). This is completely optional as you can place widgets in the tab however you like \\(or do both like the PulseBlaster\\).\n\nSo for your situation, you probably want to create an `Enum` output class in [output\\_classes.py](#!/labscript_suite/blacs/src/default/output_classes.py), update `DeviceTab` to handle the new output type. You can then opt to create widgets manually, or using the newly created automatic methods, and place them in a custom layout of your choosing for a particular device by bypassing `auto_place_widgets`.\n\n**labscript**  \nOn the labscript side you will want to subclass `Output` and create an `EnumOut` and `StaticEnumOut` classes. These would be similar to `DigitalOut` I guess, but have more states.\n\n\u200c\n\nTo be honest I\u2019m not sure if it makes sense to treat them as output types or not\u2026it almost seems like not \\(they seem more like labscript device instantiation arguments?\\), but in that case BLACS has no machinery for allowing device configuration to be modified in manual mode. It all has to be implemented separately in each device tab, which doesn\u2019t seem ideal.", "markup": "markdown", "html": "<p>Hi David,</p>\n<p>I think in general adding a enum output type makes sense (but not sure if it is what you want for this device or not)</p>\n<p>However, if these are just configuration settings, they probably shouldn\u2019t be integrated with the output types of BLACS and labscript. In such a case I would probably suggest just adding additional widgets to your device\u2019s BLACS tab as, for example, the PulseBlaster does for status widgets.</p>\n<p>But, assuming it makes sense to go down the route of integrating it as an \u201coutput type\u201d, here is the information you need to know!</p>\n<p><strong>BLACS</strong><br />\nThe fundamental level is the AO/DO/DDS/Image output classes. Instances of these we call \u201coutput objects\u201d and are ultimately what store the front panel value, interact with saving/restoring settings and trigger events to reprogram the device via the statemachine and worker process. Think of these as a datastore (one per output channel). They are created by the <code>DeviceTab.create_XX_outputs</code> methods.</p>\n<p>Widgets can then be created and linked to the output object. We provide the <code>DeviceTab.auto_create_widgets</code> and <code>AO.create_widget</code> (and equivalent for the other classes) methods to streamline this, but actually any appropriate widget can be connected in to the output object (datastore), see the <code>add_widget</code> method of each output class. A BLACS tab can use whatever method it likes to create the widget, it just needs to call appropriate methods to link the widget to the output object. Each output object can have an arbitrary number of widgets connected to it, and they\u2019ll all update together when one changes. </p>\n<p>We then have a method to automatically place widgets in collapsible groups (<code>DeviceTab.auto_place_widgets</code>). This is completely optional as you can place widgets in the tab however you like (or do both like the PulseBlaster).</p>\n<p>So for your situation, you probably want to create an <code>Enum</code> output class in <a data-is-external-link=\"true\" href=\"#!/labscript_suite/blacs/src/default/output_classes.py\" rel=\"nofollow\">output_classes.py</a>, update <code>DeviceTab</code> to handle the new output type. You can then opt to create widgets manually, or using the newly created automatic methods, and place them in a custom layout of your choosing for a particular device by bypassing <code>auto_place_widgets</code>.</p>\n<p><strong>labscript</strong><br />\nOn the labscript side you will want to subclass <code>Output</code> and create an <code>EnumOut</code> and <code>StaticEnumOut</code> classes. These would be similar to <code>DigitalOut</code> I guess, but have more states.</p>\n<p>\u200c</p>\n<p>To be honest I\u2019m not sure if it makes sense to treat them as output types or not\u2026it almost seems like not (they seem more like labscript device instantiation arguments?), but in that case BLACS has no machinery for allowing device configuration to be modified in manual mode. It all has to be implemented separately in each device tab, which doesn\u2019t seem ideal.</p>", "type": "rendered"}, "created_on": "2019-09-24T15:27:36.557127+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{0147401a-13ed-4e39-a0d0-63108c18738b}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D"}, "html": {"href": "https://bitbucket.org/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/fa0698c306b3470c00717c146b5296e9d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "philipstarkey", "type": "user", "account_id": "557058:2f99420c-1dbd-4837-952c-82c421b8fbdd"}, "updated_on": null, "type": "issue_comment", "id": 54052930}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/issues/26/comments/54061760.json"}, "html": {"href": "#!/labscript_suite/labscript_utils/issues/26#comment-54061760"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/issues/26.json"}}, "type": "issue", "id": 26, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils.json"}, "html": {"href": "#!/labscript_suite/labscript_utils"}, "avatar": {"href": "data/bytebucket.org/ravatar/{68347210-fb1e-4b58-86c0-bd2c04396e63}ts=249922"}}, "type": "repository", "name": "labscript_utils", "full_name": "labscript_suite/labscript_utils", "uuid": "{68347210-fb1e-4b58-86c0-bd2c04396e63}"}, "title": "Add enum control widget"}, "content": {"raw": "> To be honest I\u2019m not sure if it makes sense to treat them as output types or not\u2026it almost seems like not \\(they seem more like labscript device instantiation arguments?\\), but in that case BLACS has no machinery for allowing device configuration to be modified in manual mode. It all has to be implemented separately in each device tab, which doesn\u2019t seem ideal.\n\nThis is exactly the succinct way to say what I\u2019m looking for. I don\u2019t really need an output, I just want manual control of of some settings without needing to recompile the connectiontable or running a complete shot nor writing everything from scratch. I also like the idea of separating a little from typical instantiation arguments since it makes smart programming those settings a bit more consistent with typical outputs. I\u2019ve already done all this once \\(an SRS lock-in amp\\) and it is really tedious with plenty of boiler-plate that should be recycled.\n\nMight there be room to make a new type of labscript class that is controlled like an output in the BLACS tab but links directly to \u201cdevice instantiation objects\u201d \\(not \u201coutput objects\u201d\\) as far as shots and h5files are concerned? I\u2019m not entirely sure how to think about structure or its implementation but if I\u2019m going to write something from scratch anyway, might as well try to write what I need instead of a kludging on to the output system.", "markup": "markdown", "html": "<blockquote>\n<p>To be honest I\u2019m not sure if it makes sense to treat them as output types or not\u2026it almost seems like not (they seem more like labscript device instantiation arguments?), but in that case BLACS has no machinery for allowing device configuration to be modified in manual mode. It all has to be implemented separately in each device tab, which doesn\u2019t seem ideal.</p>\n</blockquote>\n<p>This is exactly the succinct way to say what I\u2019m looking for. I don\u2019t really need an output, I just want manual control of of some settings without needing to recompile the connectiontable or running a complete shot nor writing everything from scratch. I also like the idea of separating a little from typical instantiation arguments since it makes smart programming those settings a bit more consistent with typical outputs. I\u2019ve already done all this once (an SRS lock-in amp) and it is really tedious with plenty of boiler-plate that should be recycled.</p>\n<p>Might there be room to make a new type of labscript class that is controlled like an output in the BLACS tab but links directly to \u201cdevice instantiation objects\u201d (not \u201coutput objects\u201d) as far as shots and h5files are concerned? I\u2019m not entirely sure how to think about structure or its implementation but if I\u2019m going to write something from scratch anyway, might as well try to write what I need instead of a kludging on to the output system.</p>", "type": "rendered"}, "created_on": "2019-09-24T21:36:22.201949+00:00", "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "updated_on": null, "type": "issue_comment", "id": 54061760}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/issues/26/comments/54067095.json"}, "html": {"href": "#!/labscript_suite/labscript_utils/issues/26#comment-54067095"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/issues/26.json"}}, "type": "issue", "id": 26, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils.json"}, "html": {"href": "#!/labscript_suite/labscript_utils"}, "avatar": {"href": "data/bytebucket.org/ravatar/{68347210-fb1e-4b58-86c0-bd2c04396e63}ts=249922"}}, "type": "repository", "name": "labscript_utils", "full_name": "labscript_suite/labscript_utils", "uuid": "{68347210-fb1e-4b58-86c0-bd2c04396e63}"}, "title": "Add enum control widget"}, "content": {"raw": "Cool, so I\u2019ve had a bit of a think about what we could do\u2026this may not be well thought through so please adjust as it makes sense!\n\nWe currently have two categories of device properties:\n\n* Connection table properties\n* Device properties\n\nThe connection table properties should be those that cannot be configured shot-to-shot. This is why a recompile of the connection table is needed, along with a restart of BLACS. Usually they are device initialisation settings \\(hence the need to restart BLACS\\).\n\nThe device properties are those that can be changed shot-to-shot, for example data acquisition rates.\n\nIt seems to me that the type of properties you want to change on the front panel are going to match the device properties.\n\n\u200c\n\nI thus propose that we implement something in BLACS device tabs to:\n\n* Display read-only versions of the connection table properties\n* Display editable versions of the device properties.\n\nThis will require labscript device code to define meta-data about each property \\(so that we can render appropriate widgets in BLACS and do appropriate type checking in labscript\\). Off the top of my head I think this would be:\n\n* property name\n* default value\n* type\n* list of allowed values or range\n\nWe \\(a long time ago - when we first created the labscript\\_devices library from code that existed in BLACS/labscript\\) planned to have a class for each device that just held device specifications. For example, clock frequencies or update rates, number of output channels, etc. Basically the labscript class attributes and the dictionaries in the BLACS GUI class that contain channel configuration information were going to live in a single class so that we could reuse then in labscript/ruviewer/BLACS without redefining quantities multiple times \\(and without having to import the classes meant for other components\\). We didn\u2019t end up doing this because we \\(a\\) focused on other more important things and \\(b\\) had to import all the classes in every program anyway due to the file structure. The latter is of course now fixed!\n\nSo I propose:\n\n* that the meta-data about device/connection table properties be placed in a new class, along with any other device specification information collected from the device classes,\n* that we update labscript to use this information for automatic type checking and maybe:\n\n    * remove the need to explicitly specify the allowed kwargs to the `__init__` method of the labscript class\n    * integrate \\(or supersede?\\) the `@set_passed_properties` decorator\n    \n* that we add to `DeviceTab` functionality to automatically display editable widgets for device properties \\(and read-only display of connection table properties\\). This would require:\n\n    * parsing the property meta-data\n    * probably re-using the existing output classes \\(but just not storing them in the same lists as actual outputs so they aren\u2019t sent to `Worker.program_manual`\\) and passing in a different function for `self.program_device` \\(see below\\)\n    * creating an additional state machine method to tell the worker process when to reprogram the device properties in manual mode \\(similar to `DeviceTab.program_device`\\)\n    * an additional worker process method similar to `Worker.program_manual` that handles updating a devices configurable properties.\n    * working out how best to display this information in a tab by default, while also allowing subclasses to override how it is displayed \\(much like they can with output widgets\\).\n    \n\nA further extension of this could be to solve [labscript issue #49](#!/labscript_suite/labscript/issues/49/allow-the-set_passed_properties-decorator) and extend the above proposal to allow properties to be associated with device channels rather than just devices. That\u2019s probably beyond the scope of this though \\(just thought I\u2019d mention it\\) and would require a tonne more work I think.\n\nThoughts @{557058:411f7712-e1fa-438c-b578-0359da2d9f06} and @{557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3} ?\n\n\u200c", "markup": "markdown", "html": "<p>Cool, so I\u2019ve had a bit of a think about what we could do\u2026this may not be well thought through so please adjust as it makes sense!</p>\n<p>We currently have two categories of device properties:</p>\n<ul>\n<li>Connection table properties</li>\n<li>Device properties</li>\n</ul>\n<p>The connection table properties should be those that cannot be configured shot-to-shot. This is why a recompile of the connection table is needed, along with a restart of BLACS. Usually they are device initialisation settings (hence the need to restart BLACS).</p>\n<p>The device properties are those that can be changed shot-to-shot, for example data acquisition rates.</p>\n<p>It seems to me that the type of properties you want to change on the front panel are going to match the device properties.</p>\n<p>\u200c</p>\n<p>I thus propose that we implement something in BLACS device tabs to:</p>\n<ul>\n<li>Display read-only versions of the connection table properties</li>\n<li>Display editable versions of the device properties.</li>\n</ul>\n<p>This will require labscript device code to define meta-data about each property (so that we can render appropriate widgets in BLACS and do appropriate type checking in labscript). Off the top of my head I think this would be:</p>\n<ul>\n<li>property name</li>\n<li>default value</li>\n<li>type</li>\n<li>list of allowed values or range</li>\n</ul>\n<p>We (a long time ago - when we first created the labscript_devices library from code that existed in BLACS/labscript) planned to have a class for each device that just held device specifications. For example, clock frequencies or update rates, number of output channels, etc. Basically the labscript class attributes and the dictionaries in the BLACS GUI class that contain channel configuration information were going to live in a single class so that we could reuse then in labscript/ruviewer/BLACS without redefining quantities multiple times (and without having to import the classes meant for other components). We didn\u2019t end up doing this because we (a) focused on other more important things and (b) had to import all the classes in every program anyway due to the file structure. The latter is of course now fixed!</p>\n<p>So I propose:</p>\n<ul>\n<li>that the meta-data about device/connection table properties be placed in a new class, along with any other device specification information collected from the device classes,</li>\n<li>\n<p>that we update labscript to use this information for automatic type checking and maybe:</p>\n<ul>\n<li>remove the need to explicitly specify the allowed kwargs to the <code>__init__</code> method of the labscript class</li>\n<li>integrate (or supersede?) the <code>@set_passed_properties</code> decorator</li>\n</ul>\n</li>\n<li>\n<p>that we add to <code>DeviceTab</code> functionality to automatically display editable widgets for device properties (and read-only display of connection table properties). This would require:</p>\n<ul>\n<li>parsing the property meta-data</li>\n<li>probably re-using the existing output classes (but just not storing them in the same lists as actual outputs so they aren\u2019t sent to <code>Worker.program_manual</code>) and passing in a different function for <code>self.program_device</code> (see below)</li>\n<li>creating an additional state machine method to tell the worker process when to reprogram the device properties in manual mode (similar to <code>DeviceTab.program_device</code>)</li>\n<li>an additional worker process method similar to <code>Worker.program_manual</code> that handles updating a devices configurable properties.</li>\n<li>working out how best to display this information in a tab by default, while also allowing subclasses to override how it is displayed (much like they can with output widgets).</li>\n</ul>\n</li>\n</ul>\n<p>A further extension of this could be to solve <a data-is-external-link=\"true\" href=\"#!/labscript_suite/labscript/issues/49/allow-the-set_passed_properties-decorator\" rel=\"nofollow\">labscript issue #49</a> and extend the above proposal to allow properties to be associated with device channels rather than just devices. That\u2019s probably beyond the scope of this though (just thought I\u2019d mention it) and would require a tonne more work I think.</p>\n<p>Thoughts <span class=\"ap-mention\" data-atlassian-id=\"557058:411f7712-e1fa-438c-b578-0359da2d9f06\">@David Meyer</span> and <span class=\"ap-mention\" data-atlassian-id=\"557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3\">@Chris Billington</span> ?</p>\n<p>\u200c</p>", "type": "rendered"}, "created_on": "2019-09-25T07:35:45.313187+00:00", "user": {"display_name": "Philip Starkey", "uuid": "{0147401a-13ed-4e39-a0d0-63108c18738b}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D"}, "html": {"href": "https://bitbucket.org/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/fa0698c306b3470c00717c146b5296e9d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "philipstarkey", "type": "user", "account_id": "557058:2f99420c-1dbd-4837-952c-82c421b8fbdd"}, "updated_on": null, "type": "issue_comment", "id": 54067095}, {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/issues/26/comments/54191601.json"}, "html": {"href": "#!/labscript_suite/labscript_utils/issues/26#comment-54191601"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/issues/26.json"}}, "type": "issue", "id": 26, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils.json"}, "html": {"href": "#!/labscript_suite/labscript_utils"}, "avatar": {"href": "data/bytebucket.org/ravatar/{68347210-fb1e-4b58-86c0-bd2c04396e63}ts=249922"}}, "type": "repository", "name": "labscript_utils", "full_name": "labscript_suite/labscript_utils", "uuid": "{68347210-fb1e-4b58-86c0-bd2c04396e63}"}, "title": "Add enum control widget"}, "content": {"raw": "Finally back from vacation and pushed out a paper so I can think on this again.\n\nOverall I think this is a decent framework to start with. A few specific notes to begin:\n\n> that the meta-data about device/connection table properties be placed in a new class, along with any other device specification information collected from the device classes,\n\nWhile initially worried about changing the structure of labscript devices, I\u2019m coming around. It would be nice to have a central location for putting in device information instead of having to spread it over all the files.\n\n> remove the need to explicitly specify the allowed kwargs to the `__init__` method of the labscript class\n\nIs there a way to do this while maintaining syntax helps for what kwargs are expected? It might get tricky to know what options are allowed/mandatory if their definition is hidden in another class that isn\u2019t directly interacted with.\n\n> integrate \\(or supersede?\\) the `@set_passed_properties` decorator\n\nI would personally love to use this as an opportunity to streamline the process of getting connectiontable\\_properties through to the BLACS worker. The current set\\_passed\\_properties \u2192 get\\_properties \u2192 worker\\_init\\_kwargs  method feels a bit clunky and is now particularly annoying since it requires syncing parameter names across three files by hand. It would be nice to mark a property as \u2018saved\u2019 and automatically have all saved properties sent to the BLACS worker.\n\n> working out how best to display this information in a tab by default, while also allowing subclasses to override how it is displayed \\(much like they can with output widgets\\).\n\nWould a pop-up window be a crazy idea here? I don\u2019t really like it but I\u2019m also worried about widget bloat with some devices that can have truly prodigious numbers of device properties. I\u2019m going to guess you\u2019ll say I should just learn to actually use the collapsible groups feature of my tabs?\n\n\u200c\n\nAnyway, I like this approach. My only concern is that I\u2019m not really qualified/have sufficient time to implement it all. If I\u2019m going to have any hope of progress I\u2019ll need some way to break this down into somewhat smaller chunks. My initial thoughts are:\n\n1. Need to pick a device to prototype with. Ideally it is mainlined with mock functionality so it can be well tested even without physical hardware. I believe that leaves the DummyPseudoclock and the IMAQdxCamera. It would be nice to get something like this going for the cameras \\(restarting BLACS to change exposure times isn\u2019t really tenable\\) but it is also a pretty unique implementation and I\u2019m wary to start there. I guess I could do the dummy clock but then there isn\u2019t any physical hardware to readily test with.\n2. Device picked, I would want to start on the meta-data class. It seems the easiest place to start with the fewest changes needed to labscript itself. Will need to decide conventions like meta-class naming and data structure.\n3. Next is the underlying code for handling connection table and device properties. Particularly need to figure out how to attach some kind of output objects. Will likely need to add/modify output objects for the purpose. I\u2019m pretty fuzzy on how this part will actually work in practice, particularly the desired syntax in a shot script for setting a device property. Should it remain in the init method or will the settings be controlled more like static outputs?\n4. Create extra property widgets. Get some framework together for the BLACS tab to connect to the output property objects for display.\n5. Add the BLACS methods for programming the properties. Assuming everything else is working this should be relatively simple.\n\nJust getting this written down has me worried this is going to turn into a pretty time sink for everyone. While I\u2019m always a fan of complete, long-term solutions is this also a moment to reconsider something shorter term instead?", "markup": "markdown", "html": "<p>Finally back from vacation and pushed out a paper so I can think on this again.</p>\n<p>Overall I think this is a decent framework to start with. A few specific notes to begin:</p>\n<blockquote>\n<p>that the meta-data about device/connection table properties be placed in a new class, along with any other device specification information collected from the device classes,</p>\n</blockquote>\n<p>While initially worried about changing the structure of labscript devices, I\u2019m coming around. It would be nice to have a central location for putting in device information instead of having to spread it over all the files.</p>\n<blockquote>\n<p>remove the need to explicitly specify the allowed kwargs to the <code>__init__</code> method of the labscript class</p>\n</blockquote>\n<p>Is there a way to do this while maintaining syntax helps for what kwargs are expected? It might get tricky to know what options are allowed/mandatory if their definition is hidden in another class that isn\u2019t directly interacted with.</p>\n<blockquote>\n<p>integrate (or supersede?) the <code>@set_passed_properties</code> decorator</p>\n</blockquote>\n<p>I would personally love to use this as an opportunity to streamline the process of getting connectiontable_properties through to the BLACS worker. The current set_passed_properties \u2192 get_properties \u2192 worker_init_kwargs  method feels a bit clunky and is now particularly annoying since it requires syncing parameter names across three files by hand. It would be nice to mark a property as \u2018saved\u2019 and automatically have all saved properties sent to the BLACS worker.</p>\n<blockquote>\n<p>working out how best to display this information in a tab by default, while also allowing subclasses to override how it is displayed (much like they can with output widgets).</p>\n</blockquote>\n<p>Would a pop-up window be a crazy idea here? I don\u2019t really like it but I\u2019m also worried about widget bloat with some devices that can have truly prodigious numbers of device properties. I\u2019m going to guess you\u2019ll say I should just learn to actually use the collapsible groups feature of my tabs?</p>\n<p>\u200c</p>\n<p>Anyway, I like this approach. My only concern is that I\u2019m not really qualified/have sufficient time to implement it all. If I\u2019m going to have any hope of progress I\u2019ll need some way to break this down into somewhat smaller chunks. My initial thoughts are:</p>\n<ol>\n<li>Need to pick a device to prototype with. Ideally it is mainlined with mock functionality so it can be well tested even without physical hardware. I believe that leaves the DummyPseudoclock and the IMAQdxCamera. It would be nice to get something like this going for the cameras (restarting BLACS to change exposure times isn\u2019t really tenable) but it is also a pretty unique implementation and I\u2019m wary to start there. I guess I could do the dummy clock but then there isn\u2019t any physical hardware to readily test with.</li>\n<li>Device picked, I would want to start on the meta-data class. It seems the easiest place to start with the fewest changes needed to labscript itself. Will need to decide conventions like meta-class naming and data structure.</li>\n<li>Next is the underlying code for handling connection table and device properties. Particularly need to figure out how to attach some kind of output objects. Will likely need to add/modify output objects for the purpose. I\u2019m pretty fuzzy on how this part will actually work in practice, particularly the desired syntax in a shot script for setting a device property. Should it remain in the init method or will the settings be controlled more like static outputs?</li>\n<li>Create extra property widgets. Get some framework together for the BLACS tab to connect to the output property objects for display.</li>\n<li>Add the BLACS methods for programming the properties. Assuming everything else is working this should be relatively simple.</li>\n</ol>\n<p>Just getting this written down has me worried this is going to turn into a pretty time sink for everyone. While I\u2019m always a fan of complete, long-term solutions is this also a moment to reconsider something shorter term instead?</p>", "type": "rendered"}, "created_on": "2019-10-03T16:22:41.602379+00:00", "user": {"display_name": "David Meyer", "uuid": "{8df655d6-8661-4957-b4ba-669cef19bf2d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D"}, "html": {"href": "https://bitbucket.org/%7B8df655d6-8661-4957-b4ba-669cef19bf2d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/2a4efe81a17e5aeccdbc4ef2ca2cc463d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsDM-0.png"}}, "nickname": "dihm", "type": "user", "account_id": "557058:411f7712-e1fa-438c-b578-0359da2d9f06"}, "updated_on": null, "type": "issue_comment", "id": 54191601}], "page": 1, "size": 4}