{"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/issues/27/comments/54616348.json"}, "html": {"href": "#!/labscript_suite/labscript_utils/issues/27#comment-54616348"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/issues/27.json"}}, "type": "issue", "id": 27, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils.json"}, "html": {"href": "#!/labscript_suite/labscript_utils"}, "avatar": {"href": "data/bytebucket.org/ravatar/{68347210-fb1e-4b58-86c0-bd2c04396e63}ts=249922"}}, "type": "repository", "name": "labscript_utils", "full_name": "labscript_suite/labscript_utils", "uuid": "{68347210-fb1e-4b58-86c0-bd2c04396e63}"}, "title": "ToolPalette._layout_widgets() appears to recurse, causing a stack overflow"}, "content": {"raw": "I suspect you're right, that the calculation could be a little bit off. But it would be good if the code wasn't sensitive to relatively minor errors or to changing padding values, so fixing the calculation itself might not be the best solution, unless it's totally bomb-proof and looks up all the padding values at run-time with no hard-coded values.\n\nThere are also things that can happen where a widget says it is one size, and on that basis a container widget decides it should show a scrollbar or something, then the child widget is updated with the new size of the container (minus the scrollbar width), it declares itself to be smaller, then the parent widget decides it *doesn't* need a scrollbar after all, repeat. In this case something needs to break the cycle. We might be able to add a \"with signals disconnected, update size\" or similar to just stop recursion and keep the most recently calculated size. If that size if \"good enough\" then we'll be happy, even if there is some hysteresis in the number of buttons per row whilst resizing tabs.", "markup": "markdown", "html": "<p>I suspect you're right, that the calculation could be a little bit off. But it would be good if the code wasn't sensitive to relatively minor errors or to changing padding values, so fixing the calculation itself might not be the best solution, unless it's totally bomb-proof and looks up all the padding values at run-time with no hard-coded values.</p>\n<p>There are also things that can happen where a widget says it is one size, and on that basis a container widget decides it should show a scrollbar or something, then the child widget is updated with the new size of the container (minus the scrollbar width), it declares itself to be smaller, then the parent widget decides it <em>doesn't</em> need a scrollbar after all, repeat. In this case something needs to break the cycle. We might be able to add a \"with signals disconnected, update size\" or similar to just stop recursion and keep the most recently calculated size. If that size if \"good enough\" then we'll be happy, even if there is some hysteresis in the number of buttons per row whilst resizing tabs.</p>", "type": "rendered"}, "created_on": "2019-10-31T13:39:22.078400+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": null, "type": "issue_comment", "id": 54616348}