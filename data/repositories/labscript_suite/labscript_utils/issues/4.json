{"priority": "minor", "kind": "enhancement", "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils.json"}, "html": {"href": "#!/labscript_suite/labscript_utils"}, "avatar": {"href": "data/bytebucket.org/ravatar/{68347210-fb1e-4b58-86c0-bd2c04396e63}ts=249922"}}, "type": "repository", "name": "labscript_utils", "full_name": "labscript_suite/labscript_utils", "uuid": "{68347210-fb1e-4b58-86c0-bd2c04396e63}"}, "links": {"attachments": {"href": "data/repositories/labscript_suite/labscript_utils/issues/4/attachments_page=1.json"}, "self": {"href": "data/repositories/labscript_suite/labscript_utils/issues/4.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_utils/issues/4/watch"}, "comments": {"href": "data/repositories/labscript_suite/labscript_utils/issues/4/comments_page=1.json"}, "html": {"href": "#!/labscript_suite/labscript_utils/issues/4/unitconversions-less-magic-and-more"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_utils/issues/4/vote"}}, "reporter": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "title": "Unitconversions: less magic and more explicit importing", "component": null, "votes": 0, "watches": 1, "content": {"raw": "Unlike `labscript_devices`, we don't require a unit conversions class to be in a file with the same name as the class within it. And you can have multiple unit conversion classes within a file, in fact I wrote some today. This is good, unit conversion classes can be small and we don't want a proliferation files when related things could be in a file together.\r\n\r\nSo that means that `unitconversions.__init__.py` goes out and does `import *` from everything, to make sure it gets all the conversion classes.\r\n\r\nThis can have unfortunate side effects, like when you import a single unit conversion class, you unwittingly import them all (this can be a problem if you have [line-in-the-sand style reloading of modules](http://pyunit.sourceforge.net/notes/reloading.html), and accidentally put these modules on the wrong side of the line. This isn't just me making up issues, it happened today to me!)\r\n\r\nIt also pollutes the namespace of `unitconversions.__init__.py` with all the global variables from the files in which unit conversions are defined.\r\n\r\nWhat we should do instead is have labscript store the full, qualified class name of the unit conversion class that is used. So that's the fully qualified module name and class name (eg: `labscript_utils.unitconversions.myconversionmodule.MyConversionClass`), the same way that the `pickle` module stores what class you're using, so it can import it and instantiate one on unpickling, regardless of whether that class has been imported.\r\n\r\nA function in `unitconversions.__init__.py` should then be provided that will go and find the relevant class (which can be anywhere in the Python search path), and return it to the caller. This function should happily import the required modules every time it is called, but mostly this will just do nothing because the module will already be in `sys.modules` and so it will be returned without the code being run. However if a `ModuleWatcher` has in the meantime unloaded a module due to it changing, it will be re-executed, and the caller will get the brand, shiny new class.\r\n\r\nWhen users want a unit conversion class, they will import it directly from wherever it is. When BLACS wants a unit conversion class, it should call that function to get the class by name.\r\n\r\nThis will not be backward compatible, there is no easy way to make it backward compatible without defeating the benefits completely. So it will be a major version bump and changes in other code will have to have corresponding bumps in their dependency checks.\r\n\r\nThis helps us further along the path of 'don't run code that isn't yours'. We started with having literally everything in `labscript.py`, but as we branch out to more users and devices, we shouldn't be just executing all code everywhere, just what we need. Otherwise users are subject to the import dependencies and possible crashes of code that is not theirs and they aren't using.", "markup": "markdown", "html": "<p>Unlike <code>labscript_devices</code>, we don't require a unit conversions class to be in a file with the same name as the class within it. And you can have multiple unit conversion classes within a file, in fact I wrote some today. This is good, unit conversion classes can be small and we don't want a proliferation files when related things could be in a file together.</p>\n<p>So that means that <code>unitconversions.__init__.py</code> goes out and does <code>import *</code> from everything, to make sure it gets all the conversion classes.</p>\n<p>This can have unfortunate side effects, like when you import a single unit conversion class, you unwittingly import them all (this can be a problem if you have <a data-is-external-link=\"true\" href=\"http://pyunit.sourceforge.net/notes/reloading.html\" rel=\"nofollow\">line-in-the-sand style reloading of modules</a>, and accidentally put these modules on the wrong side of the line. This isn't just me making up issues, it happened today to me!)</p>\n<p>It also pollutes the namespace of <code>unitconversions.__init__.py</code> with all the global variables from the files in which unit conversions are defined.</p>\n<p>What we should do instead is have labscript store the full, qualified class name of the unit conversion class that is used. So that's the fully qualified module name and class name (eg: <code>labscript_utils.unitconversions.myconversionmodule.MyConversionClass</code>), the same way that the <code>pickle</code> module stores what class you're using, so it can import it and instantiate one on unpickling, regardless of whether that class has been imported.</p>\n<p>A function in <code>unitconversions.__init__.py</code> should then be provided that will go and find the relevant class (which can be anywhere in the Python search path), and return it to the caller. This function should happily import the required modules every time it is called, but mostly this will just do nothing because the module will already be in <code>sys.modules</code> and so it will be returned without the code being run. However if a <code>ModuleWatcher</code> has in the meantime unloaded a module due to it changing, it will be re-executed, and the caller will get the brand, shiny new class.</p>\n<p>When users want a unit conversion class, they will import it directly from wherever it is. When BLACS wants a unit conversion class, it should call that function to get the class by name.</p>\n<p>This will not be backward compatible, there is no easy way to make it backward compatible without defeating the benefits completely. So it will be a major version bump and changes in other code will have to have corresponding bumps in their dependency checks.</p>\n<p>This helps us further along the path of 'don't run code that isn't yours'. We started with having literally everything in <code>labscript.py</code>, but as we branch out to more users and devices, we shouldn't be just executing all code everywhere, just what we need. Otherwise users are subject to the import dependencies and possible crashes of code that is not theirs and they aren't using.</p>", "type": "rendered"}, "assignee": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "state": "new", "version": null, "edited_on": null, "created_on": "2014-10-04T01:47:19.137376+00:00", "milestone": null, "updated_on": "2014-10-05T03:09:49.152306+00:00", "type": "issue", "id": 4}