{"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/pullrequests/31/comments/57757904.json"}, "html": {"href": "#!/labscript_suite/labscript_utils/pull-requests/31/_/diff#comment-57757904"}}, "parent": {"id": 57756786, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/pullrequests/31/comments/57756786.json"}, "html": {"href": "#!/labscript_suite/labscript_utils/pull-requests/31/_/diff#comment-57756786"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 31, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/pullrequests/31.json"}, "html": {"href": "#!/labscript_suite/labscript_utils/pull-requests/31"}}, "title": "Unit conversions Python3 bugfix and cleanup"}, "content": {"raw": "* Yes I did, I modified the example class to have multiple derived units to confirm the order was preserved.\n* I grepped for `.units` and `.unit_list`, so I'm pretty confident I would have seen anything using them.\n* The unit list used to be:\n\n```\n#!python\n\n    unit_list = {'p':'10**-12','n':'10**-9','u':'10**-6','m':'10**-3',\n                 'k':'10**3','M':'10**6','G':'10**9','T':'10**12'}\n```\nWith strings as the dictionary values. These values were being `eval()`'d in `UnitConversionBase.py` every time they were used, except in the `exec()` calls, where they were inserted as strings into the string being `exec()`'d. Since I determined nothing in labscript was reading `unit_list` except for the code in `UnitConversionBase.py`, I figured it was harmless to turn these into floats instead of strings, so that sorting and multiplying wouldn't need `eval()` to be called on them first.\n\n* I'll do this with BLACS, I haven't tested this.\n\n* In python 2, comparisons between bytestrings and unicode strings are extremely liberal:\n\n\n```\n#!python\n\n>>> b'x' == u'x'\nTrue\n>>> b'x' in [u'x']\nTrue\n>>> u'x' in [b'x']\nTrue\n>>> {b'x': 1}[u'x']\n1\n>>> {u'x': 1}[b'x']\n1\n>>> [u'x'].index(b'x')\n0\n>>> [b'x'].index(u'x')\n0\n\n```\n\nIn Python 3 all of these are False or raise an exception.\n\nSo in porting apps to Python 3, any time a string is read from a file or whatnot, it will need to be able to deal with it regardless of whether it is a unicode string or a bytestring, and as we port things, the aim is to turn more and more strings into into the right type of string that they should be (i.e unicode pretty much everywhere, except when dealing with IO that requires bytes), and because the types are so interchangeable in Python 2, we have not hit on much trouble with doing this one file/repo at a time (For example, the only reason `print(e._magnitudes.keys())` resulted in bytestrings in Python 2 is because the test file didn't have `unicode_literals` imported from `__future__`, and so it passed in bytestrings for the desired magnitudes, but everything still worked because they were treated as the same as the unicode ones in UnitConversionBase.py for the purpose of dictionary lookups).\n\nThe only Python 2 code that will break is code that is explicitly checking whether something is a bytestring, since in Python 2, since:\n\n```\n#!python\n\n>>> isinstance(u'', str)\nFalse\n\n```\n\nAs well as code that goes on to pass the now-unicode strings into some IO that definitely requires bytes. So this trickiness is mostly only an issue with file IO such as `properties.py` and `connections.py`.", "markup": "markdown", "html": "<ul>\n<li>Yes I did, I modified the example class to have multiple derived units to confirm the order was preserved.</li>\n<li>I grepped for <code>.units</code> and <code>.unit_list</code>, so I'm pretty confident I would have seen anything using them.</li>\n<li>The unit list used to be:</li>\n</ul>\n<div class=\"codehilite language-python\"><pre><span></span>    <span class=\"n\">unit_list</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">&#39;p&#39;</span><span class=\"p\">:</span><span class=\"s1\">&#39;10**-12&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;n&#39;</span><span class=\"p\">:</span><span class=\"s1\">&#39;10**-9&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;u&#39;</span><span class=\"p\">:</span><span class=\"s1\">&#39;10**-6&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;m&#39;</span><span class=\"p\">:</span><span class=\"s1\">&#39;10**-3&#39;</span><span class=\"p\">,</span>\n                 <span class=\"s1\">&#39;k&#39;</span><span class=\"p\">:</span><span class=\"s1\">&#39;10**3&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;M&#39;</span><span class=\"p\">:</span><span class=\"s1\">&#39;10**6&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;G&#39;</span><span class=\"p\">:</span><span class=\"s1\">&#39;10**9&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;T&#39;</span><span class=\"p\">:</span><span class=\"s1\">&#39;10**12&#39;</span><span class=\"p\">}</span>\n</pre></div>\n\n\n<p>With strings as the dictionary values. These values were being <code>eval()</code>'d in <code>UnitConversionBase.py</code> every time they were used, except in the <code>exec()</code> calls, where they were inserted as strings into the string being <code>exec()</code>'d. Since I determined nothing in labscript was reading <code>unit_list</code> except for the code in <code>UnitConversionBase.py</code>, I figured it was harmless to turn these into floats instead of strings, so that sorting and multiplying wouldn't need <code>eval()</code> to be called on them first.</p>\n<ul>\n<li>\n<p>I'll do this with BLACS, I haven't tested this.</p>\n</li>\n<li>\n<p>In python 2, comparisons between bytestrings and unicode strings are extremely liberal:</p>\n</li>\n</ul>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"sa\">b</span><span class=\"s1\">&#39;x&#39;</span> <span class=\"o\">==</span> <span class=\"sa\">u</span><span class=\"s1\">&#39;x&#39;</span>\n<span class=\"bp\">True</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"sa\">b</span><span class=\"s1\">&#39;x&#39;</span> <span class=\"ow\">in</span> <span class=\"p\">[</span><span class=\"sa\">u</span><span class=\"s1\">&#39;x&#39;</span><span class=\"p\">]</span>\n<span class=\"bp\">True</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"sa\">u</span><span class=\"s1\">&#39;x&#39;</span> <span class=\"ow\">in</span> <span class=\"p\">[</span><span class=\"sa\">b</span><span class=\"s1\">&#39;x&#39;</span><span class=\"p\">]</span>\n<span class=\"bp\">True</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">{</span><span class=\"sa\">b</span><span class=\"s1\">&#39;x&#39;</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">}[</span><span class=\"sa\">u</span><span class=\"s1\">&#39;x&#39;</span><span class=\"p\">]</span>\n<span class=\"mi\">1</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">{</span><span class=\"sa\">u</span><span class=\"s1\">&#39;x&#39;</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">}[</span><span class=\"sa\">b</span><span class=\"s1\">&#39;x&#39;</span><span class=\"p\">]</span>\n<span class=\"mi\">1</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">[</span><span class=\"sa\">u</span><span class=\"s1\">&#39;x&#39;</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s1\">&#39;x&#39;</span><span class=\"p\">)</span>\n<span class=\"mi\">0</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">[</span><span class=\"sa\">b</span><span class=\"s1\">&#39;x&#39;</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">(</span><span class=\"sa\">u</span><span class=\"s1\">&#39;x&#39;</span><span class=\"p\">)</span>\n<span class=\"mi\">0</span>\n</pre></div>\n\n\n<p>In Python 3 all of these are False or raise an exception.</p>\n<p>So in porting apps to Python 3, any time a string is read from a file or whatnot, it will need to be able to deal with it regardless of whether it is a unicode string or a bytestring, and as we port things, the aim is to turn more and more strings into into the right type of string that they should be (i.e unicode pretty much everywhere, except when dealing with IO that requires bytes), and because the types are so interchangeable in Python 2, we have not hit on much trouble with doing this one file/repo at a time (For example, the only reason <code>print(e._magnitudes.keys())</code> resulted in bytestrings in Python 2 is because the test file didn't have <code>unicode_literals</code> imported from <code>__future__</code>, and so it passed in bytestrings for the desired magnitudes, but everything still worked because they were treated as the same as the unicode ones in UnitConversionBase.py for the purpose of dictionary lookups).</p>\n<p>The only Python 2 code that will break is code that is explicitly checking whether something is a bytestring, since in Python 2, since:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"sa\">u</span><span class=\"s1\">&#39;&#39;</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">)</span>\n<span class=\"bp\">False</span>\n</pre></div>\n\n\n<p>As well as code that goes on to pass the now-unicode strings into some IO that definitely requires bytes. So this trickiness is mostly only an issue with file IO such as <code>properties.py</code> and <code>connections.py</code>.</p>", "type": "rendered"}, "created_on": "2018-03-02T07:13:37.615022+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2018-03-02T07:14:02.696954+00:00", "type": "pullrequest_comment", "id": 57757904}