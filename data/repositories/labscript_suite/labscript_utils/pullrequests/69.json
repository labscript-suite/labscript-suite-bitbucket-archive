{"rendered": {"description": {"raw": "A major source of sluggishness in labscript suite programs is importing things just to check that they are a compatible version, even though the modules might not be used. For example, some devices in labscript_devices depend on a certain version of labscript, and so importing labscript_devices (even if just for a BLACS tab) means importing labscript which means importing scipy...it adds up quick. \r\n\r\nThis PR changes the check_version function to use Python's pkg_resources module to identify the version of a package without importing it. \r\n\r\nI used to not think this was a good idea, because I wanted to know the version actually being imported was the one that we were checking the version of - in case there were multiple copies of a module on the system, which is still way too easy to do, you could get false positives saying versions were fine when they were in fact totally borked.\r\n\r\nBut I realised we can ensure this by calling `imp.find_module` (Py2) or `importlib.find_spec` (Py3) to find the location of a module without importing it, and compare that with the path in pkg_resources to confirm the version being checked is the one that would be imported (and to also check the module exists and it's not just dead .egg-info files lying around with version info for things that have been deleted).\r\n\r\nThe one downside is that if you're checking the version of a package with a different 'project name' to its import name (i.e. pyserial vs serial), then you now have to give the check_version function the project name too. This is not the case for any of our present uses of check_version though.\r\n\r\nAlso, of course labscript suite repos don't have .egg-info files saying what version they are. So this code also just reads their code looking for a `__version__` literal. Much faster than actually importing them.\r\n\r\nRemoved brute_import since we're not importing the modules anymore, and move version checking code to versions.py (still imported from labscript_utils so no changes needed to application code).\r\n\r\nBLACS starts up and restarts tabs noticeably snappier with this.\r\n\r\nSpeed isn't what motivated me to do this though, I'm thinking of centralising version checking a bit more so that you don't need to wait to hit the code that needs the version before you get an error. A list of incompatible modules all at once, and even the offer to automatically fix the situation if it is straightforward (not hg updating any repos, but pip or conda packages, perhaps) would be much nicer. But it's untenable to centralise the checks for the whole suite at startup if it means actually importing everything. But with this check_version we can do a consistency check all at once and whenever we want.\r\n\r\nIn particular I'm looking at specifying versions in the installer, since we already depend on versions of things newer than what is in default anaconda (even though the updated package is one call to conda away)", "markup": "markdown", "html": "<p>A major source of sluggishness in labscript suite programs is importing things just to check that they are a compatible version, even though the modules might not be used. For example, some devices in labscript_devices depend on a certain version of labscript, and so importing labscript_devices (even if just for a BLACS tab) means importing labscript which means importing scipy...it adds up quick. </p>\n<p>This PR changes the check_version function to use Python's pkg_resources module to identify the version of a package without importing it. </p>\n<p>I used to not think this was a good idea, because I wanted to know the version actually being imported was the one that we were checking the version of - in case there were multiple copies of a module on the system, which is still way too easy to do, you could get false positives saying versions were fine when they were in fact totally borked.</p>\n<p>But I realised we can ensure this by calling <code>imp.find_module</code> (Py2) or <code>importlib.find_spec</code> (Py3) to find the location of a module without importing it, and compare that with the path in pkg_resources to confirm the version being checked is the one that would be imported (and to also check the module exists and it's not just dead .egg-info files lying around with version info for things that have been deleted).</p>\n<p>The one downside is that if you're checking the version of a package with a different 'project name' to its import name (i.e. pyserial vs serial), then you now have to give the check_version function the project name too. This is not the case for any of our present uses of check_version though.</p>\n<p>Also, of course labscript suite repos don't have .egg-info files saying what version they are. So this code also just reads their code looking for a <code>__version__</code> literal. Much faster than actually importing them.</p>\n<p>Removed brute_import since we're not importing the modules anymore, and move version checking code to versions.py (still imported from labscript_utils so no changes needed to application code).</p>\n<p>BLACS starts up and restarts tabs noticeably snappier with this.</p>\n<p>Speed isn't what motivated me to do this though, I'm thinking of centralising version checking a bit more so that you don't need to wait to hit the code that needs the version before you get an error. A list of incompatible modules all at once, and even the offer to automatically fix the situation if it is straightforward (not hg updating any repos, but pip or conda packages, perhaps) would be much nicer. But it's untenable to centralise the checks for the whole suite at startup if it means actually importing everything. But with this check_version we can do a consistency check all at once and whenever we want.</p>\n<p>In particular I'm looking at specifying versions in the installer, since we already depend on versions of things newer than what is in default anaconda (even though the updated package is one call to conda away)</p>", "type": "rendered"}, "title": {"raw": "check_version without importing modules", "markup": "markdown", "html": "<p>check_version without importing modules</p>", "type": "rendered"}}, "type": "pullrequest", "description": "A major source of sluggishness in labscript suite programs is importing things just to check that they are a compatible version, even though the modules might not be used. For example, some devices in labscript_devices depend on a certain version of labscript, and so importing labscript_devices (even if just for a BLACS tab) means importing labscript which means importing scipy...it adds up quick. \r\n\r\nThis PR changes the check_version function to use Python's pkg_resources module to identify the version of a package without importing it. \r\n\r\nI used to not think this was a good idea, because I wanted to know the version actually being imported was the one that we were checking the version of - in case there were multiple copies of a module on the system, which is still way too easy to do, you could get false positives saying versions were fine when they were in fact totally borked.\r\n\r\nBut I realised we can ensure this by calling `imp.find_module` (Py2) or `importlib.find_spec` (Py3) to find the location of a module without importing it, and compare that with the path in pkg_resources to confirm the version being checked is the one that would be imported (and to also check the module exists and it's not just dead .egg-info files lying around with version info for things that have been deleted).\r\n\r\nThe one downside is that if you're checking the version of a package with a different 'project name' to its import name (i.e. pyserial vs serial), then you now have to give the check_version function the project name too. This is not the case for any of our present uses of check_version though.\r\n\r\nAlso, of course labscript suite repos don't have .egg-info files saying what version they are. So this code also just reads their code looking for a `__version__` literal. Much faster than actually importing them.\r\n\r\nRemoved brute_import since we're not importing the modules anymore, and move version checking code to versions.py (still imported from labscript_utils so no changes needed to application code).\r\n\r\nBLACS starts up and restarts tabs noticeably snappier with this.\r\n\r\nSpeed isn't what motivated me to do this though, I'm thinking of centralising version checking a bit more so that you don't need to wait to hit the code that needs the version before you get an error. A list of incompatible modules all at once, and even the offer to automatically fix the situation if it is straightforward (not hg updating any repos, but pip or conda packages, perhaps) would be much nicer. But it's untenable to centralise the checks for the whole suite at startup if it means actually importing everything. But with this check_version we can do a consistency check all at once and whenever we want.\r\n\r\nIn particular I'm looking at specifying versions in the installer, since we already depend on versions of things newer than what is in default anaconda (even though the updated package is one call to conda away)", "links": {"decline": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_utils/pullrequests/69/decline"}, "diffstat": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_utils/diffstat/labscript_suite/labscript_utils:0675faebc6c4%0D73c42f98ed4c?from_pullrequest_id=69"}, "commits": {"href": "data/repositories/labscript_suite/labscript_utils/pullrequests/69/commits.json"}, "self": {"href": "data/repositories/labscript_suite/labscript_utils/pullrequests/69.json"}, "comments": {"href": "data/repositories/labscript_suite/labscript_utils/pullrequests/69/comments_page=1.json"}, "merge": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_utils/pullrequests/69/merge"}, "html": {"href": "#!/labscript_suite/labscript_utils/pull-requests/69"}, "activity": {"href": "data/repositories/labscript_suite/labscript_utils/pullrequests/69/activity.json"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_utils/diff/labscript_suite/labscript_utils:0675faebc6c4%0D73c42f98ed4c?from_pullrequest_id=69"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/labscript_suite/labscript_utils/pullrequests/69/approve"}, "statuses": {"href": "data/repositories/labscript_suite/labscript_utils/pullrequests/69/statuses_page=1.json"}}, "title": "check_version without importing modules", "close_source_branch": true, "reviewers": [{"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}, {"display_name": "Philip Starkey", "uuid": "{0147401a-13ed-4e39-a0d0-63108c18738b}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D"}, "html": {"href": "https://bitbucket.org/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/fa0698c306b3470c00717c146b5296e9d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "philipstarkey", "type": "user", "account_id": "557058:2f99420c-1dbd-4837-952c-82c421b8fbdd"}], "id": 69, "destination": {"commit": {"hash": "73c42f98ed4c", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/commit/73c42f98ed4c.json"}, "html": {"href": "#!/labscript_suite/labscript_utils/commits/73c42f98ed4c"}}}, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils.json"}, "html": {"href": "#!/labscript_suite/labscript_utils"}, "avatar": {"href": "data/bytebucket.org/ravatar/{68347210-fb1e-4b58-86c0-bd2c04396e63}ts=249922"}}, "type": "repository", "name": "labscript_utils", "full_name": "labscript_suite/labscript_utils", "uuid": "{68347210-fb1e-4b58-86c0-bd2c04396e63}"}, "branch": {"name": "default"}}, "created_on": "2019-02-10T02:56:48.677972+00:00", "summary": {"raw": "A major source of sluggishness in labscript suite programs is importing things just to check that they are a compatible version, even though the modules might not be used. For example, some devices in labscript_devices depend on a certain version of labscript, and so importing labscript_devices (even if just for a BLACS tab) means importing labscript which means importing scipy...it adds up quick. \r\n\r\nThis PR changes the check_version function to use Python's pkg_resources module to identify the version of a package without importing it. \r\n\r\nI used to not think this was a good idea, because I wanted to know the version actually being imported was the one that we were checking the version of - in case there were multiple copies of a module on the system, which is still way too easy to do, you could get false positives saying versions were fine when they were in fact totally borked.\r\n\r\nBut I realised we can ensure this by calling `imp.find_module` (Py2) or `importlib.find_spec` (Py3) to find the location of a module without importing it, and compare that with the path in pkg_resources to confirm the version being checked is the one that would be imported (and to also check the module exists and it's not just dead .egg-info files lying around with version info for things that have been deleted).\r\n\r\nThe one downside is that if you're checking the version of a package with a different 'project name' to its import name (i.e. pyserial vs serial), then you now have to give the check_version function the project name too. This is not the case for any of our present uses of check_version though.\r\n\r\nAlso, of course labscript suite repos don't have .egg-info files saying what version they are. So this code also just reads their code looking for a `__version__` literal. Much faster than actually importing them.\r\n\r\nRemoved brute_import since we're not importing the modules anymore, and move version checking code to versions.py (still imported from labscript_utils so no changes needed to application code).\r\n\r\nBLACS starts up and restarts tabs noticeably snappier with this.\r\n\r\nSpeed isn't what motivated me to do this though, I'm thinking of centralising version checking a bit more so that you don't need to wait to hit the code that needs the version before you get an error. A list of incompatible modules all at once, and even the offer to automatically fix the situation if it is straightforward (not hg updating any repos, but pip or conda packages, perhaps) would be much nicer. But it's untenable to centralise the checks for the whole suite at startup if it means actually importing everything. But with this check_version we can do a consistency check all at once and whenever we want.\r\n\r\nIn particular I'm looking at specifying versions in the installer, since we already depend on versions of things newer than what is in default anaconda (even though the updated package is one call to conda away)", "markup": "markdown", "html": "<p>A major source of sluggishness in labscript suite programs is importing things just to check that they are a compatible version, even though the modules might not be used. For example, some devices in labscript_devices depend on a certain version of labscript, and so importing labscript_devices (even if just for a BLACS tab) means importing labscript which means importing scipy...it adds up quick. </p>\n<p>This PR changes the check_version function to use Python's pkg_resources module to identify the version of a package without importing it. </p>\n<p>I used to not think this was a good idea, because I wanted to know the version actually being imported was the one that we were checking the version of - in case there were multiple copies of a module on the system, which is still way too easy to do, you could get false positives saying versions were fine when they were in fact totally borked.</p>\n<p>But I realised we can ensure this by calling <code>imp.find_module</code> (Py2) or <code>importlib.find_spec</code> (Py3) to find the location of a module without importing it, and compare that with the path in pkg_resources to confirm the version being checked is the one that would be imported (and to also check the module exists and it's not just dead .egg-info files lying around with version info for things that have been deleted).</p>\n<p>The one downside is that if you're checking the version of a package with a different 'project name' to its import name (i.e. pyserial vs serial), then you now have to give the check_version function the project name too. This is not the case for any of our present uses of check_version though.</p>\n<p>Also, of course labscript suite repos don't have .egg-info files saying what version they are. So this code also just reads their code looking for a <code>__version__</code> literal. Much faster than actually importing them.</p>\n<p>Removed brute_import since we're not importing the modules anymore, and move version checking code to versions.py (still imported from labscript_utils so no changes needed to application code).</p>\n<p>BLACS starts up and restarts tabs noticeably snappier with this.</p>\n<p>Speed isn't what motivated me to do this though, I'm thinking of centralising version checking a bit more so that you don't need to wait to hit the code that needs the version before you get an error. A list of incompatible modules all at once, and even the offer to automatically fix the situation if it is straightforward (not hg updating any repos, but pip or conda packages, perhaps) would be much nicer. But it's untenable to centralise the checks for the whole suite at startup if it means actually importing everything. But with this check_version we can do a consistency check all at once and whenever we want.</p>\n<p>In particular I'm looking at specifying versions in the installer, since we already depend on versions of things newer than what is in default anaconda (even though the updated package is one call to conda away)</p>", "type": "rendered"}, "source": {"commit": {"hash": "0f31a19e38e2", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_utils/commit/0f31a19e38e2"}, "html": {"href": "#!/cbillington/labscript_utils/commits/0f31a19e38e2"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/cbillington/labscript_utils"}, "html": {"href": "#!/cbillington/labscript_utils"}, "avatar": {"href": "data/bytebucket.org/ravatar/{455d0b5d-4852-4e4a-b8b1-f5ba77882210}ts=python"}}, "type": "repository", "name": "labscript_utils", "full_name": "cbillington/labscript_utils", "uuid": "{455d0b5d-4852-4e4a-b8b1-f5ba77882210}"}, "branch": {"name": "check_version"}}, "comment_count": 4, "state": "MERGED", "task_count": 0, "participants": [{"role": "REVIEWER", "participated_on": null, "type": "participant", "approved": false, "user": {"display_name": "Russell Anderson", "uuid": "{6c12ac6e-1980-466d-86fe-6c163bd116c2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D"}, "html": {"href": "https://bitbucket.org/%7B6c12ac6e-1980-466d-86fe-6c163bd116c2%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e/e307ce36-5fb6-4418-8090-b9e533eab225/128"}}, "nickname": "rpanderson", "type": "user", "account_id": "557058:443e4cd1-86c9-4cd5-8034-22bab14d9d1e"}}, {"role": "PARTICIPANT", "participated_on": "2019-06-09T16:32:06.902308+00:00", "type": "participant", "approved": false, "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}}, {"role": "REVIEWER", "participated_on": null, "type": "participant", "approved": false, "user": {"display_name": "Philip Starkey", "uuid": "{0147401a-13ed-4e39-a0d0-63108c18738b}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D"}, "html": {"href": "https://bitbucket.org/%7B0147401a-13ed-4e39-a0d0-63108c18738b%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/fa0698c306b3470c00717c146b5296e9d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "philipstarkey", "type": "user", "account_id": "557058:2f99420c-1dbd-4837-952c-82c421b8fbdd"}}], "reason": "", "updated_on": "2019-06-15T21:22:17.318844+00:00", "author": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "merge_commit": {"hash": "0675faebc6c4", "type": "commit", "links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/commit/0675faebc6c4.json"}, "html": {"href": "#!/labscript_suite/labscript_utils/commits/0675faebc6c4"}}}, "closed_by": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}}