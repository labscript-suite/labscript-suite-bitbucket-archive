{"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/pullrequests/77/comments/100229850.json"}, "html": {"href": "#!/labscript_suite/labscript_utils/pull-requests/77/_/diff#comment-100229850"}}, "parent": {"id": 100225052, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/pullrequests/77/comments/100225052.json"}, "html": {"href": "#!/labscript_suite/labscript_utils/pull-requests/77/_/diff#comment-100225052"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 77, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/pullrequests/77.json"}, "html": {"href": "#!/labscript_suite/labscript_utils/pull-requests/77"}}, "title": "Fixes for remote workers."}, "content": {"raw": "To clarify - \u2018allow\\_insecure\u2019 isn\u2019t about having servers  accept both encrypted and unencrypted clients \\(I haven\u2019t worked out how to do that in zmq in any case\\). Instead, it\u2019s a flag to say \u201cyes, I am aware that I have not enabled encryption and I accept the consequences\u201d. Setting allow\\_insecure when also specifying a shared secret does nothing, so there is no need to explicitly set it to False. Instead, one will need to set it to True in the future \\(once we\u2019re happy enough with this security stuff that we want to enforce it\\) to opt-out of encryption without zprocess erroring on every external connection or message received from an external connection \\(localhost communication continues to work fine with no encryption and without setting allow\\_insecure=True\\). \n\nThe error messages zprocess prints might help clarify further how this is intended to work:\n\n```python\n\nINSECURE_CONNECT_ERROR = ' '.join(\n    \"\"\"Plaintext socket connecting to external address %s  not allowed. Use a shared\nsecret to securely communicate across the network, or set allow_insecure=True if you are\non a trusted network and you know what you are doing. Insecure communication with Python\nobjects can allow remote code execution and so is not safe on an untrusted network even\nif messages contain no sensitive information.\"\"\".splitlines()\n)\n\n\nINSECURE_RECV_WARNING = ' '.join(\n    \"\"\"Warning: insecure message received on external interface from %s discarded. Use a\nshared secret to securely communicate across the network, or set allow_insecure=True if\nyou are on a trusted network and you know what you are doing. Insecure communication\nwith Python objects can allow remote code execution and so is not safe on an untrusted\nnetwork even if messages contain no sensitive information.\"\"\".splitlines()\n)\n```\n\n\u200c\n\nThere are two places allow\\_insecure is currently defaulting to True, one is here in `labscript_utils.ls_zprocess`, and the other is in zprocess itself. Both will need to change before security is guaranteed without explicitly suppressing it, but the change to zprocess is a backward-incompatible one, so is trickier.\n\nIt occured to me that I\u2019ve done something silly - zprocess functions accept allow\\_insecure, and whilst it\u2019s currently defaulting to True, labscript can pass in False, in which case it doesn\u2019t matter what zprocess\u2019s default is. This is happening with all the functions and classes that are accessed in normal Python code. But with the command line programs - zlog, zlock and zprocess.remote, these have the flag passed in as `--allow-insecure`on the command line, and if not provided it defaults to True as per zprocess defaults. There\u2019s no way to say \u201chey, set allow\\_insecure to be False\u201d. So I should add a `--no-allow-insecure` flag as well, so that labscript can effectively pass in the actual value of `allow_insecure`without relying on zprocess defaults. That way the zprocess backward-incompatible jump doesn\u2019t have to occur quite as soon, and newer versions of labscript suite programs can for a time work with zprocess 2 or 3, making the transition not so jarring.", "markup": "markdown", "html": "<p>To clarify - \u2018allow_insecure\u2019 isn\u2019t about having servers  accept both encrypted and unencrypted clients (I haven\u2019t worked out how to do that in zmq in any case). Instead, it\u2019s a flag to say \u201cyes, I am aware that I have not enabled encryption and I accept the consequences\u201d. Setting allow_insecure when also specifying a shared secret does nothing, so there is no need to explicitly set it to False. Instead, one will need to set it to True in the future (once we\u2019re happy enough with this security stuff that we want to enforce it) to opt-out of encryption without zprocess erroring on every external connection or message received from an external connection (localhost communication continues to work fine with no encryption and without setting allow_insecure=True). </p>\n<p>The error messages zprocess prints might help clarify further how this is intended to work:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"n\">INSECURE_CONNECT_ERROR</span> <span class=\"o\">=</span> <span class=\"s1\">&#39; &#39;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span>\n    <span class=\"sd\">&quot;&quot;&quot;Plaintext socket connecting to external address %s  not allowed. Use a shared</span>\n<span class=\"sd\">secret to securely communicate across the network, or set allow_insecure=True if you are</span>\n<span class=\"sd\">on a trusted network and you know what you are doing. Insecure communication with Python</span>\n<span class=\"sd\">objects can allow remote code execution and so is not safe on an untrusted network even</span>\n<span class=\"sd\">if messages contain no sensitive information.&quot;&quot;&quot;</span><span class=\"o\">.</span><span class=\"n\">splitlines</span><span class=\"p\">()</span>\n<span class=\"p\">)</span>\n\n\n<span class=\"n\">INSECURE_RECV_WARNING</span> <span class=\"o\">=</span> <span class=\"s1\">&#39; &#39;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span>\n    <span class=\"sd\">&quot;&quot;&quot;Warning: insecure message received on external interface from %s discarded. Use a</span>\n<span class=\"sd\">shared secret to securely communicate across the network, or set allow_insecure=True if</span>\n<span class=\"sd\">you are on a trusted network and you know what you are doing. Insecure communication</span>\n<span class=\"sd\">with Python objects can allow remote code execution and so is not safe on an untrusted</span>\n<span class=\"sd\">network even if messages contain no sensitive information.&quot;&quot;&quot;</span><span class=\"o\">.</span><span class=\"n\">splitlines</span><span class=\"p\">()</span>\n<span class=\"p\">)</span>\n</pre></div>\n\n\n<p>\u200c</p>\n<p>There are two places allow_insecure is currently defaulting to True, one is here in <code>labscript_utils.ls_zprocess</code>, and the other is in zprocess itself. Both will need to change before security is guaranteed without explicitly suppressing it, but the change to zprocess is a backward-incompatible one, so is trickier.</p>\n<p>It occured to me that I\u2019ve done something silly - zprocess functions accept allow_insecure, and whilst it\u2019s currently defaulting to True, labscript can pass in False, in which case it doesn\u2019t matter what zprocess\u2019s default is. This is happening with all the functions and classes that are accessed in normal Python code. But with the command line programs - zlog, zlock and zprocess.remote, these have the flag passed in as <code>--allow-insecure</code>on the command line, and if not provided it defaults to True as per zprocess defaults. There\u2019s no way to say \u201chey, set allow_insecure to be False\u201d. So I should add a <code>--no-allow-insecure</code> flag as well, so that labscript can effectively pass in the actual value of <code>allow_insecure</code>without relying on zprocess defaults. That way the zprocess backward-incompatible jump doesn\u2019t have to occur quite as soon, and newer versions of labscript suite programs can for a time work with zprocess 2 or 3, making the transition not so jarring.</p>", "type": "rendered"}, "created_on": "2019-04-28T15:23:19.873834+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-04-28T15:23:19.885510+00:00", "type": "pullrequest_comment", "id": 100229850}