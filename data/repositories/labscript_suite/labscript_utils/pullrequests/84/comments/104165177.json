{"links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/pullrequests/84/comments/104165177.json"}, "html": {"href": "#!/labscript_suite/labscript_utils/pull-requests/84/_/diff#comment-104165177"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 84, "links": {"self": {"href": "data/repositories/labscript_suite/labscript_utils/pullrequests/84.json"}, "html": {"href": "#!/labscript_suite/labscript_utils/pull-requests/84"}}, "title": "Delay handling SIGTERM until HDF5 files are closed"}, "content": {"raw": "This was causing occasional random deadlocks, which were super difficult to find the root cause of. And the deadlocks didn't even have anything to do with signal handling.\n\nTurns out that `h5py.File.__exit__` acquires the h5py global lock (\"`phil`\"), and so it calls our `close()` method with that lock held. For thread-safety in the implementation of the `KillLock`, `KillLock.release()` acquires a different lock, briefly, which means it may be waiting on another thread that currently holds that lock. Said other thread however may choose at any time to do garbage collection, and for deallocating HDF5 objects, this means acquiring the `phil` lock. So that's a deadlock, with tracebacks showing one Python thread hanging within `kill_lock.release()` trying to acquire a lock, and another Python thread hanging on a seemingly innocent line of code inside `kill_lock.acquire()` (whereas it is actually hanging on the garbage collection).\n\nSolution is to define `__exit__` not to acquire `phil`. There is no reason for it to anyway, it is just the h5py devs wrapping almost every method in the lock whether it specifically needs it or not, as far as I can tell.\n\nI will test this on Windows (have already tested pretty well on linux), and will merge Monday June 9th if there are no issues.", "markup": "markdown", "html": "<p>This was causing occasional random deadlocks, which were super difficult to find the root cause of. And the deadlocks didn't even have anything to do with signal handling.</p>\n<p>Turns out that <code>h5py.File.__exit__</code> acquires the h5py global lock (\"<code>phil</code>\"), and so it calls our <code>close()</code> method with that lock held. For thread-safety in the implementation of the <code>KillLock</code>, <code>KillLock.release()</code> acquires a different lock, briefly, which means it may be waiting on another thread that currently holds that lock. Said other thread however may choose at any time to do garbage collection, and for deallocating HDF5 objects, this means acquiring the <code>phil</code> lock. So that's a deadlock, with tracebacks showing one Python thread hanging within <code>kill_lock.release()</code> trying to acquire a lock, and another Python thread hanging on a seemingly innocent line of code inside <code>kill_lock.acquire()</code> (whereas it is actually hanging on the garbage collection).</p>\n<p>Solution is to define <code>__exit__</code> not to acquire <code>phil</code>. There is no reason for it to anyway, it is just the h5py devs wrapping almost every method in the lock whether it specifically needs it or not, as far as I can tell.</p>\n<p>I will test this on Windows (have already tested pretty well on linux), and will merge Monday June 9th if there are no issues.</p>", "type": "rendered"}, "created_on": "2019-05-31T20:50:16.702914+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2019-05-31T20:50:16.713678+00:00", "type": "pullrequest_comment", "id": 104165177}