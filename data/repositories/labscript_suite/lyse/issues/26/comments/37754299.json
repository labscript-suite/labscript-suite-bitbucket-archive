{"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26/comments/37754299.json"}, "html": {"href": "#!/labscript_suite/lyse/issues/26#comment-37754299"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26.json"}}, "type": "issue", "id": 26, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse.json"}, "html": {"href": "#!/labscript_suite/lyse"}, "avatar": {"href": "data/bytebucket.org/ravatar/{55eebdfe-43d1-4ae8-9049-50c55b295397}ts=249921"}}, "type": "repository", "name": "lyse", "full_name": "labscript_suite/lyse", "uuid": "{55eebdfe-43d1-4ae8-9049-50c55b295397}"}, "title": "Loading images takes too long"}, "content": {"raw": "What resolution are your images? You might find that 4000 images might take up more memory than your computers have.\n\nAn image cache is not a bad idea, but it would only be of use if the images fitted in memory, otherwise they'd be swapping out to disk anyway. Furthermore, if you're using the same images repeatedly, your operating system is likely to be caching the files already to the best of its ability, and if it's still very slow it's evidence that perhaps they don't all fit in RAM.\n\nLyse does have a place you can put things to be kept from one run of your analysis to the next, but if you remove and re-add the analysis routine it is not kept. But, as a test, you could try caching your images in the analysis subprocess with something like this:\n\n\n```\n#!python\n\n\ndef get_image(filepath):\n\n    # Make a cache if this is the first run:\n    if not hasattr(lyse.routine_storage, 'images'):\n        lyse.routinestorage.images = {}\n\n   \n    if filepath in lyse.routine_storage.images:\n         # Get the image from the cache if it's there:\n        return lyse.routine_storage.images[filepath]\n    else:\n        # Get it the usual way if it's not:\n        image = get_the_image_the_usual_way(filepath)\n        # Put it in the cache for next time:\n        lyse.routine_storage.images[filepath] = image\n        return image\n```\n\nIf that speeds things up then looking further into providing a persistent, cross-process cache like that dataframe might be useful. Otherwise perhaps not.", "markup": "markdown", "html": "<p>What resolution are your images? You might find that 4000 images might take up more memory than your computers have.</p>\n<p>An image cache is not a bad idea, but it would only be of use if the images fitted in memory, otherwise they'd be swapping out to disk anyway. Furthermore, if you're using the same images repeatedly, your operating system is likely to be caching the files already to the best of its ability, and if it's still very slow it's evidence that perhaps they don't all fit in RAM.</p>\n<p>Lyse does have a place you can put things to be kept from one run of your analysis to the next, but if you remove and re-add the analysis routine it is not kept. But, as a test, you could try caching your images in the analysis subprocess with something like this:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">get_image</span><span class=\"p\">(</span><span class=\"n\">filepath</span><span class=\"p\">):</span>\n\n    <span class=\"c1\"># Make a cache if this is the first run:</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">lyse</span><span class=\"o\">.</span><span class=\"n\">routine_storage</span><span class=\"p\">,</span> <span class=\"s1\">&#39;images&#39;</span><span class=\"p\">):</span>\n        <span class=\"n\">lyse</span><span class=\"o\">.</span><span class=\"n\">routinestorage</span><span class=\"o\">.</span><span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n\n\n    <span class=\"k\">if</span> <span class=\"n\">filepath</span> <span class=\"ow\">in</span> <span class=\"n\">lyse</span><span class=\"o\">.</span><span class=\"n\">routine_storage</span><span class=\"o\">.</span><span class=\"n\">images</span><span class=\"p\">:</span>\n         <span class=\"c1\"># Get the image from the cache if it&#39;s there:</span>\n        <span class=\"k\">return</span> <span class=\"n\">lyse</span><span class=\"o\">.</span><span class=\"n\">routine_storage</span><span class=\"o\">.</span><span class=\"n\">images</span><span class=\"p\">[</span><span class=\"n\">filepath</span><span class=\"p\">]</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Get it the usual way if it&#39;s not:</span>\n        <span class=\"n\">image</span> <span class=\"o\">=</span> <span class=\"n\">get_the_image_the_usual_way</span><span class=\"p\">(</span><span class=\"n\">filepath</span><span class=\"p\">)</span>\n        <span class=\"c1\"># Put it in the cache for next time:</span>\n        <span class=\"n\">lyse</span><span class=\"o\">.</span><span class=\"n\">routine_storage</span><span class=\"o\">.</span><span class=\"n\">images</span><span class=\"p\">[</span><span class=\"n\">filepath</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">image</span>\n        <span class=\"k\">return</span> <span class=\"n\">image</span>\n</pre></div>\n\n\n<p>If that speeds things up then looking further into providing a persistent, cross-process cache like that dataframe might be useful. Otherwise perhaps not.</p>", "type": "rendered"}, "created_on": "2017-06-21T19:20:48.093748+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": null, "type": "issue_comment", "id": 37754299}