{"pagelen": 100, "values": [{"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26/comments/37754136.json"}, "html": {"href": "#!/labscript_suite/lyse/issues/26#comment-37754136"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26.json"}}, "type": "issue", "id": 26, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse.json"}, "html": {"href": "#!/labscript_suite/lyse"}, "avatar": {"href": "data/bytebucket.org/ravatar/{55eebdfe-43d1-4ae8-9049-50c55b295397}ts=249921"}}, "type": "repository", "name": "lyse", "full_name": "labscript_suite/lyse", "uuid": "{55eebdfe-43d1-4ae8-9049-50c55b295397}"}, "title": "Loading images takes too long"}, "content": {"raw": null, "markup": "markdown", "html": "", "type": "rendered"}, "created_on": "2017-06-21T19:10:12.262476+00:00", "user": {"display_name": "Jan Werkmann", "uuid": "{44c4905c-2b90-4045-a5f1-652b8e228626}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D"}, "html": {"href": "https://bitbucket.org/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5/07e5095a-4741-4dc0-a462-9c7d455f961d/128"}}, "nickname": "PhyNerd", "type": "user", "account_id": "557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5"}, "updated_on": null, "type": "issue_comment", "id": 37754136}, {"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26/comments/37754299.json"}, "html": {"href": "#!/labscript_suite/lyse/issues/26#comment-37754299"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26.json"}}, "type": "issue", "id": 26, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse.json"}, "html": {"href": "#!/labscript_suite/lyse"}, "avatar": {"href": "data/bytebucket.org/ravatar/{55eebdfe-43d1-4ae8-9049-50c55b295397}ts=249921"}}, "type": "repository", "name": "lyse", "full_name": "labscript_suite/lyse", "uuid": "{55eebdfe-43d1-4ae8-9049-50c55b295397}"}, "title": "Loading images takes too long"}, "content": {"raw": "What resolution are your images? You might find that 4000 images might take up more memory than your computers have.\n\nAn image cache is not a bad idea, but it would only be of use if the images fitted in memory, otherwise they'd be swapping out to disk anyway. Furthermore, if you're using the same images repeatedly, your operating system is likely to be caching the files already to the best of its ability, and if it's still very slow it's evidence that perhaps they don't all fit in RAM.\n\nLyse does have a place you can put things to be kept from one run of your analysis to the next, but if you remove and re-add the analysis routine it is not kept. But, as a test, you could try caching your images in the analysis subprocess with something like this:\n\n\n```\n#!python\n\n\ndef get_image(filepath):\n\n    # Make a cache if this is the first run:\n    if not hasattr(lyse.routine_storage, 'images'):\n        lyse.routinestorage.images = {}\n\n   \n    if filepath in lyse.routine_storage.images:\n         # Get the image from the cache if it's there:\n        return lyse.routine_storage.images[filepath]\n    else:\n        # Get it the usual way if it's not:\n        image = get_the_image_the_usual_way(filepath)\n        # Put it in the cache for next time:\n        lyse.routine_storage.images[filepath] = image\n        return image\n```\n\nIf that speeds things up then looking further into providing a persistent, cross-process cache like that dataframe might be useful. Otherwise perhaps not.", "markup": "markdown", "html": "<p>What resolution are your images? You might find that 4000 images might take up more memory than your computers have.</p>\n<p>An image cache is not a bad idea, but it would only be of use if the images fitted in memory, otherwise they'd be swapping out to disk anyway. Furthermore, if you're using the same images repeatedly, your operating system is likely to be caching the files already to the best of its ability, and if it's still very slow it's evidence that perhaps they don't all fit in RAM.</p>\n<p>Lyse does have a place you can put things to be kept from one run of your analysis to the next, but if you remove and re-add the analysis routine it is not kept. But, as a test, you could try caching your images in the analysis subprocess with something like this:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">get_image</span><span class=\"p\">(</span><span class=\"n\">filepath</span><span class=\"p\">):</span>\n\n    <span class=\"c1\"># Make a cache if this is the first run:</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">lyse</span><span class=\"o\">.</span><span class=\"n\">routine_storage</span><span class=\"p\">,</span> <span class=\"s1\">&#39;images&#39;</span><span class=\"p\">):</span>\n        <span class=\"n\">lyse</span><span class=\"o\">.</span><span class=\"n\">routinestorage</span><span class=\"o\">.</span><span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n\n\n    <span class=\"k\">if</span> <span class=\"n\">filepath</span> <span class=\"ow\">in</span> <span class=\"n\">lyse</span><span class=\"o\">.</span><span class=\"n\">routine_storage</span><span class=\"o\">.</span><span class=\"n\">images</span><span class=\"p\">:</span>\n         <span class=\"c1\"># Get the image from the cache if it&#39;s there:</span>\n        <span class=\"k\">return</span> <span class=\"n\">lyse</span><span class=\"o\">.</span><span class=\"n\">routine_storage</span><span class=\"o\">.</span><span class=\"n\">images</span><span class=\"p\">[</span><span class=\"n\">filepath</span><span class=\"p\">]</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Get it the usual way if it&#39;s not:</span>\n        <span class=\"n\">image</span> <span class=\"o\">=</span> <span class=\"n\">get_the_image_the_usual_way</span><span class=\"p\">(</span><span class=\"n\">filepath</span><span class=\"p\">)</span>\n        <span class=\"c1\"># Put it in the cache for next time:</span>\n        <span class=\"n\">lyse</span><span class=\"o\">.</span><span class=\"n\">routine_storage</span><span class=\"o\">.</span><span class=\"n\">images</span><span class=\"p\">[</span><span class=\"n\">filepath</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">image</span>\n        <span class=\"k\">return</span> <span class=\"n\">image</span>\n</pre></div>\n\n\n<p>If that speeds things up then looking further into providing a persistent, cross-process cache like that dataframe might be useful. Otherwise perhaps not.</p>", "type": "rendered"}, "created_on": "2017-06-21T19:20:48.093748+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": null, "type": "issue_comment", "id": 37754299}, {"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26/comments/37754515.json"}, "html": {"href": "#!/labscript_suite/lyse/issues/26#comment-37754515"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26.json"}}, "type": "issue", "id": 26, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse.json"}, "html": {"href": "#!/labscript_suite/lyse"}, "avatar": {"href": "data/bytebucket.org/ravatar/{55eebdfe-43d1-4ae8-9049-50c55b295397}ts=249921"}}, "type": "repository", "name": "lyse", "full_name": "labscript_suite/lyse", "uuid": "{55eebdfe-43d1-4ae8-9049-50c55b295397}"}, "title": "Loading images takes too long"}, "content": {"raw": "They are 512x512 pixels or less so memory shouldn't be a problem.\n\nThis minimal solution already came to mind, but it would keep images in memory even after the were deleted from the lyse Filebox. This could get really full from one measurement to the next, when not emptied. \nAnd each script would need it's one cache causing even more memory usage if I'm not mistaking.\nAlso the cache would only be populated once the script runs. So there would be no speed improvement if a script is added after all files were loaded and or only runs once. The dataframe-like solution seems superior to me. I also know that this can quickly become a memory issue and is not something everybody needs, but maybe this could become a optional feature in the future that can be switched on an off?\n\nI will definitely give your solution a try though and maybe add some logic to remove shots that are not in the current dataframe anymore.", "markup": "markdown", "html": "<p>They are 512x512 pixels or less so memory shouldn't be a problem.</p>\n<p>This minimal solution already came to mind, but it would keep images in memory even after the were deleted from the lyse Filebox. This could get really full from one measurement to the next, when not emptied. \nAnd each script would need it's one cache causing even more memory usage if I'm not mistaking.\nAlso the cache would only be populated once the script runs. So there would be no speed improvement if a script is added after all files were loaded and or only runs once. The dataframe-like solution seems superior to me. I also know that this can quickly become a memory issue and is not something everybody needs, but maybe this could become a optional feature in the future that can be switched on an off?</p>\n<p>I will definitely give your solution a try though and maybe add some logic to remove shots that are not in the current dataframe anymore.</p>", "type": "rendered"}, "created_on": "2017-06-21T19:33:59.784782+00:00", "user": {"display_name": "Jan Werkmann", "uuid": "{44c4905c-2b90-4045-a5f1-652b8e228626}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D"}, "html": {"href": "https://bitbucket.org/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5/07e5095a-4741-4dc0-a462-9c7d455f961d/128"}}, "nickname": "PhyNerd", "type": "user", "account_id": "557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5"}, "updated_on": "2017-06-21T19:36:01.294430+00:00", "type": "issue_comment", "id": 37754515}, {"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26/comments/37754600.json"}, "html": {"href": "#!/labscript_suite/lyse/issues/26#comment-37754600"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26.json"}}, "type": "issue", "id": 26, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse.json"}, "html": {"href": "#!/labscript_suite/lyse"}, "avatar": {"href": "data/bytebucket.org/ravatar/{55eebdfe-43d1-4ae8-9049-50c55b295397}ts=249921"}}, "type": "repository", "name": "lyse", "full_name": "labscript_suite/lyse", "uuid": "{55eebdfe-43d1-4ae8-9049-50c55b295397}"}, "title": "Loading images takes too long"}, "content": {"raw": "I think I'd broadly support a feature like that - or a way to cache datasets generally regardless of what they are. They can't go in the dataframe easily, as the dataframe is serialised and deserialised repeatedly, but we could with not too much difficulty make a cache that send the images in a binary format - I've sent numpy arrays over zeroMQ sockets (which we use) before and that works well.", "markup": "markdown", "html": "<p>I think I'd broadly support a feature like that - or a way to cache datasets generally regardless of what they are. They can't go in the dataframe easily, as the dataframe is serialised and deserialised repeatedly, but we could with not too much difficulty make a cache that send the images in a binary format - I've sent numpy arrays over zeroMQ sockets (which we use) before and that works well.</p>", "type": "rendered"}, "created_on": "2017-06-21T19:40:34.385644+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": null, "type": "issue_comment", "id": 37754600}, {"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26/comments/37754790.json"}, "html": {"href": "#!/labscript_suite/lyse/issues/26#comment-37754790"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26.json"}}, "type": "issue", "id": 26, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse.json"}, "html": {"href": "#!/labscript_suite/lyse"}, "avatar": {"href": "data/bytebucket.org/ravatar/{55eebdfe-43d1-4ae8-9049-50c55b295397}ts=249921"}}, "type": "repository", "name": "lyse", "full_name": "labscript_suite/lyse", "uuid": "{55eebdfe-43d1-4ae8-9049-50c55b295397}"}, "title": "Loading images takes too long"}, "content": {"raw": "Thats why I said dataframe-like because I wanted something that behaved in the way the dataframe currently does in the following ways:\n\n* gets added to on loading a file (best case) but could also be done upon first usage in a routine\n* is available to all routines\n* allows for getting stuff from only one shot  in singelshot usage(memory is always faster than disk) as well as all of the shots in multishot usage\n\nIt's not really a urgent thing, but just something I wanted to throw out there for discussion. This could have the potential of speeding up things quite a bit when repeatedly using images or other data thats not in the dataframe.", "markup": "markdown", "html": "<p>Thats why I said dataframe-like because I wanted something that behaved in the way the dataframe currently does in the following ways:</p>\n<ul>\n<li>gets added to on loading a file (best case) but could also be done upon first usage in a routine</li>\n<li>is available to all routines</li>\n<li>allows for getting stuff from only one shot  in singelshot usage(memory is always faster than disk) as well as all of the shots in multishot usage</li>\n</ul>\n<p>It's not really a urgent thing, but just something I wanted to throw out there for discussion. This could have the potential of speeding up things quite a bit when repeatedly using images or other data thats not in the dataframe.</p>", "type": "rendered"}, "created_on": "2017-06-21T19:51:39.354805+00:00", "user": {"display_name": "Jan Werkmann", "uuid": "{44c4905c-2b90-4045-a5f1-652b8e228626}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D"}, "html": {"href": "https://bitbucket.org/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5/07e5095a-4741-4dc0-a462-9c7d455f961d/128"}}, "nickname": "PhyNerd", "type": "user", "account_id": "557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5"}, "updated_on": "2017-06-21T19:52:38.586056+00:00", "type": "issue_comment", "id": 37754790}, {"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26/comments/37754841.json"}, "html": {"href": "#!/labscript_suite/lyse/issues/26#comment-37754841"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26.json"}}, "type": "issue", "id": 26, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse.json"}, "html": {"href": "#!/labscript_suite/lyse"}, "avatar": {"href": "data/bytebucket.org/ravatar/{55eebdfe-43d1-4ae8-9049-50c55b295397}ts=249921"}}, "type": "repository", "name": "lyse", "full_name": "labscript_suite/lyse", "uuid": "{55eebdfe-43d1-4ae8-9049-50c55b295397}"}, "title": "Loading images takes too long"}, "content": {"raw": "Yep, fair enough!", "markup": "markdown", "html": "<p>Yep, fair enough!</p>", "type": "rendered"}, "created_on": "2017-06-21T19:54:02.149367+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": null, "type": "issue_comment", "id": 37754841}, {"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26/comments/38261896.json"}, "html": {"href": "#!/labscript_suite/lyse/issues/26#comment-38261896"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26.json"}}, "type": "issue", "id": 26, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse.json"}, "html": {"href": "#!/labscript_suite/lyse"}, "avatar": {"href": "data/bytebucket.org/ravatar/{55eebdfe-43d1-4ae8-9049-50c55b295397}ts=249921"}}, "type": "repository", "name": "lyse", "full_name": "labscript_suite/lyse", "uuid": "{55eebdfe-43d1-4ae8-9049-50c55b295397}"}, "title": "Loading images takes too long"}, "content": {"raw": "Ok so I've been playing around with this and here is what I came up with till now:\n\n```\n#!python\n\nclass StorageServer(ZMQServer):\n    def __init__(self, *args, **kwargs):\n        super(StorageServer, self).__init__(*args, **kwargs)\n        self.storage = {}\n\n    def handler(self, request_data):\n        command, keys, data = request_data\n\n        storage = self.storage\n        if len(keys) > 1:\n            for key in keys[:-1]:\n                if key not in storage:\n                    storage[key] = {}\n                storage = storage[key]\n\n        if command == \"get\":\n            try:\n                return storage[keys[-1]]\n            except KeyError:\n                return None\n            except IndexError:\n                return storage\n\n        elif command == \"set\":\n            storage[keys[-1]] = data\n            return True\n        elif command == \"remove\":\n            try:\n                del storage[keys[-1]]\n            except KeyError and IndexError:\n                return False\n            return True\n        elif command == \"clear\":\n            del self.storage\n            self.storage = {}\n```\n\nThis is a generic StorageServer, that stores data in nested dicts. \nIt allows for saving, getting and deleting data as well as clearing the whole storage.\nThe server expects message of the form [command, index, data]. Command being one of get, set, remove or clear. Index is expected to be a list of Indexes. Data is the data that gets stored otherwise this should be None.\n\nFor a proof of concept I modified the Run.get_images:\n\n```\n#!python\n\n    def get_image(self, orientation, label, image):\n        storage_port = 9999\n        img = zmq_get(storage_port, 'localhost', ['get', ['images', orientation, label, image, self.h5_path], None])\n        if img is None:\n            with h5py.File(self.h5_path) as h5_file:\n                if not 'images' in h5_file:\n                    raise Exception('File does not contain any images')\n                if not orientation in h5_file['images']:\n                    raise Exception('File does not contain any images with orientation \\'%s\\'' % orientation)\n                if not label in h5_file['images'][orientation]:\n                    raise Exception('File does not contain any images with label \\'%s\\'' % label)\n                if not image in h5_file['images'][orientation][label]:\n                    raise Exception('Image \\'%s\\' not found in file' % image)\n                img = array(h5_file['images'][orientation][label][image])\n                zmq_get(storage_port, 'localhost', ['set', ['images', orientation, label, image, self.h5_path], img])\n        return img\n```\n\nand also implemented a get_images function for Multishot routines:\n\n```\n#!python\n\ndef get_images(host='localhost', timeout=5):\n    port = 9999\n    return zmq_get(port, host, ['get', ['images'], None], timeout)\n```\n\nSingleshot routines are not really effected when it comes to speed as they usually just run once. When using get_images instead of something like {run.get_image(...) for path, run in seq.runs.items()} this holds a great speed increase (if the storage has already been filled).\n\nSo we still have to solve the problem of filling the storage upon loading a shot in a away that keep this feature optional for everyone who doesn't need it (so their memory doesn't suffer). Any ideas how this could be done? \nThe server could also be used for other cross analysis routine storage. So we might want to think about some sort of API to make this available.\n\nI'm also open to the idea of running a singleshot script, that does nothing but adding the images to the cross routine storage as this is a simple fix for our problem and doesn't bloat everyones memory. But non the less we would need a API for the storage.\n\nAny thoughts or ideas for improvement?", "markup": "markdown", "html": "<p>Ok so I've been playing around with this and here is what I came up with till now:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">StorageServer</span><span class=\"p\">(</span><span class=\"n\">ZMQServer</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">StorageServer</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">storage</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">handler</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">request_data</span><span class=\"p\">):</span>\n        <span class=\"n\">command</span><span class=\"p\">,</span> <span class=\"n\">keys</span><span class=\"p\">,</span> <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">request_data</span>\n\n        <span class=\"n\">storage</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">storage</span>\n        <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">keys</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n            <span class=\"k\">for</span> <span class=\"n\">key</span> <span class=\"ow\">in</span> <span class=\"n\">keys</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]:</span>\n                <span class=\"k\">if</span> <span class=\"n\">key</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">storage</span><span class=\"p\">:</span>\n                    <span class=\"n\">storage</span><span class=\"p\">[</span><span class=\"n\">key</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n                <span class=\"n\">storage</span> <span class=\"o\">=</span> <span class=\"n\">storage</span><span class=\"p\">[</span><span class=\"n\">key</span><span class=\"p\">]</span>\n\n        <span class=\"k\">if</span> <span class=\"n\">command</span> <span class=\"o\">==</span> <span class=\"s2\">&quot;get&quot;</span><span class=\"p\">:</span>\n            <span class=\"k\">try</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"n\">storage</span><span class=\"p\">[</span><span class=\"n\">keys</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]]</span>\n            <span class=\"k\">except</span> <span class=\"ne\">KeyError</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"bp\">None</span>\n            <span class=\"k\">except</span> <span class=\"ne\">IndexError</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"n\">storage</span>\n\n        <span class=\"k\">elif</span> <span class=\"n\">command</span> <span class=\"o\">==</span> <span class=\"s2\">&quot;set&quot;</span><span class=\"p\">:</span>\n            <span class=\"n\">storage</span><span class=\"p\">[</span><span class=\"n\">keys</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"n\">data</span>\n            <span class=\"k\">return</span> <span class=\"bp\">True</span>\n        <span class=\"k\">elif</span> <span class=\"n\">command</span> <span class=\"o\">==</span> <span class=\"s2\">&quot;remove&quot;</span><span class=\"p\">:</span>\n            <span class=\"k\">try</span><span class=\"p\">:</span>\n                <span class=\"k\">del</span> <span class=\"n\">storage</span><span class=\"p\">[</span><span class=\"n\">keys</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]]</span>\n            <span class=\"k\">except</span> <span class=\"ne\">KeyError</span> <span class=\"ow\">and</span> <span class=\"ne\">IndexError</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"bp\">False</span>\n            <span class=\"k\">return</span> <span class=\"bp\">True</span>\n        <span class=\"k\">elif</span> <span class=\"n\">command</span> <span class=\"o\">==</span> <span class=\"s2\">&quot;clear&quot;</span><span class=\"p\">:</span>\n            <span class=\"k\">del</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">storage</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">storage</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n</pre></div>\n\n\n<p>This is a generic StorageServer, that stores data in nested dicts. \nIt allows for saving, getting and deleting data as well as clearing the whole storage.\nThe server expects message of the form [command, index, data]. Command being one of get, set, remove or clear. Index is expected to be a list of Indexes. Data is the data that gets stored otherwise this should be None.</p>\n<p>For a proof of concept I modified the Run.get_images:</p>\n<div class=\"codehilite language-python\"><pre><span></span>    <span class=\"k\">def</span> <span class=\"nf\">get_image</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">orientation</span><span class=\"p\">,</span> <span class=\"n\">label</span><span class=\"p\">,</span> <span class=\"n\">image</span><span class=\"p\">):</span>\n        <span class=\"n\">storage_port</span> <span class=\"o\">=</span> <span class=\"mi\">9999</span>\n        <span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">zmq_get</span><span class=\"p\">(</span><span class=\"n\">storage_port</span><span class=\"p\">,</span> <span class=\"s1\">&#39;localhost&#39;</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">&#39;get&#39;</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">&#39;images&#39;</span><span class=\"p\">,</span> <span class=\"n\">orientation</span><span class=\"p\">,</span> <span class=\"n\">label</span><span class=\"p\">,</span> <span class=\"n\">image</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">h5_path</span><span class=\"p\">],</span> <span class=\"bp\">None</span><span class=\"p\">])</span>\n        <span class=\"k\">if</span> <span class=\"n\">img</span> <span class=\"ow\">is</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n            <span class=\"k\">with</span> <span class=\"n\">h5py</span><span class=\"o\">.</span><span class=\"n\">File</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">h5_path</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">h5_file</span><span class=\"p\">:</span>\n                <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"s1\">&#39;images&#39;</span> <span class=\"ow\">in</span> <span class=\"n\">h5_file</span><span class=\"p\">:</span>\n                    <span class=\"k\">raise</span> <span class=\"ne\">Exception</span><span class=\"p\">(</span><span class=\"s1\">&#39;File does not contain any images&#39;</span><span class=\"p\">)</span>\n                <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">orientation</span> <span class=\"ow\">in</span> <span class=\"n\">h5_file</span><span class=\"p\">[</span><span class=\"s1\">&#39;images&#39;</span><span class=\"p\">]:</span>\n                    <span class=\"k\">raise</span> <span class=\"ne\">Exception</span><span class=\"p\">(</span><span class=\"s1\">&#39;File does not contain any images with orientation </span><span class=\"se\">\\&#39;</span><span class=\"si\">%s</span><span class=\"se\">\\&#39;</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"n\">orientation</span><span class=\"p\">)</span>\n                <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">label</span> <span class=\"ow\">in</span> <span class=\"n\">h5_file</span><span class=\"p\">[</span><span class=\"s1\">&#39;images&#39;</span><span class=\"p\">][</span><span class=\"n\">orientation</span><span class=\"p\">]:</span>\n                    <span class=\"k\">raise</span> <span class=\"ne\">Exception</span><span class=\"p\">(</span><span class=\"s1\">&#39;File does not contain any images with label </span><span class=\"se\">\\&#39;</span><span class=\"si\">%s</span><span class=\"se\">\\&#39;</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"n\">label</span><span class=\"p\">)</span>\n                <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">image</span> <span class=\"ow\">in</span> <span class=\"n\">h5_file</span><span class=\"p\">[</span><span class=\"s1\">&#39;images&#39;</span><span class=\"p\">][</span><span class=\"n\">orientation</span><span class=\"p\">][</span><span class=\"n\">label</span><span class=\"p\">]:</span>\n                    <span class=\"k\">raise</span> <span class=\"ne\">Exception</span><span class=\"p\">(</span><span class=\"s1\">&#39;Image </span><span class=\"se\">\\&#39;</span><span class=\"si\">%s</span><span class=\"se\">\\&#39;</span><span class=\"s1\"> not found in file&#39;</span> <span class=\"o\">%</span> <span class=\"n\">image</span><span class=\"p\">)</span>\n                <span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">h5_file</span><span class=\"p\">[</span><span class=\"s1\">&#39;images&#39;</span><span class=\"p\">][</span><span class=\"n\">orientation</span><span class=\"p\">][</span><span class=\"n\">label</span><span class=\"p\">][</span><span class=\"n\">image</span><span class=\"p\">])</span>\n                <span class=\"n\">zmq_get</span><span class=\"p\">(</span><span class=\"n\">storage_port</span><span class=\"p\">,</span> <span class=\"s1\">&#39;localhost&#39;</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">&#39;set&#39;</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">&#39;images&#39;</span><span class=\"p\">,</span> <span class=\"n\">orientation</span><span class=\"p\">,</span> <span class=\"n\">label</span><span class=\"p\">,</span> <span class=\"n\">image</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">h5_path</span><span class=\"p\">],</span> <span class=\"n\">img</span><span class=\"p\">])</span>\n        <span class=\"k\">return</span> <span class=\"n\">img</span>\n</pre></div>\n\n\n<p>and also implemented a get_images function for Multishot routines:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">get_images</span><span class=\"p\">(</span><span class=\"n\">host</span><span class=\"o\">=</span><span class=\"s1\">&#39;localhost&#39;</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">):</span>\n    <span class=\"n\">port</span> <span class=\"o\">=</span> <span class=\"mi\">9999</span>\n    <span class=\"k\">return</span> <span class=\"n\">zmq_get</span><span class=\"p\">(</span><span class=\"n\">port</span><span class=\"p\">,</span> <span class=\"n\">host</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">&#39;get&#39;</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">&#39;images&#39;</span><span class=\"p\">],</span> <span class=\"bp\">None</span><span class=\"p\">],</span> <span class=\"n\">timeout</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>Singleshot routines are not really effected when it comes to speed as they usually just run once. When using get_images instead of something like {run.get_image(...) for path, run in seq.runs.items()} this holds a great speed increase (if the storage has already been filled).</p>\n<p>So we still have to solve the problem of filling the storage upon loading a shot in a away that keep this feature optional for everyone who doesn't need it (so their memory doesn't suffer). Any ideas how this could be done? \nThe server could also be used for other cross analysis routine storage. So we might want to think about some sort of API to make this available.</p>\n<p>I'm also open to the idea of running a singleshot script, that does nothing but adding the images to the cross routine storage as this is a simple fix for our problem and doesn't bloat everyones memory. But non the less we would need a API for the storage.</p>\n<p>Any thoughts or ideas for improvement?</p>", "type": "rendered"}, "created_on": "2017-07-16T14:30:03.648760+00:00", "user": {"display_name": "Jan Werkmann", "uuid": "{44c4905c-2b90-4045-a5f1-652b8e228626}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D"}, "html": {"href": "https://bitbucket.org/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5/07e5095a-4741-4dc0-a462-9c7d455f961d/128"}}, "nickname": "PhyNerd", "type": "user", "account_id": "557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5"}, "updated_on": "2017-07-16T18:21:23.873840+00:00", "type": "issue_comment", "id": 38261896}, {"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26/comments/38272393.json"}, "html": {"href": "#!/labscript_suite/lyse/issues/26#comment-38272393"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26.json"}}, "type": "issue", "id": 26, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse.json"}, "html": {"href": "#!/labscript_suite/lyse"}, "avatar": {"href": "data/bytebucket.org/ravatar/{55eebdfe-43d1-4ae8-9049-50c55b295397}ts=249921"}}, "type": "repository", "name": "lyse", "full_name": "labscript_suite/lyse", "uuid": "{55eebdfe-43d1-4ae8-9049-50c55b295397}"}, "title": "Loading images takes too long"}, "content": {"raw": "Did a bit of playing around with the storage.\nStoring Runs in a dict in Storage instead of creating a sequence object(that then internally creates lots of runs) every time also holds a great speed improvement for lange amounts of shots. This might also be worth looking into.", "markup": "markdown", "html": "<p>Did a bit of playing around with the storage.\nStoring Runs in a dict in Storage instead of creating a sequence object(that then internally creates lots of runs) every time also holds a great speed improvement for lange amounts of shots. This might also be worth looking into.</p>", "type": "rendered"}, "created_on": "2017-07-17T09:00:56.644202+00:00", "user": {"display_name": "Jan Werkmann", "uuid": "{44c4905c-2b90-4045-a5f1-652b8e228626}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D"}, "html": {"href": "https://bitbucket.org/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5/07e5095a-4741-4dc0-a462-9c7d455f961d/128"}}, "nickname": "PhyNerd", "type": "user", "account_id": "557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5"}, "updated_on": null, "type": "issue_comment", "id": 38272393}, {"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26/comments/39014892.json"}, "html": {"href": "#!/labscript_suite/lyse/issues/26#comment-39014892"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/26.json"}}, "type": "issue", "id": 26, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse.json"}, "html": {"href": "#!/labscript_suite/lyse"}, "avatar": {"href": "data/bytebucket.org/ravatar/{55eebdfe-43d1-4ae8-9049-50c55b295397}ts=249921"}}, "type": "repository", "name": "lyse", "full_name": "labscript_suite/lyse", "uuid": "{55eebdfe-43d1-4ae8-9049-50c55b295397}"}, "title": "Loading images takes too long"}, "content": {"raw": "I created a branch for my corss routine storage/cached images and runs stuff over on my repo.([here](#!/PhyNerd/lyse/branch/cross-routine-storage)) \n\nThe storage is a extension to Lyses server. The storage is made up of nested dicts, allowing hierarchical indexes and stores anything that zmq_get will send. One can save, get and delete enteries from storage. \n\nI also added the option to automatically cache images (on first load) and multishot sequence runs (on first creation). This gives me a drastic speed increase in my multishot scripts. If a shot gets removed from lyse the cached entries from that shot are removed as well to reduce memory usage. \n\nWe are already running lyse with these changes in our lab. Before caching one of our scripts using images (with 2000 shots loaded equaling 4000 images) ran for 17 seconds after the change it is running sub 1 second. \n\nThe options for caching(on/off and timeout) are currently a variable that is hardcoded in the init file. I'm not that happy with having it hardcoded but also not sure where to put it. I would personally opt for putting it into labconfig. \n\nAny ideas for improvement or ideas on where to put the option to enable/disable caching? I'd also like to create a pull request for this sometime in the near future (but have too many open pull requests at the moment as is) so input is much appreciated.", "markup": "markdown", "html": "<p>I created a branch for my corss routine storage/cached images and runs stuff over on my repo.(<a data-is-external-link=\"true\" href=\"#!/PhyNerd/lyse/branch/cross-routine-storage\" rel=\"nofollow\">here</a>) </p>\n<p>The storage is a extension to Lyses server. The storage is made up of nested dicts, allowing hierarchical indexes and stores anything that zmq_get will send. One can save, get and delete enteries from storage. </p>\n<p>I also added the option to automatically cache images (on first load) and multishot sequence runs (on first creation). This gives me a drastic speed increase in my multishot scripts. If a shot gets removed from lyse the cached entries from that shot are removed as well to reduce memory usage. </p>\n<p>We are already running lyse with these changes in our lab. Before caching one of our scripts using images (with 2000 shots loaded equaling 4000 images) ran for 17 seconds after the change it is running sub 1 second. </p>\n<p>The options for caching(on/off and timeout) are currently a variable that is hardcoded in the init file. I'm not that happy with having it hardcoded but also not sure where to put it. I would personally opt for putting it into labconfig. </p>\n<p>Any ideas for improvement or ideas on where to put the option to enable/disable caching? I'd also like to create a pull request for this sometime in the near future (but have too many open pull requests at the moment as is) so input is much appreciated.</p>", "type": "rendered"}, "created_on": "2017-08-10T14:04:00.893986+00:00", "user": {"display_name": "Jan Werkmann", "uuid": "{44c4905c-2b90-4045-a5f1-652b8e228626}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D"}, "html": {"href": "https://bitbucket.org/%7B44c4905c-2b90-4045-a5f1-652b8e228626%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5/07e5095a-4741-4dc0-a462-9c7d455f961d/128"}}, "nickname": "PhyNerd", "type": "user", "account_id": "557058:a70cc9cf-684e-4849-a61a-9ade4d7218b5"}, "updated_on": "2017-08-10T15:58:49.878846+00:00", "type": "issue_comment", "id": 39014892}], "page": 1, "size": 9}