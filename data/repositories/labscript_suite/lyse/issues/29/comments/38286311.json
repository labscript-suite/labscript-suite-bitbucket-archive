{"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/29/comments/38286311.json"}, "html": {"href": "#!/labscript_suite/lyse/issues/29#comment-38286311"}}, "issue": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse/issues/29.json"}}, "type": "issue", "id": 29, "repository": {"links": {"self": {"href": "data/repositories/labscript_suite/lyse.json"}, "html": {"href": "#!/labscript_suite/lyse"}, "avatar": {"href": "data/bytebucket.org/ravatar/{55eebdfe-43d1-4ae8-9049-50c55b295397}ts=249921"}}, "type": "repository", "name": "lyse", "full_name": "labscript_suite/lyse", "uuid": "{55eebdfe-43d1-4ae8-9049-50c55b295397}"}, "title": "speed up shot loading"}, "content": {"raw": "If you're posting code changes for discussion, it would be nice if you could post diffs for ease of seeing what has changed. You can run `hg diff somefile.py` from a terminal to get the diff text and post it here in a code environment with 'diff' as the language.\n\nI don't think allowing `update_row()` to take a `df_row_index` argument is a good idea *in general*. The reason is that since `update_row()` can be called from outside the main thread, any thread computing a row index and then calling `update_row()` runs the risk of the row index having changed before `update_row()` actually runs. By accepting the filepath instead, `update_row` ensures that it never has out of date information, as the filepath cannot change. \n\nHowever, if `add_files()` is the only caller using the `df_row_index` argument then that's fine, as `add_files()` itself runs in the main thread and so can be sure that nothing has changed in between its determination of the row number and the call to `update_row`. And performance optimisations are often compromises on making interfaces as pure as you'd like them to be, so I think I'm happy to accept this as a performance optimisation if it really is a significant speedup.\n\nOne way to prevent the race condition from biting anyone in the future if they use `df_row_index` argument from a non-main thread is to confirm that the filepath matches. You could have `add_files()` still pass in the filepath argument (rather than None),  and then have `update_row()` have a check like:\n\n\n```\n#!python\n\n# If df_row_index was used, check the row actually matches the filepath.\n# This might be the case if the caller was not in the main thread, which\n# is a situation vulnerable to race conditions:\nassert filepath == dataframe_row['filepath', '']\n```\n\nThis should be a factor of *n* faster than actually looking up the filepath, whilst ensuring race conditions don't cause invisible bugs in the future.\n\n\nI can see though how the line\n\n```\n#!python\n\ndf_row_index = np.where(self.dataframe['filepath'].values == filepath)\n```\n\ncould be a problem for performance. If you're calling it for every update, then it searches through the dataframe once for every file and so updating n files runs in quadratic time in n. \n\nWhen you say a factor of two, do you mean that the `update_row` function is two times faster without this search than with it? If so that's quite a speedup!\n\nThere are other ways to optimise lookups rather than searching. For example in sql databases you can \"index\" a column to speed up searches for rows that have a particular value. I don't know if pandas supports anything like this (googling for \"pandas index column\" obviously gives many irrelevant results), but we could also do that manually by maintaining a dictionary containing a filepath:row_index mapping that is updated whenever a row is added or removed (or rows re-ordered which we don't currently support but might in future).\n\nBut your solution with theabove  added check should be entirely sufficient. If there are similar slow searches through dataframes elsewhere in the code though that you hit upon, this other approach might be worth considering. Pandas people seem to care a lot about performance so it's possible that this functionality is built-in somewhere if you can work out what to type into google to find it.", "markup": "markdown", "html": "<p>If you're posting code changes for discussion, it would be nice if you could post diffs for ease of seeing what has changed. You can run <code>hg diff somefile.py</code> from a terminal to get the diff text and post it here in a code environment with 'diff' as the language.</p>\n<p>I don't think allowing <code>update_row()</code> to take a <code>df_row_index</code> argument is a good idea <em>in general</em>. The reason is that since <code>update_row()</code> can be called from outside the main thread, any thread computing a row index and then calling <code>update_row()</code> runs the risk of the row index having changed before <code>update_row()</code> actually runs. By accepting the filepath instead, <code>update_row</code> ensures that it never has out of date information, as the filepath cannot change. </p>\n<p>However, if <code>add_files()</code> is the only caller using the <code>df_row_index</code> argument then that's fine, as <code>add_files()</code> itself runs in the main thread and so can be sure that nothing has changed in between its determination of the row number and the call to <code>update_row</code>. And performance optimisations are often compromises on making interfaces as pure as you'd like them to be, so I think I'm happy to accept this as a performance optimisation if it really is a significant speedup.</p>\n<p>One way to prevent the race condition from biting anyone in the future if they use <code>df_row_index</code> argument from a non-main thread is to confirm that the filepath matches. You could have <code>add_files()</code> still pass in the filepath argument (rather than None),  and then have <code>update_row()</code> have a check like:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"c1\"># If df_row_index was used, check the row actually matches the filepath.</span>\n<span class=\"c1\"># This might be the case if the caller was not in the main thread, which</span>\n<span class=\"c1\"># is a situation vulnerable to race conditions:</span>\n<span class=\"k\">assert</span> <span class=\"n\">filepath</span> <span class=\"o\">==</span> <span class=\"n\">dataframe_row</span><span class=\"p\">[</span><span class=\"s1\">&#39;filepath&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;&#39;</span><span class=\"p\">]</span>\n</pre></div>\n\n\n<p>This should be a factor of <em>n</em> faster than actually looking up the filepath, whilst ensuring race conditions don't cause invisible bugs in the future.</p>\n<p>I can see though how the line</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"n\">df_row_index</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">where</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">dataframe</span><span class=\"p\">[</span><span class=\"s1\">&#39;filepath&#39;</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">values</span> <span class=\"o\">==</span> <span class=\"n\">filepath</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>could be a problem for performance. If you're calling it for every update, then it searches through the dataframe once for every file and so updating n files runs in quadratic time in n. </p>\n<p>When you say a factor of two, do you mean that the <code>update_row</code> function is two times faster without this search than with it? If so that's quite a speedup!</p>\n<p>There are other ways to optimise lookups rather than searching. For example in sql databases you can \"index\" a column to speed up searches for rows that have a particular value. I don't know if pandas supports anything like this (googling for \"pandas index column\" obviously gives many irrelevant results), but we could also do that manually by maintaining a dictionary containing a filepath:row_index mapping that is updated whenever a row is added or removed (or rows re-ordered which we don't currently support but might in future).</p>\n<p>But your solution with theabove  added check should be entirely sufficient. If there are similar slow searches through dataframes elsewhere in the code though that you hit upon, this other approach might be worth considering. Pandas people seem to care a lot about performance so it's possible that this functionality is built-in somewhere if you can work out what to type into google to find it.</p>", "type": "rendered"}, "created_on": "2017-07-17T18:40:03.474690+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": null, "type": "issue_comment", "id": 38286311}