{"links": {"self": {"href": "data/repositories/labscript_suite/lyse/pullrequests/17/comments/39222130.json"}, "html": {"href": "#!/labscript_suite/lyse/pull-requests/17/_/diff#comment-39222130"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 17, "links": {"self": {"href": "data/repositories/labscript_suite/lyse/pullrequests/17.json"}, "html": {"href": "#!/labscript_suite/lyse/pull-requests/17"}}, "title": "Update Dataframe without Readoperations"}, "content": {"raw": "Ok, quibbles:\n\n- It would be good to prefix `updated_data` with an underscore to ensure that \"from lyse import *\" doesn't import it, and to indicate to users that it's an internal detail they shouldn't be directly using. You should also prefix its definition with a comment along the lines of ` # data to be sent back to the lyse GUI if running within lyse`\n\n- The code:\n\n\n```\n#!python\n\n        if spinning_top:\n            if self.h5_path not in updated_data:\n                updated_data[self.h5_path] = []\n            updated_data[self.h5_path].append((self.group, name, value))\n```\nShould change to:\n\n\n```\n#!python\n\n        if spinning_top:\n            if self.h5_path not in updated_data:\n                updated_data[self.h5_path] = {}\n            updated_data[self.h5_path][self.group, name] = value\n```\nsince it is legal to overwrite a previous `save_result()` with another within the same script - the new value overwrites the old in the hdf5 file, and so it should overwrite it in the `updated_data` dictionary as well (obviously your logic downstream will need to change to reflect that it's dealing with a dictionary rather than a list).\n\n- Rather than doing the dataframe logic in `do_singleshot_analysis()`, you should do something like this (the if statement just checking if `updated_data` is an empty dictionary):\n\n```\n#!python\n\n            if signal in ['error', 'progress']:\n                if updated_data:\n                    self.shots_model.update_row(filepath, status_percent=status_percent, updated_row_data=updated_data)\n                else:\n                    self.shots_model.update_row(filepath, status_percent=status_percent)\n```\n\nAnd then put the logic for turning the `updated_data` dict into `new_row_data` into `DataFrameModel.update_row()`, adding a new keyword argument `updated_row_data`. This way `FileBox` doesn't read the dataframe columns - as a general principle it shouldn't be directly dealing with the dataframe. The multishot updating should be changed in the same way. Another important reason for the `do_singleshot_analysis()` and  `do_multishot_analysis()` functions to not touch the dataframe directly, even to only read its columns, is that since they are not running in the GUI thread, which all modifications to the dataframe occur in, the dataframe columns might change at any time (say if files are arriving from BLACS that have newly defined runmanager globals), and this will change the dataframe columns potentially making the `new_row_data` incorrect. `DataFrameModel.update_row()` on the other hand runs in the GUI thread, so that's where that logic shoudl be done. The comment about saving time by being outseide the GUI thread applies to reading the shot files, which is indeed slow (but even then the comment is a bit wrong because h5py holds the GIL, which does block the GUI regardless of what thread you're in). But converting a dictionary to a dataframe is such a lightweight thing that there's no benefit to avoiding doing that in the GUI thread.\n\nSo putting that logic at the top of `DataFrameModel.update_row()`, something like:\n\n```\n#!python\n\nif (new_row_data is None) == (updated_row_data is None):\n    raise ValueError('Exactly one of new_row_data or updated_row_data must be provided')\n\nif updated_row_data is not None:\n    new_row_data = # do the logic here\n\n```\n\nWhen converting dictionaries into dataframes, you should see whether any of the functions in `lyse.dataframe_utilities` do what you want. `flat_dict_to_hierarchical_dataframe()` and `concat_with_padding()` look like they might be useful. They are what we use to make the dataframes out of dictionaries in the first place, so re-using them if they apply would be good.", "markup": "markdown", "html": "<p>Ok, quibbles:</p>\n<ul>\n<li>\n<p>It would be good to prefix <code>updated_data</code> with an underscore to ensure that \"from lyse import *\" doesn't import it, and to indicate to users that it's an internal detail they shouldn't be directly using. You should also prefix its definition with a comment along the lines of <code># data to be sent back to the lyse GUI if running within lyse</code></p>\n</li>\n<li>\n<p>The code:</p>\n</li>\n</ul>\n<div class=\"codehilite language-python\"><pre><span></span>        <span class=\"k\">if</span> <span class=\"n\">spinning_top</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">h5_path</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">updated_data</span><span class=\"p\">:</span>\n                <span class=\"n\">updated_data</span><span class=\"p\">[</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">h5_path</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n            <span class=\"n\">updated_data</span><span class=\"p\">[</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">h5_path</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">group</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">))</span>\n</pre></div>\n\n\n<p>Should change to:</p>\n<div class=\"codehilite language-python\"><pre><span></span>        <span class=\"k\">if</span> <span class=\"n\">spinning_top</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">h5_path</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">updated_data</span><span class=\"p\">:</span>\n                <span class=\"n\">updated_data</span><span class=\"p\">[</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">h5_path</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n            <span class=\"n\">updated_data</span><span class=\"p\">[</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">h5_path</span><span class=\"p\">][</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">group</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n</pre></div>\n\n\n<p>since it is legal to overwrite a previous <code>save_result()</code> with another within the same script - the new value overwrites the old in the hdf5 file, and so it should overwrite it in the <code>updated_data</code> dictionary as well (obviously your logic downstream will need to change to reflect that it's dealing with a dictionary rather than a list).</p>\n<ul>\n<li>Rather than doing the dataframe logic in <code>do_singleshot_analysis()</code>, you should do something like this (the if statement just checking if <code>updated_data</code> is an empty dictionary):</li>\n</ul>\n<div class=\"codehilite language-python\"><pre><span></span>            <span class=\"k\">if</span> <span class=\"n\">signal</span> <span class=\"ow\">in</span> <span class=\"p\">[</span><span class=\"s1\">&#39;error&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;progress&#39;</span><span class=\"p\">]:</span>\n                <span class=\"k\">if</span> <span class=\"n\">updated_data</span><span class=\"p\">:</span>\n                    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shots_model</span><span class=\"o\">.</span><span class=\"n\">update_row</span><span class=\"p\">(</span><span class=\"n\">filepath</span><span class=\"p\">,</span> <span class=\"n\">status_percent</span><span class=\"o\">=</span><span class=\"n\">status_percent</span><span class=\"p\">,</span> <span class=\"n\">updated_row_data</span><span class=\"o\">=</span><span class=\"n\">updated_data</span><span class=\"p\">)</span>\n                <span class=\"k\">else</span><span class=\"p\">:</span>\n                    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shots_model</span><span class=\"o\">.</span><span class=\"n\">update_row</span><span class=\"p\">(</span><span class=\"n\">filepath</span><span class=\"p\">,</span> <span class=\"n\">status_percent</span><span class=\"o\">=</span><span class=\"n\">status_percent</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>And then put the logic for turning the <code>updated_data</code> dict into <code>new_row_data</code> into <code>DataFrameModel.update_row()</code>, adding a new keyword argument <code>updated_row_data</code>. This way <code>FileBox</code> doesn't read the dataframe columns - as a general principle it shouldn't be directly dealing with the dataframe. The multishot updating should be changed in the same way. Another important reason for the <code>do_singleshot_analysis()</code> and  <code>do_multishot_analysis()</code> functions to not touch the dataframe directly, even to only read its columns, is that since they are not running in the GUI thread, which all modifications to the dataframe occur in, the dataframe columns might change at any time (say if files are arriving from BLACS that have newly defined runmanager globals), and this will change the dataframe columns potentially making the <code>new_row_data</code> incorrect. <code>DataFrameModel.update_row()</code> on the other hand runs in the GUI thread, so that's where that logic shoudl be done. The comment about saving time by being outseide the GUI thread applies to reading the shot files, which is indeed slow (but even then the comment is a bit wrong because h5py holds the GIL, which does block the GUI regardless of what thread you're in). But converting a dictionary to a dataframe is such a lightweight thing that there's no benefit to avoiding doing that in the GUI thread.</p>\n<p>So putting that logic at the top of <code>DataFrameModel.update_row()</code>, something like:</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">new_row_data</span> <span class=\"ow\">is</span> <span class=\"bp\">None</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"n\">updated_row_data</span> <span class=\"ow\">is</span> <span class=\"bp\">None</span><span class=\"p\">):</span>\n    <span class=\"k\">raise</span> <span class=\"ne\">ValueError</span><span class=\"p\">(</span><span class=\"s1\">&#39;Exactly one of new_row_data or updated_row_data must be provided&#39;</span><span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"n\">updated_row_data</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">new_row_data</span> <span class=\"o\">=</span> <span class=\"c1\"># do the logic here</span>\n</pre></div>\n\n\n<p>When converting dictionaries into dataframes, you should see whether any of the functions in <code>lyse.dataframe_utilities</code> do what you want. <code>flat_dict_to_hierarchical_dataframe()</code> and <code>concat_with_padding()</code> look like they might be useful. They are what we use to make the dataframes out of dictionaries in the first place, so re-using them if they apply would be good.</p>", "type": "rendered"}, "created_on": "2017-06-20T21:21:54.697052+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-06-20T23:28:17.527255+00:00", "type": "pullrequest_comment", "id": 39222130}