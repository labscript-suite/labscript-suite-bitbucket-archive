{"links": {"self": {"href": "data/repositories/labscript_suite/lyse/pullrequests/18/comments/41381608.json"}, "html": {"href": "#!/labscript_suite/lyse/pull-requests/18/_/diff#comment-41381608"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 18, "links": {"self": {"href": "data/repositories/labscript_suite/lyse/pullrequests/18.json"}, "html": {"href": "#!/labscript_suite/lyse/pull-requests/18"}}, "title": "Added ability to restore UI state"}, "content": {"raw": "I've tested a bit and there doesn't seem to be any obvious breakage. Two suggestions:\n\n1. Every time a config option is loaded, the code should allow for the possibility that the option doesn't exist (like runmanager does). This allows us to add more options in the future and have people's existing config files keep working after the update.\n\n2. When you load a configuration using the menu option, it adds saved routines, but it does not *remove* routines that are present in the GUI but not in the config file being loaded.\n\nThe below patch addresses these two issues:\n\n\n```\n#!diff\n\n--- a/__main__.py\tFri Jul 07 14:34:25 2017 +0200\n+++ b/__main__.py\tMon Jul 24 15:36:49 2017 -0400\n@@ -526,8 +526,16 @@\n         self.last_opened_routine_folder = os.path.dirname(routine_files[0])\n         self.add_routines([(routine_file, QtCore.Qt.Checked) for routine_file in routine_files])\n \n-    def add_routines(self, routine_files):\n-        # Queue the files to be opened:\n+    def add_routines(self, routine_files, clear_existing=False):\n+        \"\"\"Add routines to the routine box, where routine_files is a list of\n+        tuples containing the filepath and whether the routine is enabled or\n+        not when it is added. if clear_existing == True, then any existing\n+        analysis routines will be cleared before the new ones are added.\"\"\"\n+        if clear_existing:\n+            for routine in self.routines[:]:\n+                routine.remove()\n+                self.routines.remove(routine)\n+\n         for filepath, checked in routine_files:\n             if filepath in [routine.filepath for routine in self.routines]:\n                 app.output_box.output('Warning: Ignoring duplicate analysis routine %s\\n'%filepath, red=True)\n@@ -1938,12 +1946,27 @@\n         self.ui.actionSave_configuration.setText('Save configuration %s'%filename)\n         lyse_config = LabConfig(filename)\n \n-        self.singleshot_routinebox.add_routines(ast.literal_eval(lyse_config.get('lyse_state', 'SingleShot')))\n-        self.singleshot_routinebox.last_opened_routine_folder = ast.literal_eval(lyse_config.get('lyse_state', 'LastSingleShotFolder'))\n-        self.multishot_routinebox.add_routines(ast.literal_eval(lyse_config.get('lyse_state', 'MultiShot')))\n-        self.multishot_routinebox.last_opened_routine_folder = ast.literal_eval(lyse_config.get('lyse_state', 'LastMultiShotFolder'))\n-        self.filebox.last_opened_shots_folder = ast.literal_eval(lyse_config.get('lyse_state', 'LastFileBoxFolder'))\n-\n+        try:\n+            self.singleshot_routinebox.add_routines(ast.literal_eval(lyse_config.get('lyse_state', 'SingleShot')), clear_existing=True)\n+        except LabConfig.NoOptionError:\n+            pass\n+        try:\n+            self.singleshot_routinebox.last_opened_routine_folder = ast.literal_eval(lyse_config.get('lyse_state', 'LastSingleShotFolder'))\n+        except LabConfig.NoOptionError:\n+            pass\n+        try:\n+            self.multishot_routinebox.add_routines(ast.literal_eval(lyse_config.get('lyse_state', 'MultiShot')), clear_existing=True)\n+        except LabConfig.NoOptionError:\n+            pass\n+        try:\n+            self.multishot_routinebox.last_opened_routine_folder = ast.literal_eval(lyse_config.get('lyse_state', 'LastMultiShotFolder'))\n+        except LabConfig.NoOptionError:\n+            pass\n+        try:\n+            self.filebox.last_opened_shots_folder = ast.literal_eval(lyse_config.get('lyse_state', 'LastFileBoxFolder'))\n+        except LabConfig.NoOptionError:\n+            pass\n \n         # Set as self.last_save_data:\n         save_data = self.get_save_data()\n```\n\nThe clearing of existing routines does mean that if you're loading a config file with some of the *same* routines as are already loaded, those routines will be removed and re-added, which restarts their subprocess unnecessarily. I don't think this is a big enough deal to worry about, though.", "markup": "markdown", "html": "<p>I've tested a bit and there doesn't seem to be any obvious breakage. Two suggestions:</p>\n<ol>\n<li>\n<p>Every time a config option is loaded, the code should allow for the possibility that the option doesn't exist (like runmanager does). This allows us to add more options in the future and have people's existing config files keep working after the update.</p>\n</li>\n<li>\n<p>When you load a configuration using the menu option, it adds saved routines, but it does not <em>remove</em> routines that are present in the GUI but not in the config file being loaded.</p>\n</li>\n</ol>\n<p>The below patch addresses these two issues:</p>\n<div class=\"codehilite language-diff\"><pre><span></span><span class=\"gd\">--- a/__main__.py   Fri Jul 07 14:34:25 2017 +0200</span>\n<span class=\"gi\">+++ b/__main__.py   Mon Jul 24 15:36:49 2017 -0400</span>\n<span class=\"gu\">@@ -526,8 +526,16 @@</span>\n         self.last_opened_routine_folder = os.path.dirname(routine_files[0])\n         self.add_routines([(routine_file, QtCore.Qt.Checked) for routine_file in routine_files])\n\n<span class=\"gd\">-    def add_routines(self, routine_files):</span>\n<span class=\"gd\">-        # Queue the files to be opened:</span>\n<span class=\"gi\">+    def add_routines(self, routine_files, clear_existing=False):</span>\n<span class=\"gi\">+        &quot;&quot;&quot;Add routines to the routine box, where routine_files is a list of</span>\n<span class=\"gi\">+        tuples containing the filepath and whether the routine is enabled or</span>\n<span class=\"gi\">+        not when it is added. if clear_existing == True, then any existing</span>\n<span class=\"gi\">+        analysis routines will be cleared before the new ones are added.&quot;&quot;&quot;</span>\n<span class=\"gi\">+        if clear_existing:</span>\n<span class=\"gi\">+            for routine in self.routines[:]:</span>\n<span class=\"gi\">+                routine.remove()</span>\n<span class=\"gi\">+                self.routines.remove(routine)</span>\n<span class=\"gi\">+</span>\n         for filepath, checked in routine_files:\n             if filepath in [routine.filepath for routine in self.routines]:\n                 app.output_box.output(&#39;Warning: Ignoring duplicate analysis routine %s\\n&#39;%filepath, red=True)\n<span class=\"gu\">@@ -1938,12 +1946,27 @@</span>\n         self.ui.actionSave_configuration.setText(&#39;Save configuration %s&#39;%filename)\n         lyse_config = LabConfig(filename)\n\n<span class=\"gd\">-        self.singleshot_routinebox.add_routines(ast.literal_eval(lyse_config.get(&#39;lyse_state&#39;, &#39;SingleShot&#39;)))</span>\n<span class=\"gd\">-        self.singleshot_routinebox.last_opened_routine_folder = ast.literal_eval(lyse_config.get(&#39;lyse_state&#39;, &#39;LastSingleShotFolder&#39;))</span>\n<span class=\"gd\">-        self.multishot_routinebox.add_routines(ast.literal_eval(lyse_config.get(&#39;lyse_state&#39;, &#39;MultiShot&#39;)))</span>\n<span class=\"gd\">-        self.multishot_routinebox.last_opened_routine_folder = ast.literal_eval(lyse_config.get(&#39;lyse_state&#39;, &#39;LastMultiShotFolder&#39;))</span>\n<span class=\"gd\">-        self.filebox.last_opened_shots_folder = ast.literal_eval(lyse_config.get(&#39;lyse_state&#39;, &#39;LastFileBoxFolder&#39;))</span>\n<span class=\"gd\">-</span>\n<span class=\"gi\">+        try:</span>\n<span class=\"gi\">+            self.singleshot_routinebox.add_routines(ast.literal_eval(lyse_config.get(&#39;lyse_state&#39;, &#39;SingleShot&#39;)), clear_existing=True)</span>\n<span class=\"gi\">+        except LabConfig.NoOptionError:</span>\n<span class=\"gi\">+            pass</span>\n<span class=\"gi\">+        try:</span>\n<span class=\"gi\">+            self.singleshot_routinebox.last_opened_routine_folder = ast.literal_eval(lyse_config.get(&#39;lyse_state&#39;, &#39;LastSingleShotFolder&#39;))</span>\n<span class=\"gi\">+        except LabConfig.NoOptionError:</span>\n<span class=\"gi\">+            pass</span>\n<span class=\"gi\">+        try:</span>\n<span class=\"gi\">+            self.multishot_routinebox.add_routines(ast.literal_eval(lyse_config.get(&#39;lyse_state&#39;, &#39;MultiShot&#39;)), clear_existing=True)</span>\n<span class=\"gi\">+        except LabConfig.NoOptionError:</span>\n<span class=\"gi\">+            pass</span>\n<span class=\"gi\">+        try:</span>\n<span class=\"gi\">+            self.multishot_routinebox.last_opened_routine_folder = ast.literal_eval(lyse_config.get(&#39;lyse_state&#39;, &#39;LastMultiShotFolder&#39;))</span>\n<span class=\"gi\">+        except LabConfig.NoOptionError:</span>\n<span class=\"gi\">+            pass</span>\n<span class=\"gi\">+        try:</span>\n<span class=\"gi\">+            self.filebox.last_opened_shots_folder = ast.literal_eval(lyse_config.get(&#39;lyse_state&#39;, &#39;LastFileBoxFolder&#39;))</span>\n<span class=\"gi\">+        except LabConfig.NoOptionError:</span>\n<span class=\"gi\">+            pass</span>\n\n         # Set as self.last_save_data:\n         save_data = self.get_save_data()\n</pre></div>\n\n\n<p>The clearing of existing routines does mean that if you're loading a config file with some of the <em>same</em> routines as are already loaded, those routines will be removed and re-added, which restarts their subprocess unnecessarily. I don't think this is a big enough deal to worry about, though.</p>", "type": "rendered"}, "created_on": "2017-07-24T19:42:18.828812+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-07-24T19:46:06.343247+00:00", "type": "pullrequest_comment", "id": 41381608}