{"links": {"self": {"href": "data/repositories/labscript_suite/lyse/pullrequests/22/comments/41557505.json"}, "html": {"href": "#!/labscript_suite/lyse/pull-requests/22/_/diff#comment-41557505"}}, "parent": {"id": 41505698, "links": {"self": {"href": "data/repositories/labscript_suite/lyse/pullrequests/22/comments/41505698.json"}, "html": {"href": "#!/labscript_suite/lyse/pull-requests/22/_/diff#comment-41505698"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 22, "links": {"self": {"href": "data/repositories/labscript_suite/lyse/pullrequests/22.json"}, "html": {"href": "#!/labscript_suite/lyse/pull-requests/22"}}, "title": "Unicode strings and other Python 3 forward-compatible changes."}, "content": {"raw": "I like to think that I know enough about unicode and text encoding to fix these problems \"properly\" rather than the whack-a-mole approach, but sometimes is seems like the latter is the only option on Python 2. But that's because Python 2 has serious deficiencies in this area, not our fault! It's possible to do encoding and decoding logically in Python 3. Especially since Python 3.6 now that it has `sys.getfilesystemencoding()` returning `'utf-8'` on Windows (I think that even though windows uses something else internally Python does the translation for you and presents a utf8 interface), and now that it has the 'surrogate escape' error handler (and os.fsencode/os.fsdecode methods using it) that allows invalid utf8 to sucessfully make a decode/encode round trip unchanged. It's all pretty great. Windows is strange, but even on unix the OS *says* that the files are utf8 encoded but it doesn't enforce this - you can come across files that are not valid utf8 and ultimately have to treat the filepaths as bytes. I've had a few projects hit on these issues but I think I understand things now. It's just that doing things correctly on Python 2 is next to impossible because of deficiencies in Pytohn 2 itself.\n\nAha. This makes sense. I set `__file__` to be filesystem encoded instead of leaving it as unicode - which was the right thing to do - but obviously it needs to be decoded again for h5py to make sense of it.\n\nI'll include your fix!\n\nSince similar changes need to be made throughout the labscript suite in order to port to Python 3 whist retaining backward compatibility, I might make a function in labscript_utils or zprocess to do the traceback-making, in which case it would be economical to do it \"properly\" on Python 2 - though it's definitely the case that we're going beyond the call of duty here. The mangled non-ascii character in the filepath in the traceback you posted is what I expected - I told Python to try to decode the traceback with utf8 and to replace any invalid utf8 with the unicode replacement character \"\ufffd\". So that's all good.", "markup": "markdown", "html": "<p>I like to think that I know enough about unicode and text encoding to fix these problems \"properly\" rather than the whack-a-mole approach, but sometimes is seems like the latter is the only option on Python 2. But that's because Python 2 has serious deficiencies in this area, not our fault! It's possible to do encoding and decoding logically in Python 3. Especially since Python 3.6 now that it has <code>sys.getfilesystemencoding()</code> returning <code>'utf-8'</code> on Windows (I think that even though windows uses something else internally Python does the translation for you and presents a utf8 interface), and now that it has the 'surrogate escape' error handler (and os.fsencode/os.fsdecode methods using it) that allows invalid utf8 to sucessfully make a decode/encode round trip unchanged. It's all pretty great. Windows is strange, but even on unix the OS <em>says</em> that the files are utf8 encoded but it doesn't enforce this - you can come across files that are not valid utf8 and ultimately have to treat the filepaths as bytes. I've had a few projects hit on these issues but I think I understand things now. It's just that doing things correctly on Python 2 is next to impossible because of deficiencies in Pytohn 2 itself.</p>\n<p>Aha. This makes sense. I set <code>__file__</code> to be filesystem encoded instead of leaving it as unicode - which was the right thing to do - but obviously it needs to be decoded again for h5py to make sense of it.</p>\n<p>I'll include your fix!</p>\n<p>Since similar changes need to be made throughout the labscript suite in order to port to Python 3 whist retaining backward compatibility, I might make a function in labscript_utils or zprocess to do the traceback-making, in which case it would be economical to do it \"properly\" on Python 2 - though it's definitely the case that we're going beyond the call of duty here. The mangled non-ascii character in the filepath in the traceback you posted is what I expected - I told Python to try to decode the traceback with utf8 and to replace any invalid utf8 with the unicode replacement character \"\ufffd\". So that's all good.</p>", "type": "rendered"}, "created_on": "2017-07-26T15:52:12.399068+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-07-26T15:52:12.402614+00:00", "type": "pullrequest_comment", "id": 41557505}