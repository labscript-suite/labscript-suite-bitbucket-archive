{"links": {"self": {"href": "data/repositories/labscript_suite/lyse/pullrequests/29/comments/42963644.json"}, "html": {"href": "#!/labscript_suite/lyse/pull-requests/29/_/diff#comment-42963644"}}, "parent": {"id": 42963134, "links": {"self": {"href": "data/repositories/labscript_suite/lyse/pullrequests/29/comments/42963134.json"}, "html": {"href": "#!/labscript_suite/lyse/pull-requests/29/_/diff#comment-42963134"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 29, "links": {"self": {"href": "data/repositories/labscript_suite/lyse/pullrequests/29.json"}, "html": {"href": "#!/labscript_suite/lyse/pull-requests/29"}}, "title": "Cross routine caching"}, "content": {"raw": "Files stay cached as long as you have free RAM or until something else is being cached, the former being the same limit placed on lyse - its storage will start moving to disk (if you have a swap partition/file) once it exceeds free memory. And in general the OS is better at predicting what needs to cached than we are - if it drops the cache for a file being used in analysis, it's probably because your analysis was using some other file instead, which if not cached would cause an even bigger slowdown.\n\nCould you elaborate about numbers of operations? To get an image when you are using the storage, it's a socket message, a pickling of an array, a socket reply, and then an unpickling. With reading from disk, it's a message to and from zlock, then a read from a file, then another message to and from zlock. It seems pretty comparable to me. And for 2000 files it's 2000 of one of these.", "markup": "markdown", "html": "<p>Files stay cached as long as you have free RAM or until something else is being cached, the former being the same limit placed on lyse - its storage will start moving to disk (if you have a swap partition/file) once it exceeds free memory. And in general the OS is better at predicting what needs to cached than we are - if it drops the cache for a file being used in analysis, it's probably because your analysis was using some other file instead, which if not cached would cause an even bigger slowdown.</p>\n<p>Could you elaborate about numbers of operations? To get an image when you are using the storage, it's a socket message, a pickling of an array, a socket reply, and then an unpickling. With reading from disk, it's a message to and from zlock, then a read from a file, then another message to and from zlock. It seems pretty comparable to me. And for 2000 files it's 2000 of one of these.</p>", "type": "rendered"}, "created_on": "2017-08-16T21:51:38.970828+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-08-16T21:52:04.464212+00:00", "type": "pullrequest_comment", "id": 42963644}