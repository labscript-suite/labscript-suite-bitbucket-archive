{"links": {"self": {"href": "data/repositories/labscript_suite/runviewer/pullrequests/14/comments/43318297.json"}, "html": {"href": "#!/labscript_suite/runviewer/pull-requests/14/_/diff#comment-43318297"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 14, "links": {"self": {"href": "data/repositories/labscript_suite/runviewer/pullrequests/14.json"}, "html": {"href": "#!/labscript_suite/runviewer/pull-requests/14"}}, "title": "Compiled resampler for mac"}, "content": {"raw": "So the empty string coming back is actually a bug - sort of, I haven't seen Python devs acknowledge it as a bug (you could debate that it's a bug in the `file` unix utility for identifying files). Basically the python executable is some kind of memory-layout-randomised or security-hardened or something executable that makes it look a bit odd from the perspective of unix tools trying to work out what kind of executable it is. Python defaults to giving an empty string if here if it doesn't get what it expects.\n\n`ELF` is the executable format on macos, so if you for example try this from anaconda python (probably?) you might hey that `platform.architecture()` is `'ELF'`. For me, system Python is empty string, anaconda is ELF.\n\nThe resample thing used to work on both macos and Linux with the same shared object if I recall correctly. Potentially it didn't run for you for some other reason, such as being compiled with too-old a version of numpy libraries (which I think are relevant). I'll test (at some point) if your updated shared object works on linux, and if it does we can just have it be the 'unix' shared object again.\n\nAs for the empty string bug, we should probably use some other way of checking what OS we're on - `sys.platform()` potentially, whilst still using `platform.architecture()` for whether it's 32 bit or 64 bit.", "markup": "markdown", "html": "<p>So the empty string coming back is actually a bug - sort of, I haven't seen Python devs acknowledge it as a bug (you could debate that it's a bug in the <code>file</code> unix utility for identifying files). Basically the python executable is some kind of memory-layout-randomised or security-hardened or something executable that makes it look a bit odd from the perspective of unix tools trying to work out what kind of executable it is. Python defaults to giving an empty string if here if it doesn't get what it expects.</p>\n<p><code>ELF</code> is the executable format on macos, so if you for example try this from anaconda python (probably?) you might hey that <code>platform.architecture()</code> is <code>'ELF'</code>. For me, system Python is empty string, anaconda is ELF.</p>\n<p>The resample thing used to work on both macos and Linux with the same shared object if I recall correctly. Potentially it didn't run for you for some other reason, such as being compiled with too-old a version of numpy libraries (which I think are relevant). I'll test (at some point) if your updated shared object works on linux, and if it does we can just have it be the 'unix' shared object again.</p>\n<p>As for the empty string bug, we should probably use some other way of checking what OS we're on - <code>sys.platform()</code> potentially, whilst still using <code>platform.architecture()</code> for whether it's 32 bit or 64 bit.</p>", "type": "rendered"}, "created_on": "2017-08-22T15:46:31.081956+00:00", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}, "updated_on": "2017-08-22T15:47:09.745790+00:00", "type": "pullrequest_comment", "id": 43318297}