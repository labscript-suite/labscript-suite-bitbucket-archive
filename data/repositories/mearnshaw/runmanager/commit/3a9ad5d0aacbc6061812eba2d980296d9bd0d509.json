{"rendered": {"message": {"raw": "fixes #770 (in a better way)\n\nI've modified the solution to #770 by overriding the dictionary class of the dictionary of variables passed to the eval() function. This allows us to trace which globals a particular global depends on. This was particularly important because of the following issue:\n\nImagine a global that was defined as: 7 if condition else a_list_of_values\n\nIn the previous code, the global would be found to depend on a_list_of_values regardless of the state of condition. In the new code, it determines dependencies based on what the eval() function requests access to, and so the dependencies do depend on the state of condition as one would expect.\n\nThe only \"strange\" behaviour now is if you set a global to: list_1 if za_list_of_conditions else list_2\nIn this case, the global will be added to a zip group with 'za_list_of_conditions' (note that \"if za_list_of_conditions\" always evaluates to True if it is a non empty list) rather than the more obvious option of adding it to a zip group with 'list_1'. Whether the global is added to a zip group with 'list_1' or 'za_list_of_conditions' depends on the global names (the zip group picked is the last dependency in alphabetical order). You can of course, always override the runmanager defaults yourself if you ever encounter an instance like this!", "markup": "markdown", "html": "<p>fixes #770 (in a better way)</p>\n<p>I've modified the solution to #770 by overriding the dictionary class of the dictionary of variables passed to the eval() function. This allows us to trace which globals a particular global depends on. This was particularly important because of the following issue:</p>\n<p>Imagine a global that was defined as: 7 if condition else a_list_of_values</p>\n<p>In the previous code, the global would be found to depend on a_list_of_values regardless of the state of condition. In the new code, it determines dependencies based on what the eval() function requests access to, and so the dependencies do depend on the state of condition as one would expect.</p>\n<p>The only \"strange\" behaviour now is if you set a global to: list_1 if za_list_of_conditions else list_2<br />\nIn this case, the global will be added to a zip group with 'za_list_of_conditions' (note that \"if za_list_of_conditions\" always evaluates to True if it is a non empty list) rather than the more obvious option of adding it to a zip group with 'list_1'. Whether the global is added to a zip group with 'list_1' or 'za_list_of_conditions' depends on the global names (the zip group picked is the last dependency in alphabetical order). You can of course, always override the runmanager defaults yourself if you ever encounter an instance like this!</p>", "type": "rendered"}}, "hash": "3a9ad5d0aacbc6061812eba2d980296d9bd0d509", "repository": {"links": {"self": {"href": "data/repositories/mearnshaw/runmanager.json"}, "html": {"href": "#!/mearnshaw/runmanager"}, "avatar": {"href": "data/bytebucket.org/ravatar/{aa4b3ab4-9ba3-4c29-9cea-fe61e672e182}ts=python"}}, "type": "repository", "name": "runmanager", "full_name": "mearnshaw/runmanager", "uuid": "{aa4b3ab4-9ba3-4c29-9cea-fe61e672e182}"}, "links": {"self": {"href": "data/repositories/mearnshaw/runmanager/commit/3a9ad5d0aacbc6061812eba2d980296d9bd0d509.json"}, "comments": {"href": "data/repositories/mearnshaw/runmanager/commit/3a9ad5d0aacbc6061812eba2d980296d9bd0d509/comments_page=1.json"}, "patch": {"href": "https://api.bitbucket.org/2.0/repositories/mearnshaw/runmanager/patch/3a9ad5d0aacbc6061812eba2d980296d9bd0d509"}, "html": {"href": "#!/mearnshaw/runmanager/commits/3a9ad5d0aacbc6061812eba2d980296d9bd0d509"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/mearnshaw/runmanager/diff/3a9ad5d0aacbc6061812eba2d980296d9bd0d509"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/mearnshaw/runmanager/commit/3a9ad5d0aacbc6061812eba2d980296d9bd0d509/approve"}, "statuses": {"href": "data/repositories/mearnshaw/runmanager/commit/3a9ad5d0aacbc6061812eba2d980296d9bd0d509/statuses_page=1.json"}}, "author": {"raw": "pstarkey", "type": "author", "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}}, "summary": {"raw": "fixes #770 (in a better way)\n\nI've modified the solution to #770 by overriding the dictionary class of the dictionary of variables passed to the eval() function. This allows us to trace which globals a particular global depends on. This was particularly important because of the following issue:\n\nImagine a global that was defined as: 7 if condition else a_list_of_values\n\nIn the previous code, the global would be found to depend on a_list_of_values regardless of the state of condition. In the new code, it determines dependencies based on what the eval() function requests access to, and so the dependencies do depend on the state of condition as one would expect.\n\nThe only \"strange\" behaviour now is if you set a global to: list_1 if za_list_of_conditions else list_2\nIn this case, the global will be added to a zip group with 'za_list_of_conditions' (note that \"if za_list_of_conditions\" always evaluates to True if it is a non empty list) rather than the more obvious option of adding it to a zip group with 'list_1'. Whether the global is added to a zip group with 'list_1' or 'za_list_of_conditions' depends on the global names (the zip group picked is the last dependency in alphabetical order). You can of course, always override the runmanager defaults yourself if you ever encounter an instance like this!", "markup": "markdown", "html": "<p>fixes #770 (in a better way)</p>\n<p>I've modified the solution to #770 by overriding the dictionary class of the dictionary of variables passed to the eval() function. This allows us to trace which globals a particular global depends on. This was particularly important because of the following issue:</p>\n<p>Imagine a global that was defined as: 7 if condition else a_list_of_values</p>\n<p>In the previous code, the global would be found to depend on a_list_of_values regardless of the state of condition. In the new code, it determines dependencies based on what the eval() function requests access to, and so the dependencies do depend on the state of condition as one would expect.</p>\n<p>The only \"strange\" behaviour now is if you set a global to: list_1 if za_list_of_conditions else list_2<br />\nIn this case, the global will be added to a zip group with 'za_list_of_conditions' (note that \"if za_list_of_conditions\" always evaluates to True if it is a non empty list) rather than the more obvious option of adding it to a zip group with 'list_1'. Whether the global is added to a zip group with 'list_1' or 'za_list_of_conditions' depends on the global names (the zip group picked is the last dependency in alphabetical order). You can of course, always override the runmanager defaults yourself if you ever encounter an instance like this!</p>", "type": "rendered"}, "participants": [], "parents": [{"hash": "33b0a09ca53f43c083b5f224387807e19cd53fb2", "type": "commit", "links": {"self": {"href": "data/repositories/mearnshaw/runmanager/commit/33b0a09ca53f43c083b5f224387807e19cd53fb2.json"}, "html": {"href": "#!/mearnshaw/runmanager/commits/33b0a09ca53f43c083b5f224387807e19cd53fb2"}}}], "date": "2013-09-24T08:19:41+00:00", "message": "fixes #770 (in a better way)\n\nI've modified the solution to #770 by overriding the dictionary class of the dictionary of variables passed to the eval() function. This allows us to trace which globals a particular global depends on. This was particularly important because of the following issue:\n\nImagine a global that was defined as: 7 if condition else a_list_of_values\n\nIn the previous code, the global would be found to depend on a_list_of_values regardless of the state of condition. In the new code, it determines dependencies based on what the eval() function requests access to, and so the dependencies do depend on the state of condition as one would expect.\n\nThe only \"strange\" behaviour now is if you set a global to: list_1 if za_list_of_conditions else list_2\nIn this case, the global will be added to a zip group with 'za_list_of_conditions' (note that \"if za_list_of_conditions\" always evaluates to True if it is a non empty list) rather than the more obvious option of adding it to a zip group with 'list_1'. Whether the global is added to a zip group with 'list_1' or 'za_list_of_conditions' depends on the global names (the zip group picked is the last dependency in alphabetical order). You can of course, always override the runmanager defaults yourself if you ever encounter an instance like this!", "type": "commit", "git_hash": "3f31b682b81dc4251dc8f129c53f1f65684eee1a", "tags": null, "branches": "default"}