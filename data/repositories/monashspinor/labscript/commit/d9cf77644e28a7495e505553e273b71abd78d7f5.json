{"rendered": {"message": {"raw": "Added the ability to trigger pulseblasters, either via a software trigger or a hardware trigger (note that the software trigger is not implemented in BLACS yet).\n\nNOTE: ALL PULSBLASTERS MUST BE TRIGGERED USING THIS NEW CODE\n\nExample:\n# Here we 'software' trigger a pulseblaster at t=0.\n# Note this doesn't actually do anything yet, but is needed!\nt=0\npulseblaster_0.trigger(t,'software')\n# Here we trigger a pulseblaster using a digital channel called pb_1_trigger\n# Note that if you trigger at t=0, you must have left the trigger HIGH\n# at the end of the last experiment, or else you will leave your\n# pulseblaster in a state that continually triggers itself\nt+=7\npulseblaster_1.trigger(t,pb_1_trigger)\n\nNow that you have triggered pulseblaster_1 at t=7s, times given to channels on this pulseblaster should be referenced to t=0 (the start of the entire experiment). So ao.constant(8,3,'A') will set the channel ao to 3A 1s after triggering the pulseblaster at t=7s\n\nSIMPLE IMPLEMENTATION: If you wish to edit your code as little as possible, just software trigger pulseblaster0, and hardware trigger the other pulseblasters using the above syntax at t=0\n\nFurthermore, to facilitate this feature, the ramping functions in functions.py now return a lambda function which takes t-t0 as a parameter, where t0 is the start time of the ramp, and t is the time at which you wish to evaluate the function. This will not affect using the ramp functions of the AnalogQuantity, but will affect your code if you directly call functions.ramp etc.\n\nTODO: Take into account the minor delay between sending the trigger signal, and triggering the Pulseblaster (on the order of 10s of nanoseconds)", "markup": "markdown", "html": "<p>Added the ability to trigger pulseblasters, either via a software trigger or a hardware trigger (note that the software trigger is not implemented in BLACS yet).</p>\n<p>NOTE: ALL PULSBLASTERS MUST BE TRIGGERED USING THIS NEW CODE</p>\n<p>Example:</p>\n<h1 id=\"markdown-header-here-we-software-trigger-a-pulseblaster-at-t0\">Here we 'software' trigger a pulseblaster at t=0.</h1>\n<h1 id=\"markdown-header-note-this-doesnt-actually-do-anything-yet-but-is-needed\">Note this doesn't actually do anything yet, but is needed!</h1>\n<p>t=0<br />\npulseblaster_0.trigger(t,'software')</p>\n<h1 id=\"markdown-header-here-we-trigger-a-pulseblaster-using-a-digital-channel-called-pb_1_trigger\">Here we trigger a pulseblaster using a digital channel called pb_1_trigger</h1>\n<h1 id=\"markdown-header-note-that-if-you-trigger-at-t0-you-must-have-left-the-trigger-high\">Note that if you trigger at t=0, you must have left the trigger HIGH</h1>\n<h1 id=\"markdown-header-at-the-end-of-the-last-experiment-or-else-you-will-leave-your\">at the end of the last experiment, or else you will leave your</h1>\n<h1 id=\"markdown-header-pulseblaster-in-a-state-that-continually-triggers-itself\">pulseblaster in a state that continually triggers itself</h1>\n<p>t+=7<br />\npulseblaster_1.trigger(t,pb_1_trigger)</p>\n<p>Now that you have triggered pulseblaster_1 at t=7s, times given to channels on this pulseblaster should be referenced to t=0 (the start of the entire experiment). So ao.constant(8,3,'A') will set the channel ao to 3A 1s after triggering the pulseblaster at t=7s</p>\n<p>SIMPLE IMPLEMENTATION: If you wish to edit your code as little as possible, just software trigger pulseblaster0, and hardware trigger the other pulseblasters using the above syntax at t=0</p>\n<p>Furthermore, to facilitate this feature, the ramping functions in functions.py now return a lambda function which takes t-t0 as a parameter, where t0 is the start time of the ramp, and t is the time at which you wish to evaluate the function. This will not affect using the ramp functions of the AnalogQuantity, but will affect your code if you directly call functions.ramp etc.</p>\n<p>TODO: Take into account the minor delay between sending the trigger signal, and triggering the Pulseblaster (on the order of 10s of nanoseconds)</p>", "type": "rendered"}}, "hash": "d9cf77644e28a7495e505553e273b71abd78d7f5", "repository": {"links": {"self": {"href": "data/repositories/monashspinor/labscript.json"}, "html": {"href": "#!/monashspinor/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{73852c03-7486-4603-be8a-3bf277ec77cc}ts=python"}}, "type": "repository", "name": "labscript", "full_name": "monashspinor/labscript", "uuid": "{73852c03-7486-4603-be8a-3bf277ec77cc}"}, "links": {"self": {"href": "data/repositories/monashspinor/labscript/commit/d9cf77644e28a7495e505553e273b71abd78d7f5.json"}, "comments": {"href": "data/repositories/monashspinor/labscript/commit/d9cf77644e28a7495e505553e273b71abd78d7f5/comments_page=1.json"}, "patch": {"href": "https://api.bitbucket.org/2.0/repositories/monashspinor/labscript/patch/d9cf77644e28a7495e505553e273b71abd78d7f5"}, "html": {"href": "#!/monashspinor/labscript/commits/d9cf77644e28a7495e505553e273b71abd78d7f5"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/monashspinor/labscript/diff/d9cf77644e28a7495e505553e273b71abd78d7f5"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/monashspinor/labscript/commit/d9cf77644e28a7495e505553e273b71abd78d7f5/approve"}, "statuses": {"href": "data/repositories/monashspinor/labscript/commit/d9cf77644e28a7495e505553e273b71abd78d7f5/statuses_page=1.json"}}, "author": {"raw": "pstarkey", "type": "author", "user": {"display_name": "Philip Starkey", "uuid": "{48af65db-e5fc-459c-a7eb-52eb1f9a5690}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D"}, "html": {"href": "https://bitbucket.org/%7B48af65db-e5fc-459c-a7eb-52eb1f9a5690%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/dc318537facc47ebe1ae98a7aabacecfd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsPS-0.png"}}, "nickname": "pstarkey", "type": "user", "account_id": "557058:52a111e4-40da-4441-9143-417f95f2db97"}}, "summary": {"raw": "Added the ability to trigger pulseblasters, either via a software trigger or a hardware trigger (note that the software trigger is not implemented in BLACS yet).\n\nNOTE: ALL PULSBLASTERS MUST BE TRIGGERED USING THIS NEW CODE\n\nExample:\n# Here we 'software' trigger a pulseblaster at t=0.\n# Note this doesn't actually do anything yet, but is needed!\nt=0\npulseblaster_0.trigger(t,'software')\n# Here we trigger a pulseblaster using a digital channel called pb_1_trigger\n# Note that if you trigger at t=0, you must have left the trigger HIGH\n# at the end of the last experiment, or else you will leave your\n# pulseblaster in a state that continually triggers itself\nt+=7\npulseblaster_1.trigger(t,pb_1_trigger)\n\nNow that you have triggered pulseblaster_1 at t=7s, times given to channels on this pulseblaster should be referenced to t=0 (the start of the entire experiment). So ao.constant(8,3,'A') will set the channel ao to 3A 1s after triggering the pulseblaster at t=7s\n\nSIMPLE IMPLEMENTATION: If you wish to edit your code as little as possible, just software trigger pulseblaster0, and hardware trigger the other pulseblasters using the above syntax at t=0\n\nFurthermore, to facilitate this feature, the ramping functions in functions.py now return a lambda function which takes t-t0 as a parameter, where t0 is the start time of the ramp, and t is the time at which you wish to evaluate the function. This will not affect using the ramp functions of the AnalogQuantity, but will affect your code if you directly call functions.ramp etc.\n\nTODO: Take into account the minor delay between sending the trigger signal, and triggering the Pulseblaster (on the order of 10s of nanoseconds)", "markup": "markdown", "html": "<p>Added the ability to trigger pulseblasters, either via a software trigger or a hardware trigger (note that the software trigger is not implemented in BLACS yet).</p>\n<p>NOTE: ALL PULSBLASTERS MUST BE TRIGGERED USING THIS NEW CODE</p>\n<p>Example:</p>\n<h1 id=\"markdown-header-here-we-software-trigger-a-pulseblaster-at-t0\">Here we 'software' trigger a pulseblaster at t=0.</h1>\n<h1 id=\"markdown-header-note-this-doesnt-actually-do-anything-yet-but-is-needed\">Note this doesn't actually do anything yet, but is needed!</h1>\n<p>t=0<br />\npulseblaster_0.trigger(t,'software')</p>\n<h1 id=\"markdown-header-here-we-trigger-a-pulseblaster-using-a-digital-channel-called-pb_1_trigger\">Here we trigger a pulseblaster using a digital channel called pb_1_trigger</h1>\n<h1 id=\"markdown-header-note-that-if-you-trigger-at-t0-you-must-have-left-the-trigger-high\">Note that if you trigger at t=0, you must have left the trigger HIGH</h1>\n<h1 id=\"markdown-header-at-the-end-of-the-last-experiment-or-else-you-will-leave-your\">at the end of the last experiment, or else you will leave your</h1>\n<h1 id=\"markdown-header-pulseblaster-in-a-state-that-continually-triggers-itself\">pulseblaster in a state that continually triggers itself</h1>\n<p>t+=7<br />\npulseblaster_1.trigger(t,pb_1_trigger)</p>\n<p>Now that you have triggered pulseblaster_1 at t=7s, times given to channels on this pulseblaster should be referenced to t=0 (the start of the entire experiment). So ao.constant(8,3,'A') will set the channel ao to 3A 1s after triggering the pulseblaster at t=7s</p>\n<p>SIMPLE IMPLEMENTATION: If you wish to edit your code as little as possible, just software trigger pulseblaster0, and hardware trigger the other pulseblasters using the above syntax at t=0</p>\n<p>Furthermore, to facilitate this feature, the ramping functions in functions.py now return a lambda function which takes t-t0 as a parameter, where t0 is the start time of the ramp, and t is the time at which you wish to evaluate the function. This will not affect using the ramp functions of the AnalogQuantity, but will affect your code if you directly call functions.ramp etc.</p>\n<p>TODO: Take into account the minor delay between sending the trigger signal, and triggering the Pulseblaster (on the order of 10s of nanoseconds)</p>", "type": "rendered"}, "participants": [], "parents": [{"hash": "96123e46450d3db6e2c0d3b7506f83f788f56986", "type": "commit", "links": {"self": {"href": "data/repositories/monashspinor/labscript/commit/96123e46450d3db6e2c0d3b7506f83f788f56986.json"}, "html": {"href": "#!/monashspinor/labscript/commits/96123e46450d3db6e2c0d3b7506f83f788f56986"}}}], "date": "2012-07-30T06:27:49+00:00", "message": "Added the ability to trigger pulseblasters, either via a software trigger or a hardware trigger (note that the software trigger is not implemented in BLACS yet).\n\nNOTE: ALL PULSBLASTERS MUST BE TRIGGERED USING THIS NEW CODE\n\nExample:\n# Here we 'software' trigger a pulseblaster at t=0.\n# Note this doesn't actually do anything yet, but is needed!\nt=0\npulseblaster_0.trigger(t,'software')\n# Here we trigger a pulseblaster using a digital channel called pb_1_trigger\n# Note that if you trigger at t=0, you must have left the trigger HIGH\n# at the end of the last experiment, or else you will leave your\n# pulseblaster in a state that continually triggers itself\nt+=7\npulseblaster_1.trigger(t,pb_1_trigger)\n\nNow that you have triggered pulseblaster_1 at t=7s, times given to channels on this pulseblaster should be referenced to t=0 (the start of the entire experiment). So ao.constant(8,3,'A') will set the channel ao to 3A 1s after triggering the pulseblaster at t=7s\n\nSIMPLE IMPLEMENTATION: If you wish to edit your code as little as possible, just software trigger pulseblaster0, and hardware trigger the other pulseblasters using the above syntax at t=0\n\nFurthermore, to facilitate this feature, the ramping functions in functions.py now return a lambda function which takes t-t0 as a parameter, where t0 is the start time of the ramp, and t is the time at which you wish to evaluate the function. This will not affect using the ramp functions of the AnalogQuantity, but will affect your code if you directly call functions.ramp etc.\n\nTODO: Take into account the minor delay between sending the trigger signal, and triggering the Pulseblaster (on the order of 10s of nanoseconds)", "type": "commit", "git_hash": "3aad492049c6f7974ed27f912de810a55a09eb64", "tags": null, "branches": "default"}