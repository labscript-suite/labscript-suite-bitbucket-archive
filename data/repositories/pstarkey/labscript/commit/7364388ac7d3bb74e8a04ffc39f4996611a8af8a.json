{"rendered": {"message": {"raw": "Made some changes as discussed today with the Phil and Russ, regarding interactions with the LabVIEW control system.\n\n1. Numbering of devices now starts from zero.\n\n2. No initial pulse program instruction is issued putting the clock flags into the correct state to start ticking. Instead, LabVIEW will\n   program this instruction, as it can keep all the other flags in the state they are in the front panel. Previously labscript just set them to zero.\n   This should avoid accidental triggering and closing of shutters etc. A smooth transition from state-of-the-front-panel to labscript's initial instruction\n   is important for avoiding these problems.\n\n3. In the same vein, the end of the pulse program is now handled differently. The second last instruction is a WAIT instruction, and LabVIEW will know that the\n   program is finished by polling the pulseblaster's status to see if it's waiting (and if there is more than one WAIT instruction in the program, LabVIEW can count them.)\n   Then LabVIEW programs instruction zero with the front panel state, and then sends a software trigger telling the pulse program to resume. The program moves to its\n   final instruction, which is to brach to line zero. Then the system ends up in the state of the front panel without missing a beat. Again, this is important so that there\n   are no intermediate states between buffered output and front panel states. There should always be a direct transition from one to the other with nothing in between.\n\n4. Code generation now works. Run:\n\n         utils/edit_connections.py infile.h5 outfile.py\n\n   to generate a minimalistic labscript from the connection table in the already-compiled infile.h5. Still needing to be done is to make this automatically open in a text editor,\n   and then when the text editor is closed to make it compile and generate a hdf5 file with the new connection table. In that case I should probably make the intermediate .py file just\n   a temporary file, and have the user instead specify the desired output hdf5 file to compile the minimalistic labscript to.", "markup": "markdown", "html": "<p>Made some changes as discussed today with the Phil and Russ, regarding interactions with the LabVIEW control system.</p>\n<ol>\n<li>\n<p>Numbering of devices now starts from zero.</p>\n</li>\n<li>\n<p>No initial pulse program instruction is issued putting the clock flags into the correct state to start ticking. Instead, LabVIEW will<br />\n   program this instruction, as it can keep all the other flags in the state they are in the front panel. Previously labscript just set them to zero.<br />\n   This should avoid accidental triggering and closing of shutters etc. A smooth transition from state-of-the-front-panel to labscript's initial instruction<br />\n   is important for avoiding these problems.</p>\n</li>\n<li>\n<p>In the same vein, the end of the pulse program is now handled differently. The second last instruction is a WAIT instruction, and LabVIEW will know that the<br />\n   program is finished by polling the pulseblaster's status to see if it's waiting (and if there is more than one WAIT instruction in the program, LabVIEW can count them.)<br />\n   Then LabVIEW programs instruction zero with the front panel state, and then sends a software trigger telling the pulse program to resume. The program moves to its<br />\n   final instruction, which is to brach to line zero. Then the system ends up in the state of the front panel without missing a beat. Again, this is important so that there<br />\n   are no intermediate states between buffered output and front panel states. There should always be a direct transition from one to the other with nothing in between.</p>\n</li>\n<li>\n<p>Code generation now works. Run:</p>\n<div class=\"codehilite\"><pre><span></span> utils/edit_connections.py infile.h5 outfile.py\n</pre></div>\n\n\n</li>\n</ol>\n<p>to generate a minimalistic labscript from the connection table in the already-compiled infile.h5. Still needing to be done is to make this automatically open in a text editor,<br />\n   and then when the text editor is closed to make it compile and generate a hdf5 file with the new connection table. In that case I should probably make the intermediate .py file just<br />\n   a temporary file, and have the user instead specify the desired output hdf5 file to compile the minimalistic labscript to.</p>", "type": "rendered"}}, "hash": "7364388ac7d3bb74e8a04ffc39f4996611a8af8a", "repository": {"links": {"self": {"href": "data/repositories/pstarkey/labscript.json"}, "html": {"href": "#!/pstarkey/labscript"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e07b8a11-58d9-46da-8368-724e708c5ac1}ts=python"}}, "type": "repository", "name": "labscript", "full_name": "pstarkey/labscript", "uuid": "{e07b8a11-58d9-46da-8368-724e708c5ac1}"}, "links": {"self": {"href": "data/repositories/pstarkey/labscript/commit/7364388ac7d3bb74e8a04ffc39f4996611a8af8a.json"}, "comments": {"href": "data/repositories/pstarkey/labscript/commit/7364388ac7d3bb74e8a04ffc39f4996611a8af8a/comments_page=1.json"}, "patch": {"href": "https://api.bitbucket.org/2.0/repositories/pstarkey/labscript/patch/7364388ac7d3bb74e8a04ffc39f4996611a8af8a"}, "html": {"href": "#!/pstarkey/labscript/commits/7364388ac7d3bb74e8a04ffc39f4996611a8af8a"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/pstarkey/labscript/diff/7364388ac7d3bb74e8a04ffc39f4996611a8af8a"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/pstarkey/labscript/commit/7364388ac7d3bb74e8a04ffc39f4996611a8af8a/approve"}, "statuses": {"href": "data/repositories/pstarkey/labscript/commit/7364388ac7d3bb74e8a04ffc39f4996611a8af8a/statuses_page=1.json"}}, "author": {"raw": "cbilling", "type": "author", "user": {"display_name": "Chris Billington", "uuid": "{e363c5a9-5075-4656-afb5-88bd6a6dceeb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D"}, "html": {"href": "https://bitbucket.org/%7Be363c5a9-5075-4656-afb5-88bd6a6dceeb%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/9238baf7300c41c0e7294db922899e6ad=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCB-1.png"}}, "nickname": "cbillington", "type": "user", "account_id": "557058:cbf1bc43-1dc2-477b-9e25-1a8f40fd7ee3"}}, "summary": {"raw": "Made some changes as discussed today with the Phil and Russ, regarding interactions with the LabVIEW control system.\n\n1. Numbering of devices now starts from zero.\n\n2. No initial pulse program instruction is issued putting the clock flags into the correct state to start ticking. Instead, LabVIEW will\n   program this instruction, as it can keep all the other flags in the state they are in the front panel. Previously labscript just set them to zero.\n   This should avoid accidental triggering and closing of shutters etc. A smooth transition from state-of-the-front-panel to labscript's initial instruction\n   is important for avoiding these problems.\n\n3. In the same vein, the end of the pulse program is now handled differently. The second last instruction is a WAIT instruction, and LabVIEW will know that the\n   program is finished by polling the pulseblaster's status to see if it's waiting (and if there is more than one WAIT instruction in the program, LabVIEW can count them.)\n   Then LabVIEW programs instruction zero with the front panel state, and then sends a software trigger telling the pulse program to resume. The program moves to its\n   final instruction, which is to brach to line zero. Then the system ends up in the state of the front panel without missing a beat. Again, this is important so that there\n   are no intermediate states between buffered output and front panel states. There should always be a direct transition from one to the other with nothing in between.\n\n4. Code generation now works. Run:\n\n         utils/edit_connections.py infile.h5 outfile.py\n\n   to generate a minimalistic labscript from the connection table in the already-compiled infile.h5. Still needing to be done is to make this automatically open in a text editor,\n   and then when the text editor is closed to make it compile and generate a hdf5 file with the new connection table. In that case I should probably make the intermediate .py file just\n   a temporary file, and have the user instead specify the desired output hdf5 file to compile the minimalistic labscript to.", "markup": "markdown", "html": "<p>Made some changes as discussed today with the Phil and Russ, regarding interactions with the LabVIEW control system.</p>\n<ol>\n<li>\n<p>Numbering of devices now starts from zero.</p>\n</li>\n<li>\n<p>No initial pulse program instruction is issued putting the clock flags into the correct state to start ticking. Instead, LabVIEW will<br />\n   program this instruction, as it can keep all the other flags in the state they are in the front panel. Previously labscript just set them to zero.<br />\n   This should avoid accidental triggering and closing of shutters etc. A smooth transition from state-of-the-front-panel to labscript's initial instruction<br />\n   is important for avoiding these problems.</p>\n</li>\n<li>\n<p>In the same vein, the end of the pulse program is now handled differently. The second last instruction is a WAIT instruction, and LabVIEW will know that the<br />\n   program is finished by polling the pulseblaster's status to see if it's waiting (and if there is more than one WAIT instruction in the program, LabVIEW can count them.)<br />\n   Then LabVIEW programs instruction zero with the front panel state, and then sends a software trigger telling the pulse program to resume. The program moves to its<br />\n   final instruction, which is to brach to line zero. Then the system ends up in the state of the front panel without missing a beat. Again, this is important so that there<br />\n   are no intermediate states between buffered output and front panel states. There should always be a direct transition from one to the other with nothing in between.</p>\n</li>\n<li>\n<p>Code generation now works. Run:</p>\n<div class=\"codehilite\"><pre><span></span> utils/edit_connections.py infile.h5 outfile.py\n</pre></div>\n\n\n</li>\n</ol>\n<p>to generate a minimalistic labscript from the connection table in the already-compiled infile.h5. Still needing to be done is to make this automatically open in a text editor,<br />\n   and then when the text editor is closed to make it compile and generate a hdf5 file with the new connection table. In that case I should probably make the intermediate .py file just<br />\n   a temporary file, and have the user instead specify the desired output hdf5 file to compile the minimalistic labscript to.</p>", "type": "rendered"}, "participants": [], "parents": [{"hash": "a84deec20212bd8049e6e6b1b4b513a8430d8713", "type": "commit", "links": {"self": {"href": "data/repositories/pstarkey/labscript/commit/a84deec20212bd8049e6e6b1b4b513a8430d8713.json"}, "html": {"href": "#!/pstarkey/labscript/commits/a84deec20212bd8049e6e6b1b4b513a8430d8713"}}}], "date": "2011-04-14T05:24:43+00:00", "message": "Made some changes as discussed today with the Phil and Russ, regarding interactions with the LabVIEW control system.\n\n1. Numbering of devices now starts from zero.\n\n2. No initial pulse program instruction is issued putting the clock flags into the correct state to start ticking. Instead, LabVIEW will\n   program this instruction, as it can keep all the other flags in the state they are in the front panel. Previously labscript just set them to zero.\n   This should avoid accidental triggering and closing of shutters etc. A smooth transition from state-of-the-front-panel to labscript's initial instruction\n   is important for avoiding these problems.\n\n3. In the same vein, the end of the pulse program is now handled differently. The second last instruction is a WAIT instruction, and LabVIEW will know that the\n   program is finished by polling the pulseblaster's status to see if it's waiting (and if there is more than one WAIT instruction in the program, LabVIEW can count them.)\n   Then LabVIEW programs instruction zero with the front panel state, and then sends a software trigger telling the pulse program to resume. The program moves to its\n   final instruction, which is to brach to line zero. Then the system ends up in the state of the front panel without missing a beat. Again, this is important so that there\n   are no intermediate states between buffered output and front panel states. There should always be a direct transition from one to the other with nothing in between.\n\n4. Code generation now works. Run:\n\n         utils/edit_connections.py infile.h5 outfile.py\n\n   to generate a minimalistic labscript from the connection table in the already-compiled infile.h5. Still needing to be done is to make this automatically open in a text editor,\n   and then when the text editor is closed to make it compile and generate a hdf5 file with the new connection table. In that case I should probably make the intermediate .py file just\n   a temporary file, and have the user instead specify the desired output hdf5 file to compile the minimalistic labscript to.", "type": "commit", "git_hash": "a5dcc6b2092cf076918d9fcd161650de7e7e6ddf", "tags": null, "branches": "default"}